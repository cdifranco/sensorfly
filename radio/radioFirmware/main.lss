
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000006c6  00800100  00008d1a  00008dae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008d1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000089a  008007c6  008007c6  00009474  2**0
                  ALLOC
  3 .stab         0000b868  00000000  00000000  00009474  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004761  00000000  00000000  00014cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  0001943d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000104  00000000  00000000  0001953d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000109f  00000000  00000000  00019641  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000091c  00000000  00000000  0001a6e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e7d  00000000  00000000  0001affc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000100  00000000  00000000  0001be7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000295  00000000  00000000  0001bf7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000c31  00000000  00000000  0001c211  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000d8  00000000  00000000  0001ce42  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b5 04 	jmp	0x96a	; 0x96a <__ctors_end>
       4:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
       8:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
       c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      10:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      14:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      18:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      1c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      20:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      24:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      28:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      2c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      30:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      34:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      38:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      3c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      40:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      44:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      48:	0c 94 c2 17 	jmp	0x2f84	; 0x2f84 <__vector_18>
      4c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      50:	0c 94 f5 17 	jmp	0x2fea	; 0x2fea <__vector_20>
      54:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      58:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      5c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      60:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      64:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      68:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>
      6c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__bad_interrupt>

00000070 <__c.1790>:
      70:	6e 61 6e 00                                         nan.

00000074 <__c.1788>:
      74:	69 6e 66 00                                         inf.

00000078 <ntrxInitShadowReg>:
      78:	00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 00     ................
      88:	00 00 00 00 00 00 40 00 20 40 00 20 00 00 00 03     ......@. @. ....
      98:	06 98 0c 00 02 3f 1e 06 00 00 ab 2c d5 92 94 ca     .....?.....,....
      a8:	69 ab 30 00 00 00 00 00 00 00 00 00 e0 04 00 01     i.0.............
      b8:	03 07 00 03 3f 3f 0f 0f 73 00 10 10 43 14 10 00     ....??..s...C...
      c8:	00 7f 00 00 00 00 00 00 00 00 0b 5f 05 07 d5 62     ..........._...b
      d8:	00 00 00 0c 0a 00 00 00 00 00 00 00 00 00 00 00     ................
	...
      f4:	00 50 00 00                                         .P..

000000f8 <NA5TR1_Rx_80MHz_500ns>:
      f8:	08 07 38 e0 ff ff e0 e3 9c 0e 63 87 f0 01 fc 38     ..8.......c....8
     108:	ce                                                  .

00000109 <NA5TR1_Rx_80MHz_1000ns>:
     109:	10 02 63 39 c7 0e 0f c0 1f ff e0 0f c3 c3 8e 73     ..c9...........s
     119:	39 00 ce 63 1c 38 3e 03 ff ff ff 01 f0 f0 e7 19     9..c.8>.........
     129:	8c                                                  .

0000012a <NA5TR1_Rx_80MHz_2000ns>:
     12a:	1f 0c cc e6 73 1c e3 8e 1c 3c 3e 0f c0 7f e0 00     ....s....<>.....
     13a:	00 00 00 7f c0 3f 07 c3 c3 87 1c 73 9c e6 63 33     .....?.....s..c3
     14a:	09 99 8c c6 31 ce 3c 70 f0 f0 7e 03 fc 00 1f ff     ....1.<p..~.....
     15a:	ff 80 03 fc 07 c1 f0 f0 e3 8e 38 c6 73 31 99        ..........8.s1.

00000169 <NA5TR1_Rx_80MHz_4000ns>:
     169:	20 ff ff ff c0 00 ff c0 1f c0 7e 07 c1 f0 f8 78      .........~....x
     179:	78 f1 e3 87 1c 63 8c 73 9c e6 33 99 98 cc cc c0     x....c.s..3.....
     189:	00 00 01 ff ff c0 03 fe 01 fc 0f c1 f8 3c 1e 1e     .............<..
     199:	1e 3c 78 e3 8e 38 c7 38 c6 73 99 cc ce 66 66 60     .<x..8.8.s...ff`
	...

000001aa <NA5TR1_Rx_22MHz_1000ns>:
     1aa:	04 c6 0f f0 63 9c 7f fe 39                          ....c...9

000001b3 <NA5TR1_Rx_22MHz_2000ns>:
     1b3:	08 99 c7 0f e0 07 f0 e3 99 33 1c 3e 00 00 7c 38     .........3.>..|8
     1c3:	cc                                                  .

000001c4 <NA5TR1_Rx_22MHz_4000ns>:
     1c4:	10 93 19 ce 38 70 7e 00 ff ff 00 7e 0e 1c 73 98     ....8p~....~..s.
     1d4:	c9 26 33 1c e1 c1 f0 1f ff ff f8 0f 83 87 38 cc     .&3...........8.
     1e4:	64                                                  d

000001e5 <NA5TR1_Tx_80MHz_500ns>:
     1e5:	3d e0 9c 5c ef eb 4a 86 6a bf ac 8b 01 15 f2 7f     =..\..J.j.......
     1f5:	f6 df ca 40 84 51 21 6f 39 fe ff 3e bb 39 b7 b6     ...@.Q!o9..>.9..
     205:	f6 78 fa bc ff bf 7c f5 68 59 0a 01 83 d3 ab fd     .x....|.hY......
     215:	bb 64 48 c2 1a fa b9 96 81 db f3 25 1a 1f f7 e6     .dH........%....
     225:	89 6c b6 d0 25 de 0e 36 80 62 d9 9e 1f 9a 04 90     .l..%..6.b......
     235:	c0 f2 b6 fa bd 2f 8f ef 6f 0e de ad 9d ad be ee     ...../..o.......
     245:	3f af 3f de 7b e8 e4 61 60 12 27 2d 4f fc f5 40     ?.?.{..a`.'-O..@
     255:	62 0b ef 2a e1 e2 5a 9b b7 27 e8 79 89 ae 66 14     b..*..Z..'.y..f.
     265:	78 fb cb 3a 00 58 d2 ff bf 52 08 08 44 99 da fb     x..:.X...R..D...
     275:	fb df b7 8e 69 4d 39 2c 28 24 28 34 40 59 79 a2     ....iM9,($(4@Yy.
     285:	ca ef ff ef bf 72 25 00 24 85 e6 f7 9b 21 0c 80     .....r%.$....!..
     295:	f7 cb 35 2c 99 a2 7a 7d                             ..5,..z}

0000029d <NA5TR1_Tx_80MHz_1000ns>:
     29d:	3d 20 e0 1d de 27 a3 12 17 f1 b1 10 04 a4 ff 6d     = ...'.........m
     2ad:	09 03 e2 bd 75 d4 c0 0d 2c 7f 35 19 03 c3 57 b1     ....u...,.5...W.
     2bd:	bf 39 a5 cf 02 c2 0f e2 73 fd fe 77 ea 5b 4f 85     .9......s..w.[O.
     2cd:	01 80 84 49 10 d7 9e e4 2a ee b1 33 75 75 08 f7     ...I....*..3uu..
     2dd:	f7 48 1a 56 a4 09 cd e8 81 a4 ed 4e 36 a0 e4 fc     .H.V.......N6...
     2ed:	9f 89 21 c0 97 de 5f 9a 13 20 d2 e9 ae 5f dc 16     ..!..._.. ..._..
     2fd:	51 60 b1 a6 fa 8e 9f 9e ac 28 05 52 e0 90 40 e1     Q`.......(.R..@.
     30d:	63 b5 e6 f8 f9 db cb ac 8d 7d 6d 7e 79 85 96 6e     c........}m~y..n
     31d:	51 95 cf 7a 14 5c ea db 42 04 6c ee e3 62 04 30     Q..z.\..B.l..b.0
     32d:	b1 ff cf 56 04 1c 7d e2 ff c7 62 14 04 30 81 d2     ...V..}...b..0..
     33d:	fb f7 c7 86 45 14 00 08 24 4c 7d a6 ca e7 f7 ff     ....E...$L}.....
     34d:	ff fb f7 ef e7 e3 df db                             ........

00000355 <NA5TR1_Tx_80MHz_2000ns>:
     355:	7a 1f 20 e0 9e 5f a3 20 da 1f e8 a1 14 5b ee 29     z. .._. .....[.)
     365:	d0 50 ac b5 99 c4 9c 3b 70 4b 84 e6 bf eb 07 c5     .P.....;pK......
     375:	e6 3f 6f 4c c1 9c fb 39 db 41 09 e9 7e b4 15 41     .?oL...9.A..~..A
     385:	ca 27 fd b9 5f 06 42 15 b1 7f b6 1d 46 81 cf e8     .'.._.B.....F...
     395:	fb 3e 2f 58 45 00 4b a0 f4 fe bc 2d 5a c9 00 03     .>/XE.K....-Z...
     3a5:	cf 60 f1 bc 7f 3a ae df d1 86 00 01 07 d1 dd a9     .`...:..........
     3b5:	f3 7a fe bf bc 37 30 28 20 58 91 4c 47 84 42 00     .z...70( X.LG.B.
     3c5:	00 40 81 c2 04 45 c6 07 08 49 49 08 08 f7 f7 28     .@...E...II....(
     3d5:	08 b7 f6 79 19 56 c5 d9 6b 17 32 e7 2d 5a 72 12     ...y.V..k.2.-Zr.
     3e5:	cb af 67 90 e4 ed 2e 25 c0 04 ed 4f 47 70 92 fb     ..g....%...OGp..
     3f5:	0f eb 02 60 66 ed 6f 89 22 90 65 ed af db 04 d0     ...`f.o.".e.....
     405:	92 d9 ae 3f 9a 04 d0 61 a6 ec ff 7e 49 13 e0 41     ...?...a...~I..A
     415:	85 fa 8e 6f 1d 39 14 a0 b0 d2 a5 fa ad df df ed     ...o.9..........
     425:	39 05 42 d0 a0 81 43 c5 f8 eb 8d 0f 6f cf 2e ad     9.B...C.....o...
     435:	5b 19 07 15 33 72 c1 10 60 b0 00 40 80 b0 e1 01     [...3r..`..@....
     445:	21 42 52 52 62 82 7e 7d 85 86 76 71 91 9a 6a 59     !BRRb.~}..vq..jY
     455:	99 b6 6e 35 81 d6 9b 25 40 ce e3 5a 04 68 f2 d3     ..n5...%@..Z.h..
     465:	3e 04 78 f7 d7 46 00 58 e2 f3 7b 0c 20 9d fb d7     >.x..F.X..{. ...
     475:	56 04 2c a5 fb df 6e 0c 10 6c da ff c3 56 08 10     V.,...n..l...V..
     485:	64 ca ff e3 8e 31 00 18 64 be f7 f7 c3 6e 25 00     d....1..d....n%.
     495:	10 48 91 d6 fb fb d3 96 55 20 04 04 20 50 85 ba     .H......U .. P..
     4a5:	e3 fb ff ef d3 af 86 5d 39 1c 0c 00 00 08 14 24     .......]9......$
     4b5:	38 4d 61 75 8a 9a aa b6 be c7 cf d3 d7 db db        8Mau...........

000004c4 <NA5TR1_Tx_80MHz_4000ns>:
     4c4:	f4 e0 df 20 20 df df 60 21 9f 9d a0 63 1e 5b 21     ...  ..`!...c.[!
     4d4:	e5 9e d8 a1 a9 1f d5 de ec 63 92 19 2d ea 53 d0     .........c..-.S.
     4e4:	a9 73 9b c9 5d 77 6a 8b 4d 6e 79 9b 03 d8 7a 73     .s..]wj.Mny...zs
     4f4:	8e c3 63 fe 2c 07 45 69 7f 68 05 c7 6a 7f aa 07     ..c.,.Ei.h..j...
     504:	c5 a6 3f 6f 8c c1 9c fb 78 17 c0 ce 30 3f 29 49     ..?o....x...0?)I
     514:	02 5c fa fb df 03 86 a3 fc 39 1c 03 86 62 fc fa     .\.......9...b..
     524:	60 05 03 5a b6 3e 6c 0f c0 4c 27 fd 3a 63 89 40     `..Z.>l..L'.:c.@
     534:	4f ab fd 7a e4 cb c0 8b 24 b9 7e ef d6 03 02 92     O..z....$.~.....
     544:	6b fc fd ad d6 04 81 4e e5 78 3f 76 23 8e 01 43     k......N.x?v#..C
     554:	d1 26 78 bf b9 e9 15 45 80 87 16 a9 78 bf 7b 6d     .&x....E....x.{m
     564:	dc 8c 02 01 09 18 28 f6 fe fe 36 68 99 8b 02 80     ......(...6h....
     574:	45 4f dc 2a b6 fd bf 3b b3 a8 5b d0 c7 01 40 83     EO.*...;..[...@.
     584:	8a 13 de 68 b2 39 fd ff 3e f9 f3 eb e3 9b d3 4c     ...h.9..>......L
     594:	06 42 00 40 c1 84 88 cd 52 d8 1d a3 e8 ed f1 f5     .B.@....R.......
     5a4:	78 3b 7c be ff ff ff bf be 7e 3d fc bb ba 79 38     x;|......~=...y8
     5b4:	f8 f7 b7 b6 b6 f7 f7 08 f8 f7 07 18 f8 e7 07 28     ...............(
     5c4:	f8 c7 17 59 e8 96 16 89 f9 66 f5 b9 2a 36 a4 d9     ...Y.....f..*6..
     5d4:	8c 27 33 b6 1c 8a b3 13 7b 6d 96 11 27 6e 5b 42     .'3.....{m..'n[B
     5e4:	e2 ca df 98 70 a3 ed 4e 36 b0 15 ee fe 15 e0 35     ....p..N6......5
     5f4:	de fe 25 c0 04 ed 5f 47 70 82 fb ff ca 12 b0 a7     ..%..._Gp.......
     604:	af ce 26 a0 a3 fb 1f 0b 03 10 24 fc cf cb 03 30     ..&.......$....0
     614:	24 fc ef fb 04 e0 c3 fa 5f 9e 27 51 e0 86 ed bf     $......._.'Q....
     624:	fc 05 a0 41 b7 dd af fc 05 80 00 75 fc 1f 8e 48     ...A.......u...H
     634:	12 20 a2 c7 dd cf 5d 38 22 00 71 a6 fb 3f ef ab     . ....]8".q..?..
     644:	06 61 70 c2 c6 ec 4f 0f dc 17 23 e0 10 33 e8 dc     .ap...O...#..3..
     654:	3f 1f 0d 39 04 71 50 71 64 e8 ec 5e 7f 7e 9c 18     ?..9.qPqd..^.~..
     664:	14 71 30 20 02 a5 f8 dc 6e bf ef 1e 7b 18 05 42     .q0 ....n...{..B
     674:	c0 70 20 d1 63 c6 f8 eb 9d 2f 9f 0f 6f ed 7b 29     .p .c..../..o.{)
     684:	07 05 33 72 d1 30 b0 20 90 f1 42 93 c5 e6 f8 f9     ..3r.0. ..B.....
     694:	ea cb 9c 7d 3e 0f cf 8f 5f 1f ef bf 8f 6f 4f 2e     ...}>..._....oO.
     6a4:	0e ee de ce bd bd ad ad 9d 7d 81 82 7d 7d 82 82     .........}..}}..
     6b4:	79 79 8a 86 71 75 92 8a 69 71 9a 96 65 61 9d a6     yy..qu..iq..ea..
     6c4:	66 4d 95 be 76 39 79 ca 9b 35 48 be cf 56 1c 89     fM..v9y..5H..V..
     6d4:	eb a3 1d 34 c5 eb 6a 04 58 ea db 46 04 78 f7 cb     ...4..j.X..F.x..
     6e4:	31 08 84 fb cb 35 04 78 f3 d7 4a 00 58 e2 ef 76     1....5.x..J.X..v
     6f4:	08 28 b1 ff b7 2d 04 64 e2 f3 87 11 14 89 f3 e7     .(...-.d........
     704:	72 08 18 8d f3 eb 7a 10 10 74 e2 f7 a3 2d 00 3c     r.....z..t...-.<
     714:	b1 fb df 76 14 08 58 c6 ff d7 72 14 04 4c b6 fb     ...v..X...r..L..
     724:	eb 97 35 00 20 79 d6 ff db 86 29 00 1c 71 ca fb     ..5. y....)..q..
     734:	ef a7 4d 0c 04 34 89 d6 ff eb af 5a 18 00 1c 5c     ..M..4.....Z...\
     744:	aa e7 ff e7 ab 62 21 00 08 38 79 be ef ff eb bf     .....b!..8y.....
     754:	7e 41 10 00 0c 34 69 a6 db f7 ff eb c7 92 5d 2d     ~A...4i.......]-
     764:	0c 00 08 20 44 75 a2 ca eb fb ff f3 db bb 92 6e     ... Du.........n
     774:	49 28 10 04 00 04 14 28 40 5d 79 96 b2 ca df ef     I(.....(@]y.....
     784:	f7 ff ff fb f7 ef e3 d7 c7 bb aa 9e 8e 82 75 69     ..............ui
     794:	5d 55 4d 45 3d 38 34 30 2c 28 28 28 24              ]UME=840,((($

000007a1 <NA5TR1_Tx_22MHz_1000ns>:
     7a1:	08 22 54 1e b9 07 c8 a4 b3 5c 40 ff c7 c0 55 fb     ."T......\@...U.
     7b1:	8d 5e 9c b7 00 8c fb f3 db                          .^.......

000007ba <NA5TR1_Tx_22MHz_2000ns>:
     7ba:	10 e1 98 71 04 7f c7 5e 3d 4e 85 6a 3f f5 21 52     ...q...^=N.j?.!R
     7ca:	4b f6 8b e3 fa fa b0 fe 4a 50 15 de 2f 8a 06 33     K.......JP../..3
     7da:	82 6d b2 20 fa 09 b4 c7 05 68 fb cb 4e 08 04 18     .m. .....h..N...
     7ea:	24                                                  $

000007eb <NA5TR1_Tx_22MHz_4000ns>:
     7eb:	20 a0 5f 1e a2 9e 1b ad 47 ff 43 eb 6e 00 f3 af      ._.....G.C.n...
     7fb:	c1 9e 7f 9f 00 d4 f7 3d 26 0c 40 c5 92 a0 eb 32     .......=&.@....2
     80b:	b5 f7 39 75 fc 91 bf 41 4b a8 22 df 33 45 8f 44     ..9u...AK.".3E.D
     81b:	81 fd ed 02 b1 d9 5f 4d 16 71 c0 12 c6 f9 db 9d     ......_M.q......
     82b:	6d 7d 7e 85 76 7c a3 30 f3 01 d5 87 18 f6 77 0c     m}~.v|.0......w.
     83b:	cd db 21 20 c1 fb 97 1d 04 44 9d e3 fb fb ef e3     ..! .....D......
     84b:	db                                                  .

0000084c <NA5TR1_THRES_80MHz_500ns>:
     84c:	00 20 20 20 20                                      .    

00000851 <NA5TR1_THRES_80MHz_1000ns>:
     851:	00 36 36 36 36                                      .6666

00000856 <NA5TR1_THRES_80MHz_2000ns>:
     856:	00 5a 5a 5a 5a                                      .ZZZZ

0000085b <NA5TR1_THRES_80MHz_4000ns>:
     85b:	00 8d 8d 8d 8d                                      .....

00000860 <NA5TR1_THRES_22MHz_1000ns>:
     860:	00 11 11 11 11                                      .....

00000865 <NA5TR1_THRES_22MHz_2000ns>:
     865:	00 20 20 20 20                                      .    

0000086a <NA5TR1_THRES_22MHz_4000ns>:
     86a:	00 31 31 31 31 00 40 7a 10 f3 5a 00 a0 72 4e 18     .1111.@z..Z..rN.
     87a:	09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b     .........vH.....
     88a:	54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80     T.....;.........
     89a:	96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00     .....@B.........
     8aa:	00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00     ..'..........d..
     8ba:	00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c     ...............,
     8ca:	76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7     v...gO.#....Y...
     8da:	96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84     ....S.:.Q.v.....
     8ea:	26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40     &....b.@|o.....@
     8fa:	f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9     ...o....Z*.\.kl.
     90a:	67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0     gm......G.. ....
     91a:	ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00     ......5w........
     92a:	20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12      N......3333..n.
     93a:	83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db     ..A..!..;.U.....
     94a:	18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20     ...K8..|......$ 
     95a:	32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27 00     2.r^"....$...='.

0000096a <__ctors_end>:
     96a:	11 24       	eor	r1, r1
     96c:	1f be       	out	0x3f, r1	; 63
     96e:	cf ef       	ldi	r28, 0xFF	; 255
     970:	d0 e1       	ldi	r29, 0x10	; 16
     972:	de bf       	out	0x3e, r29	; 62
     974:	cd bf       	out	0x3d, r28	; 61

00000976 <__do_copy_data>:
     976:	17 e0       	ldi	r17, 0x07	; 7
     978:	a0 e0       	ldi	r26, 0x00	; 0
     97a:	b1 e0       	ldi	r27, 0x01	; 1
     97c:	ea e1       	ldi	r30, 0x1A	; 26
     97e:	fd e8       	ldi	r31, 0x8D	; 141
     980:	02 c0       	rjmp	.+4      	; 0x986 <.do_copy_data_start>

00000982 <.do_copy_data_loop>:
     982:	05 90       	lpm	r0, Z+
     984:	0d 92       	st	X+, r0

00000986 <.do_copy_data_start>:
     986:	a6 3c       	cpi	r26, 0xC6	; 198
     988:	b1 07       	cpc	r27, r17
     98a:	d9 f7       	brne	.-10     	; 0x982 <.do_copy_data_loop>

0000098c <__do_clear_bss>:
     98c:	10 e1       	ldi	r17, 0x10	; 16
     98e:	a6 ec       	ldi	r26, 0xC6	; 198
     990:	b7 e0       	ldi	r27, 0x07	; 7
     992:	01 c0       	rjmp	.+2      	; 0x996 <.do_clear_bss_start>

00000994 <.do_clear_bss_loop>:
     994:	1d 92       	st	X+, r1

00000996 <.do_clear_bss_start>:
     996:	a0 36       	cpi	r26, 0x60	; 96
     998:	b1 07       	cpc	r27, r17
     99a:	e1 f7       	brne	.-8      	; 0x994 <.do_clear_bss_loop>
     99c:	0e 94 66 05 	call	0xacc	; 0xacc <main>
     9a0:	0c 94 8b 46 	jmp	0x8d16	; 0x8d16 <_exit>

000009a4 <__bad_interrupt>:
     9a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009a8 <error_handler>:
 * error_handler() print out the error number and stop the system.
 *
 * Returns: None
 */
void	error_handler(MyInt16T err)
{
     9a8:	df 93       	push	r29
     9aa:	cf 93       	push	r28
     9ac:	00 d0       	rcall	.+0      	; 0x9ae <error_handler+0x6>
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	9a 83       	std	Y+2, r25	; 0x02
     9b4:	89 83       	std	Y+1, r24	; 0x01
#ifdef	CONFIG_CONSOLE
#ifdef	CONFIG_PRINTF
	printf("ErrorHandler: error %d\n", err);
     9b6:	00 d0       	rcall	.+0      	; 0x9b8 <error_handler+0x10>
     9b8:	00 d0       	rcall	.+0      	; 0x9ba <error_handler+0x12>
     9ba:	ed b7       	in	r30, 0x3d	; 61
     9bc:	fe b7       	in	r31, 0x3e	; 62
     9be:	31 96       	adiw	r30, 0x01	; 1
     9c0:	80 e0       	ldi	r24, 0x00	; 0
     9c2:	91 e0       	ldi	r25, 0x01	; 1
     9c4:	91 83       	std	Z+1, r25	; 0x01
     9c6:	80 83       	st	Z, r24
     9c8:	89 81       	ldd	r24, Y+1	; 0x01
     9ca:	9a 81       	ldd	r25, Y+2	; 0x02
     9cc:	93 83       	std	Z+3, r25	; 0x03
     9ce:	82 83       	std	Z+2, r24	; 0x02
     9d0:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
     9d4:	0f 90       	pop	r0
     9d6:	0f 90       	pop	r0
     9d8:	0f 90       	pop	r0
     9da:	0f 90       	pop	r0
	printf("System halted!\n");
     9dc:	88 e1       	ldi	r24, 0x18	; 24
     9de:	91 e0       	ldi	r25, 0x01	; 1
     9e0:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
#endif	/* CONFIG_PRINTF */
#endif	/* CONFIG_CONSOLE */
	while( 1 )
	{
		LED3 (LED_OFF);
     9e4:	a8 e2       	ldi	r26, 0x28	; 40
     9e6:	b0 e0       	ldi	r27, 0x00	; 0
     9e8:	e8 e2       	ldi	r30, 0x28	; 40
     9ea:	f0 e0       	ldi	r31, 0x00	; 0
     9ec:	80 81       	ld	r24, Z
     9ee:	82 60       	ori	r24, 0x02	; 2
     9f0:	8c 93       	st	X, r24
		LED0 (LED_ON);
     9f2:	a2 e2       	ldi	r26, 0x22	; 34
     9f4:	b0 e0       	ldi	r27, 0x00	; 0
     9f6:	e2 e2       	ldi	r30, 0x22	; 34
     9f8:	f0 e0       	ldi	r31, 0x00	; 0
     9fa:	80 81       	ld	r24, Z
     9fc:	8f 77       	andi	r24, 0x7F	; 127
     9fe:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     a00:	88 ec       	ldi	r24, 0xC8	; 200
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED0 (LED_OFF);
     a08:	a2 e2       	ldi	r26, 0x22	; 34
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	e2 e2       	ldi	r30, 0x22	; 34
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	80 81       	ld	r24, Z
     a12:	80 68       	ori	r24, 0x80	; 128
     a14:	8c 93       	st	X, r24
		LED1 (LED_ON);
     a16:	a8 e2       	ldi	r26, 0x28	; 40
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	e8 e2       	ldi	r30, 0x28	; 40
     a1c:	f0 e0       	ldi	r31, 0x00	; 0
     a1e:	80 81       	ld	r24, Z
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     a24:	88 ec       	ldi	r24, 0xC8	; 200
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED1 (LED_OFF);
     a2c:	a8 e2       	ldi	r26, 0x28	; 40
     a2e:	b0 e0       	ldi	r27, 0x00	; 0
     a30:	e8 e2       	ldi	r30, 0x28	; 40
     a32:	f0 e0       	ldi	r31, 0x00	; 0
     a34:	80 81       	ld	r24, Z
     a36:	80 68       	ori	r24, 0x80	; 128
     a38:	8c 93       	st	X, r24
		LED2 (LED_ON);
     a3a:	a8 e2       	ldi	r26, 0x28	; 40
     a3c:	b0 e0       	ldi	r27, 0x00	; 0
     a3e:	e8 e2       	ldi	r30, 0x28	; 40
     a40:	f0 e0       	ldi	r31, 0x00	; 0
     a42:	80 81       	ld	r24, Z
     a44:	8f 7b       	andi	r24, 0xBF	; 191
     a46:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     a48:	88 ec       	ldi	r24, 0xC8	; 200
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED2 (LED_OFF);
     a50:	a8 e2       	ldi	r26, 0x28	; 40
     a52:	b0 e0       	ldi	r27, 0x00	; 0
     a54:	e8 e2       	ldi	r30, 0x28	; 40
     a56:	f0 e0       	ldi	r31, 0x00	; 0
     a58:	80 81       	ld	r24, Z
     a5a:	80 64       	ori	r24, 0x40	; 64
     a5c:	8c 93       	st	X, r24
		LED3 (LED_ON);
     a5e:	a8 e2       	ldi	r26, 0x28	; 40
     a60:	b0 e0       	ldi	r27, 0x00	; 0
     a62:	e8 e2       	ldi	r30, 0x28	; 40
     a64:	f0 e0       	ldi	r31, 0x00	; 0
     a66:	80 81       	ld	r24, Z
     a68:	8d 7f       	andi	r24, 0xFD	; 253
     a6a:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     a6c:	88 ec       	ldi	r24, 0xC8	; 200
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED3 (LED_OFF);
     a74:	a8 e2       	ldi	r26, 0x28	; 40
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	e8 e2       	ldi	r30, 0x28	; 40
     a7a:	f0 e0       	ldi	r31, 0x00	; 0
     a7c:	80 81       	ld	r24, Z
     a7e:	82 60       	ori	r24, 0x02	; 2
     a80:	8c 93       	st	X, r24
		LED2 (LED_ON);
     a82:	a8 e2       	ldi	r26, 0x28	; 40
     a84:	b0 e0       	ldi	r27, 0x00	; 0
     a86:	e8 e2       	ldi	r30, 0x28	; 40
     a88:	f0 e0       	ldi	r31, 0x00	; 0
     a8a:	80 81       	ld	r24, Z
     a8c:	8f 7b       	andi	r24, 0xBF	; 191
     a8e:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     a90:	88 ec       	ldi	r24, 0xC8	; 200
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED2 (LED_OFF);
     a98:	a8 e2       	ldi	r26, 0x28	; 40
     a9a:	b0 e0       	ldi	r27, 0x00	; 0
     a9c:	e8 e2       	ldi	r30, 0x28	; 40
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
     aa0:	80 81       	ld	r24, Z
     aa2:	80 64       	ori	r24, 0x40	; 64
     aa4:	8c 93       	st	X, r24
		LED1 (LED_ON);
     aa6:	a8 e2       	ldi	r26, 0x28	; 40
     aa8:	b0 e0       	ldi	r27, 0x00	; 0
     aaa:	e8 e2       	ldi	r30, 0x28	; 40
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	80 81       	ld	r24, Z
     ab0:	8f 77       	andi	r24, 0x7F	; 127
     ab2:	8c 93       	st	X, r24
		HWDelayms ( 200 );
     ab4:	88 ec       	ldi	r24, 0xC8	; 200
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
		LED1 (LED_OFF);
     abc:	a8 e2       	ldi	r26, 0x28	; 40
     abe:	b0 e0       	ldi	r27, 0x00	; 0
     ac0:	e8 e2       	ldi	r30, 0x28	; 40
     ac2:	f0 e0       	ldi	r31, 0x00	; 0
     ac4:	80 81       	ld	r24, Z
     ac6:	80 68       	ori	r24, 0x80	; 128
     ac8:	8c 93       	st	X, r24
     aca:	8c cf       	rjmp	.-232    	; 0x9e4 <error_handler+0x3c>

00000acc <main>:
 * The main() function of the PPS
 *
 * Returns: None.
 */
int	main(int ac, char *av[])
{
     acc:	df 93       	push	r29
     ace:	cf 93       	push	r28
     ad0:	00 d0       	rcall	.+0      	; 0xad2 <main+0x6>
     ad2:	00 d0       	rcall	.+0      	; 0xad4 <main+0x8>
     ad4:	0f 92       	push	r0
     ad6:	cd b7       	in	r28, 0x3d	; 61
     ad8:	de b7       	in	r29, 0x3e	; 62
     ada:	9b 83       	std	Y+3, r25	; 0x03
     adc:	8a 83       	std	Y+2, r24	; 0x02
     ade:	7d 83       	std	Y+5, r23	; 0x05
     ae0:	6c 83       	std	Y+4, r22	; 0x04
	/* Run with 16 MHz */
	clock_prescale_set(1);
     ae2:	80 e8       	ldi	r24, 0x80	; 128
     ae4:	89 83       	std	Y+1, r24	; 0x01
     ae6:	29 81       	ldd	r18, Y+1	; 0x01
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	90 e0       	ldi	r25, 0x00	; 0
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	f8 94       	cli
     af0:	20 93 61 00 	sts	0x0061, r18
     af4:	80 93 61 00 	sts	0x0061, r24
     af8:	0f be       	out	0x3f, r0	; 63

	/*
     * LEDs are on Port C off avr board
     */
	LED0_DIR |= LED0_PIN;
     afa:	a1 e2       	ldi	r26, 0x21	; 33
     afc:	b0 e0       	ldi	r27, 0x00	; 0
     afe:	e1 e2       	ldi	r30, 0x21	; 33
     b00:	f0 e0       	ldi	r31, 0x00	; 0
     b02:	80 81       	ld	r24, Z
     b04:	80 68       	ori	r24, 0x80	; 128
     b06:	8c 93       	st	X, r24
	LED0 (LED_OFF);
     b08:	a2 e2       	ldi	r26, 0x22	; 34
     b0a:	b0 e0       	ldi	r27, 0x00	; 0
     b0c:	e2 e2       	ldi	r30, 0x22	; 34
     b0e:	f0 e0       	ldi	r31, 0x00	; 0
     b10:	80 81       	ld	r24, Z
     b12:	80 68       	ori	r24, 0x80	; 128
     b14:	8c 93       	st	X, r24

	LED1_DIR |= LED1_PIN;
     b16:	a7 e2       	ldi	r26, 0x27	; 39
     b18:	b0 e0       	ldi	r27, 0x00	; 0
     b1a:	e7 e2       	ldi	r30, 0x27	; 39
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	80 81       	ld	r24, Z
     b20:	80 68       	ori	r24, 0x80	; 128
     b22:	8c 93       	st	X, r24
	LED1 (LED_OFF);
     b24:	a8 e2       	ldi	r26, 0x28	; 40
     b26:	b0 e0       	ldi	r27, 0x00	; 0
     b28:	e8 e2       	ldi	r30, 0x28	; 40
     b2a:	f0 e0       	ldi	r31, 0x00	; 0
     b2c:	80 81       	ld	r24, Z
     b2e:	80 68       	ori	r24, 0x80	; 128
     b30:	8c 93       	st	X, r24

	LED2_DIR |= LED2_PIN;
     b32:	a7 e2       	ldi	r26, 0x27	; 39
     b34:	b0 e0       	ldi	r27, 0x00	; 0
     b36:	e7 e2       	ldi	r30, 0x27	; 39
     b38:	f0 e0       	ldi	r31, 0x00	; 0
     b3a:	80 81       	ld	r24, Z
     b3c:	80 64       	ori	r24, 0x40	; 64
     b3e:	8c 93       	st	X, r24
	LED2 (LED_OFF);
     b40:	a8 e2       	ldi	r26, 0x28	; 40
     b42:	b0 e0       	ldi	r27, 0x00	; 0
     b44:	e8 e2       	ldi	r30, 0x28	; 40
     b46:	f0 e0       	ldi	r31, 0x00	; 0
     b48:	80 81       	ld	r24, Z
     b4a:	80 64       	ori	r24, 0x40	; 64
     b4c:	8c 93       	st	X, r24

	LED3_DIR |= LED3_PIN;
     b4e:	a7 e2       	ldi	r26, 0x27	; 39
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e7 e2       	ldi	r30, 0x27	; 39
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	82 60       	ori	r24, 0x02	; 2
     b5a:	8c 93       	st	X, r24
	LED3 (LED_OFF);
     b5c:	a8 e2       	ldi	r26, 0x28	; 40
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e8 e2       	ldi	r30, 0x28	; 40
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	82 60       	ori	r24, 0x02	; 2
     b68:	8c 93       	st	X, r24

	/* Initialize direction of pins for flow control for comm with the ARM */
	CTS_DIR  |= CTS_PIN;
     b6a:	a1 e2       	ldi	r26, 0x21	; 33
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e1 e2       	ldi	r30, 0x21	; 33
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	80 62       	ori	r24, 0x20	; 32
     b76:	8c 93       	st	X, r24
	RTS_DIR  &= ~RTS_PIN;
     b78:	a1 e2       	ldi	r26, 0x21	; 33
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e1 e2       	ldi	r30, 0x21	; 33
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	8f 7e       	andi	r24, 0xEF	; 239
     b84:	8c 93       	st	X, r24

	/*
     * Initialize the timer for periodic tasks
     * or time supervized actions
     */
	hwclock_init();
     b86:	0e 94 93 17 	call	0x2f26	; 0x2f26 <hwclock_init>

#	ifdef	CONFIG_CONSOLE
	console_init();
     b8a:	0e 94 13 18 	call	0x3026	; 0x3026 <console_init>
#	endif	/* CONFIG_CONSOLE */

	/*
	 * Initialize the ntrx driver
	 */
 	NTRXInit();
     b8e:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <NTRXInit>
	PHYInit ();
     b92:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <PHYInit>
#	endif

	/*
     * initialize user application
     */
	APLInit();
     b96:	0e 94 17 09 	call	0x122e	; 0x122e <APLInit>
	{
		//printf("alive");
		/*
		 * call application periodically
         */
		APLPoll ();
     b9a:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <APLPoll>
		/*
         * Check for incomming packets
         */
		PHYPoll ();
     b9e:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <PHYPoll>
     ba2:	fb cf       	rjmp	.-10     	; 0xb9a <main+0xce>

00000ba4 <sendToARM>:

/* @brief Send string to ARM
 * Helper function that makes writing to the ARM less cumbersome by wrapping our message contents around an envelope
 * Returns 0 on success, nonzero on failure. 
 */
int sendToARM (char *message, int msg_len, radio_msg_type msg_type, char tag) {
     ba4:	ef 92       	push	r14
     ba6:	ff 92       	push	r15
     ba8:	0f 93       	push	r16
     baa:	1f 93       	push	r17
     bac:	df 93       	push	r29
     bae:	cf 93       	push	r28
     bb0:	cd b7       	in	r28, 0x3d	; 61
     bb2:	de b7       	in	r29, 0x3e	; 62
     bb4:	28 97       	sbiw	r28, 0x08	; 8
     bb6:	0f b6       	in	r0, 0x3f	; 63
     bb8:	f8 94       	cli
     bba:	de bf       	out	0x3e, r29	; 62
     bbc:	0f be       	out	0x3f, r0	; 63
     bbe:	cd bf       	out	0x3d, r28	; 61
     bc0:	9a 83       	std	Y+2, r25	; 0x02
     bc2:	89 83       	std	Y+1, r24	; 0x01
     bc4:	7c 83       	std	Y+4, r23	; 0x04
     bc6:	6b 83       	std	Y+3, r22	; 0x03
     bc8:	4d 83       	std	Y+5, r20	; 0x05
     bca:	2e 83       	std	Y+6, r18	; 0x06
   if (msg_len > 256 - Sf_packet_header_overhead - sizeof(crc) ) {
     bcc:	8b 81       	ldd	r24, Y+3	; 0x03
     bce:	9c 81       	ldd	r25, Y+4	; 0x04
     bd0:	8c 3f       	cpi	r24, 0xFC	; 252
     bd2:	91 05       	cpc	r25, r1
     bd4:	48 f0       	brcs	.+18     	; 0xbe8 <sendToARM+0x44>
      puts ("Err: avr to arm msg too long");
     bd6:	87 e2       	ldi	r24, 0x27	; 39
     bd8:	91 e0       	ldi	r25, 0x01	; 1
     bda:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
      return 1;
     bde:	81 e0       	ldi	r24, 0x01	; 1
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	98 87       	std	Y+8, r25	; 0x08
     be4:	8f 83       	std	Y+7, r24	; 0x07
     be6:	7a c0       	rjmp	.+244    	; 0xcdc <sendToARM+0x138>
   }
   apl->outpkt.header_soh = '\x1';
     be8:	e0 91 ec 08 	lds	r30, 0x08EC
     bec:	f0 91 ed 08 	lds	r31, 0x08ED
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	86 8f       	std	Z+30, r24	; 0x1e
   apl->outpkt.size = msg_len + Sf_packet_header_overhead + sizeof(crc);
     bf4:	e0 91 ec 08 	lds	r30, 0x08EC
     bf8:	f0 91 ed 08 	lds	r31, 0x08ED
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	8b 5f       	subi	r24, 0xFB	; 251
     c00:	87 8f       	std	Z+31, r24	; 0x1f
   apl->outpkt.type = msg_type;
     c02:	e0 91 ec 08 	lds	r30, 0x08EC
     c06:	f0 91 ed 08 	lds	r31, 0x08ED
     c0a:	8d 81       	ldd	r24, Y+5	; 0x05
     c0c:	80 a3       	std	Z+32, r24	; 0x20
   apl->outpkt.tag = tag;
     c0e:	e0 91 ec 08 	lds	r30, 0x08EC
     c12:	f0 91 ed 08 	lds	r31, 0x08ED
     c16:	8e 81       	ldd	r24, Y+6	; 0x06
     c18:	81 a3       	std	Z+33, r24	; 0x21
   if (message != apl->outpkt.params)
     c1a:	80 91 ec 08 	lds	r24, 0x08EC
     c1e:	90 91 ed 08 	lds	r25, 0x08ED
     c22:	9c 01       	movw	r18, r24
     c24:	2e 5d       	subi	r18, 0xDE	; 222
     c26:	3f 4f       	sbci	r19, 0xFF	; 255
     c28:	89 81       	ldd	r24, Y+1	; 0x01
     c2a:	9a 81       	ldd	r25, Y+2	; 0x02
     c2c:	28 17       	cp	r18, r24
     c2e:	39 07       	cpc	r19, r25
     c30:	61 f0       	breq	.+24     	; 0xc4a <sendToARM+0xa6>
   	memcpy (apl->outpkt.params, message, msg_len);
     c32:	80 91 ec 08 	lds	r24, 0x08EC
     c36:	90 91 ed 08 	lds	r25, 0x08ED
     c3a:	82 96       	adiw	r24, 0x22	; 34
     c3c:	4b 81       	ldd	r20, Y+3	; 0x03
     c3e:	5c 81       	ldd	r21, Y+4	; 0x04
     c40:	29 81       	ldd	r18, Y+1	; 0x01
     c42:	3a 81       	ldd	r19, Y+2	; 0x02
     c44:	b9 01       	movw	r22, r18
     c46:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
   //for (i=0; i< msg_len + envelope_overhead - sizeof(crc); i++) {
   //   printf ("%x ", (  (unsigned char *) &apl->outpkt )  [i]);
   //}
   //puts ("<-");
   //debug end
   apl->outpkt.params[msg_len] = crcFast ((unsigned char *) &apl->outpkt, msg_len + Sf_packet_header_overhead, 0 ); //TODO: return value of crcFast depends on width of crc check, which might change, so left side of this line needs to be rewritten to support that 
     c4a:	e0 90 ec 08 	lds	r14, 0x08EC
     c4e:	f0 90 ed 08 	lds	r15, 0x08ED
     c52:	0b 81       	ldd	r16, Y+3	; 0x03
     c54:	1c 81       	ldd	r17, Y+4	; 0x04
     c56:	80 91 ec 08 	lds	r24, 0x08EC
     c5a:	90 91 ed 08 	lds	r25, 0x08ED
     c5e:	ac 01       	movw	r20, r24
     c60:	42 5e       	subi	r20, 0xE2	; 226
     c62:	5f 4f       	sbci	r21, 0xFF	; 255
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	9c 81       	ldd	r25, Y+4	; 0x04
     c68:	9c 01       	movw	r18, r24
     c6a:	2c 5f       	subi	r18, 0xFC	; 252
     c6c:	3f 4f       	sbci	r19, 0xFF	; 255
     c6e:	ca 01       	movw	r24, r20
     c70:	b9 01       	movw	r22, r18
     c72:	40 e0       	ldi	r20, 0x00	; 0
     c74:	0e 94 16 1b 	call	0x362c	; 0x362c <crcFast>
     c78:	28 2f       	mov	r18, r24
     c7a:	c7 01       	movw	r24, r14
     c7c:	80 0f       	add	r24, r16
     c7e:	91 1f       	adc	r25, r17
     c80:	fc 01       	movw	r30, r24
     c82:	b2 96       	adiw	r30, 0x22	; 34
     c84:	20 83       	st	Z, r18
   if (apl->outpkt.size < Sf_packet_header_overhead + sizeof(crc) ) {
     c86:	e0 91 ec 08 	lds	r30, 0x08EC
     c8a:	f0 91 ed 08 	lds	r31, 0x08ED
     c8e:	87 8d       	ldd	r24, Z+31	; 0x1f
     c90:	85 30       	cpi	r24, 0x05	; 5
     c92:	48 f4       	brcc	.+18     	; 0xca6 <sendToARM+0x102>
      puts ("Error: avr to arm msg impossibly shrt\n");
     c94:	84 e4       	ldi	r24, 0x44	; 68
     c96:	91 e0       	ldi	r25, 0x01	; 1
     c98:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
      return 1;
     c9c:	81 e0       	ldi	r24, 0x01	; 1
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	98 87       	std	Y+8, r25	; 0x08
     ca2:	8f 83       	std	Y+7, r24	; 0x07
     ca4:	1b c0       	rjmp	.+54     	; 0xcdc <sendToARM+0x138>
   }
   fwrite (& (apl->outpkt), 1, apl->outpkt.size, stdout);
     ca6:	80 91 ec 08 	lds	r24, 0x08EC
     caa:	90 91 ed 08 	lds	r25, 0x08ED
     cae:	ac 01       	movw	r20, r24
     cb0:	42 5e       	subi	r20, 0xE2	; 226
     cb2:	5f 4f       	sbci	r21, 0xFF	; 255
     cb4:	e0 91 ec 08 	lds	r30, 0x08EC
     cb8:	f0 91 ed 08 	lds	r31, 0x08ED
     cbc:	87 8d       	ldd	r24, Z+31	; 0x1f
     cbe:	28 2f       	mov	r18, r24
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	e0 91 5c 10 	lds	r30, 0x105C
     cc6:	f0 91 5d 10 	lds	r31, 0x105D
     cca:	ca 01       	movw	r24, r20
     ccc:	61 e0       	ldi	r22, 0x01	; 1
     cce:	70 e0       	ldi	r23, 0x00	; 0
     cd0:	a9 01       	movw	r20, r18
     cd2:	9f 01       	movw	r18, r30
     cd4:	0e 94 83 45 	call	0x8b06	; 0x8b06 <fwrite>
   return 0;
     cd8:	18 86       	std	Y+8, r1	; 0x08
     cda:	1f 82       	std	Y+7, r1	; 0x07
     cdc:	8f 81       	ldd	r24, Y+7	; 0x07
     cde:	98 85       	ldd	r25, Y+8	; 0x08
}
     ce0:	28 96       	adiw	r28, 0x08	; 8
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	de bf       	out	0x3e, r29	; 62
     ce8:	0f be       	out	0x3f, r0	; 63
     cea:	cd bf       	out	0x3d, r28	; 61
     cec:	cf 91       	pop	r28
     cee:	df 91       	pop	r29
     cf0:	1f 91       	pop	r17
     cf2:	0f 91       	pop	r16
     cf4:	ff 90       	pop	r15
     cf6:	ef 90       	pop	r14
     cf8:	08 95       	ret

00000cfa <APLCallback>:
 * and sends the payload to the serial interface.
 */
/**************************************************************************/
void APLCallback (MyMsgT *msg)
/**************************************************************************/
{
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	cd b7       	in	r28, 0x3d	; 61
     d00:	de b7       	in	r29, 0x3e	; 62
     d02:	aa 97       	sbiw	r28, 0x2a	; 42
     d04:	0f b6       	in	r0, 0x3f	; 63
     d06:	f8 94       	cli
     d08:	de bf       	out	0x3e, r29	; 62
     d0a:	0f be       	out	0x3f, r0	; 63
     d0c:	cd bf       	out	0x3d, r28	; 61
     d0e:	9e a3       	std	Y+38, r25	; 0x26
     d10:	8d a3       	std	Y+37, r24	; 0x25
	static MyByte8T lastAddr[6];

	static MyByte8T lastPacketTag = 0;
    MyInt16T i;

	switch (msg->prim)
     d12:	ed a1       	ldd	r30, Y+37	; 0x25
     d14:	fe a1       	ldd	r31, Y+38	; 0x26
     d16:	80 81       	ld	r24, Z
     d18:	28 2f       	mov	r18, r24
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	3a a7       	std	Y+42, r19	; 0x2a
     d1e:	29 a7       	std	Y+41, r18	; 0x29
     d20:	89 a5       	ldd	r24, Y+41	; 0x29
     d22:	9a a5       	ldd	r25, Y+42	; 0x2a
     d24:	82 31       	cpi	r24, 0x12	; 18
     d26:	91 05       	cpc	r25, r1
     d28:	31 f1       	breq	.+76     	; 0xd76 <APLCallback+0x7c>
     d2a:	29 a5       	ldd	r18, Y+41	; 0x29
     d2c:	3a a5       	ldd	r19, Y+42	; 0x2a
     d2e:	23 31       	cpi	r18, 0x13	; 19
     d30:	31 05       	cpc	r19, r1
     d32:	64 f4       	brge	.+24     	; 0xd4c <APLCallback+0x52>
     d34:	89 a5       	ldd	r24, Y+41	; 0x29
     d36:	9a a5       	ldd	r25, Y+42	; 0x2a
     d38:	82 30       	cpi	r24, 0x02	; 2
     d3a:	91 05       	cpc	r25, r1
     d3c:	c9 f0       	breq	.+50     	; 0xd70 <APLCallback+0x76>
     d3e:	29 a5       	ldd	r18, Y+41	; 0x29
     d40:	3a a5       	ldd	r19, Y+42	; 0x2a
     d42:	23 30       	cpi	r18, 0x03	; 3
     d44:	31 05       	cpc	r19, r1
     d46:	09 f4       	brne	.+2      	; 0xd4a <APLCallback+0x50>
     d48:	dd c0       	rjmp	.+442    	; 0xf04 <APLCallback+0x20a>
     d4a:	68 c2       	rjmp	.+1232   	; 0x121c <__stack+0x11d>
     d4c:	89 a5       	ldd	r24, Y+41	; 0x29
     d4e:	9a a5       	ldd	r25, Y+42	; 0x2a
     d50:	87 31       	cpi	r24, 0x17	; 23
     d52:	91 05       	cpc	r25, r1
     d54:	81 f0       	breq	.+32     	; 0xd76 <APLCallback+0x7c>
     d56:	29 a5       	ldd	r18, Y+41	; 0x29
     d58:	3a a5       	ldd	r19, Y+42	; 0x2a
     d5a:	28 31       	cpi	r18, 0x18	; 24
     d5c:	31 05       	cpc	r19, r1
     d5e:	09 f4       	brne	.+2      	; 0xd62 <APLCallback+0x68>
     d60:	15 c2       	rjmp	.+1066   	; 0x118c <__stack+0x8d>
     d62:	89 a5       	ldd	r24, Y+41	; 0x29
     d64:	9a a5       	ldd	r25, Y+42	; 0x2a
     d66:	83 31       	cpi	r24, 0x13	; 19
     d68:	91 05       	cpc	r25, r1
     d6a:	09 f4       	brne	.+2      	; 0xd6e <APLCallback+0x74>
     d6c:	0f c2       	rjmp	.+1054   	; 0x118c <__stack+0x8d>
     d6e:	56 c2       	rjmp	.+1196   	; 0x121c <__stack+0x11d>
	{
		case PD_DATA_CONFIRM:
								downMsg.len = 0;
     d70:	10 92 f5 08 	sts	0x08F5, r1
     d74:	53 c2       	rjmp	.+1190   	; 0x121c <__stack+0x11d>
							  	break;
		case PD_RANGING_CONFIRM:
		case PD_RANGING_FAST_CONFIRM:
								upRangingMsg = (RangingPIB*) msg->data;
     d76:	8d a1       	ldd	r24, Y+37	; 0x25
     d78:	9e a1       	ldd	r25, Y+38	; 0x26
     d7a:	08 96       	adiw	r24, 0x08	; 8
     d7c:	90 93 87 09 	sts	0x0987, r25
     d80:	80 93 86 09 	sts	0x0986, r24
								switch(msg->status)
     d84:	8d a1       	ldd	r24, Y+37	; 0x25
     d86:	9e a1       	ldd	r25, Y+38	; 0x26
     d88:	fc 01       	movw	r30, r24
     d8a:	e8 57       	subi	r30, 0x78	; 120
     d8c:	ff 4f       	sbci	r31, 0xFF	; 255
     d8e:	80 81       	ld	r24, Z
     d90:	28 2f       	mov	r18, r24
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	38 a7       	std	Y+40, r19	; 0x28
     d96:	2f a3       	std	Y+39, r18	; 0x27
     d98:	8f a1       	ldd	r24, Y+39	; 0x27
     d9a:	98 a5       	ldd	r25, Y+40	; 0x28
     d9c:	87 30       	cpi	r24, 0x07	; 7
     d9e:	91 05       	cpc	r25, r1
     da0:	09 f4       	brne	.+2      	; 0xda4 <APLCallback+0xaa>
     da2:	3c c2       	rjmp	.+1144   	; 0x121c <__stack+0x11d>
     da4:	2f a1       	ldd	r18, Y+39	; 0x27
     da6:	38 a5       	ldd	r19, Y+40	; 0x28
     da8:	28 30       	cpi	r18, 0x08	; 8
     daa:	31 05       	cpc	r19, r1
     dac:	0c f4       	brge	.+2      	; 0xdb0 <APLCallback+0xb6>
     dae:	36 c2       	rjmp	.+1132   	; 0x121c <__stack+0x11d>
     db0:	8f a1       	ldd	r24, Y+39	; 0x27
     db2:	98 a5       	ldd	r25, Y+40	; 0x28
     db4:	8c 30       	cpi	r24, 0x0C	; 12
     db6:	91 05       	cpc	r25, r1
     db8:	39 f0       	breq	.+14     	; 0xdc8 <APLCallback+0xce>
     dba:	2f a1       	ldd	r18, Y+39	; 0x27
     dbc:	38 a5       	ldd	r19, Y+40	; 0x28
     dbe:	2d 30       	cpi	r18, 0x0D	; 13
     dc0:	31 05       	cpc	r19, r1
     dc2:	09 f4       	brne	.+2      	; 0xdc6 <APLCallback+0xcc>
     dc4:	50 c0       	rjmp	.+160    	; 0xe66 <APLCallback+0x16c>
     dc6:	2a c2       	rjmp	.+1108   	; 0x121c <__stack+0x11d>
									case PHY_SUCCESS	:
										/* hwack received, ranging start successfully */
										break;
									case PHY_NO_ACK		:
										/* no hwack received, ranging didnt start */
										if ( talk_to_ARM == apl->mode ) {
     dc8:	e0 91 ec 08 	lds	r30, 0x08EC
     dcc:	f0 91 ed 08 	lds	r31, 0x08ED
     dd0:	80 89       	ldd	r24, Z+16	; 0x10
     dd2:	86 30       	cpi	r24, 0x06	; 6
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <APLCallback+0xde>
     dd6:	22 c2       	rjmp	.+1092   	; 0x121c <__stack+0x11d>
											//char* replymsg = "dest didn't reply for rng"; //commented to save space in the string memory section.
											//sendToARM( replymsg, strlen(replymsg) + 1, nack, Sf_packet_unsolicited_msg_tag ); 
										}
										else {
											//sprintf(serial_print_buffer,"#%07.2f:%03i:%03i\n",upRangingMsg->distance,msg->addr[0],upRangingMsg->error);
											sprintf(serial_print_buffer,"confirmation %07.2f,%03i\n",upRangingMsg->distance, upRangingMsg->error);
     dd8:	e0 91 86 09 	lds	r30, 0x0986
     ddc:	f0 91 87 09 	lds	r31, 0x0987
     de0:	22 81       	ldd	r18, Z+2	; 0x02
     de2:	33 81       	ldd	r19, Z+3	; 0x03
     de4:	44 81       	ldd	r20, Z+4	; 0x04
     de6:	55 81       	ldd	r21, Z+5	; 0x05
     de8:	e0 91 86 09 	lds	r30, 0x0986
     dec:	f0 91 87 09 	lds	r31, 0x0987
     df0:	80 81       	ld	r24, Z
     df2:	68 2f       	mov	r22, r24
     df4:	70 e0       	ldi	r23, 0x00	; 0
     df6:	8d b7       	in	r24, 0x3d	; 61
     df8:	9e b7       	in	r25, 0x3e	; 62
     dfa:	0a 97       	sbiw	r24, 0x0a	; 10
     dfc:	0f b6       	in	r0, 0x3f	; 63
     dfe:	f8 94       	cli
     e00:	9e bf       	out	0x3e, r25	; 62
     e02:	0f be       	out	0x3f, r0	; 63
     e04:	8d bf       	out	0x3d, r24	; 61
     e06:	ed b7       	in	r30, 0x3d	; 61
     e08:	fe b7       	in	r31, 0x3e	; 62
     e0a:	31 96       	adiw	r30, 0x01	; 1
     e0c:	ce 01       	movw	r24, r28
     e0e:	05 96       	adiw	r24, 0x05	; 5
     e10:	91 83       	std	Z+1, r25	; 0x01
     e12:	80 83       	st	Z, r24
     e14:	8b e6       	ldi	r24, 0x6B	; 107
     e16:	91 e0       	ldi	r25, 0x01	; 1
     e18:	93 83       	std	Z+3, r25	; 0x03
     e1a:	82 83       	std	Z+2, r24	; 0x02
     e1c:	24 83       	std	Z+4, r18	; 0x04
     e1e:	35 83       	std	Z+5, r19	; 0x05
     e20:	46 83       	std	Z+6, r20	; 0x06
     e22:	57 83       	std	Z+7, r21	; 0x07
     e24:	71 87       	std	Z+9, r23	; 0x09
     e26:	60 87       	std	Z+8, r22	; 0x08
     e28:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
     e2c:	2d b7       	in	r18, 0x3d	; 61
     e2e:	3e b7       	in	r19, 0x3e	; 62
     e30:	26 5f       	subi	r18, 0xF6	; 246
     e32:	3f 4f       	sbci	r19, 0xFF	; 255
     e34:	0f b6       	in	r0, 0x3f	; 63
     e36:	f8 94       	cli
     e38:	3e bf       	out	0x3e, r19	; 62
     e3a:	0f be       	out	0x3f, r0	; 63
     e3c:	2d bf       	out	0x3d, r18	; 61
											printf("%s",serial_print_buffer);
     e3e:	00 d0       	rcall	.+0      	; 0xe40 <APLCallback+0x146>
     e40:	00 d0       	rcall	.+0      	; 0xe42 <APLCallback+0x148>
     e42:	ed b7       	in	r30, 0x3d	; 61
     e44:	fe b7       	in	r31, 0x3e	; 62
     e46:	31 96       	adiw	r30, 0x01	; 1
     e48:	85 e8       	ldi	r24, 0x85	; 133
     e4a:	91 e0       	ldi	r25, 0x01	; 1
     e4c:	91 83       	std	Z+1, r25	; 0x01
     e4e:	80 83       	st	Z, r24
     e50:	ce 01       	movw	r24, r28
     e52:	05 96       	adiw	r24, 0x05	; 5
     e54:	93 83       	std	Z+3, r25	; 0x03
     e56:	82 83       	std	Z+2, r24	; 0x02
     e58:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
     e5c:	0f 90       	pop	r0
     e5e:	0f 90       	pop	r0
     e60:	0f 90       	pop	r0
     e62:	0f 90       	pop	r0
     e64:	db c1       	rjmp	.+950    	; 0x121c <__stack+0x11d>
									case PHY_BUSY_TX 	:
										/* measurement is allready running (BUSY), wait
											for PD_RANGING_INDICATION first! */
										break;
									case PHY_CONFIGURATION_ERROR :
										if (terminal == apl->mode ) break;
     e66:	e0 91 ec 08 	lds	r30, 0x08EC
     e6a:	f0 91 ed 08 	lds	r31, 0x08ED
     e6e:	80 89       	ldd	r24, Z+16	; 0x10
     e70:	88 23       	and	r24, r24
     e72:	09 f4       	brne	.+2      	; 0xe76 <APLCallback+0x17c>
     e74:	d3 c1       	rjmp	.+934    	; 0x121c <__stack+0x11d>
										/* driver isnt correct initialized for ranging */
										//sprintf(serial_print_buffer,"#%07.2f:%03i:%03i\n",upRangingMsg->distance,msg->addr[0],upRangingMsg->error);
										sprintf(serial_print_buffer,"%07.2f,%03i\n",upRangingMsg->distance, upRangingMsg->error);
     e76:	e0 91 86 09 	lds	r30, 0x0986
     e7a:	f0 91 87 09 	lds	r31, 0x0987
     e7e:	22 81       	ldd	r18, Z+2	; 0x02
     e80:	33 81       	ldd	r19, Z+3	; 0x03
     e82:	44 81       	ldd	r20, Z+4	; 0x04
     e84:	55 81       	ldd	r21, Z+5	; 0x05
     e86:	e0 91 86 09 	lds	r30, 0x0986
     e8a:	f0 91 87 09 	lds	r31, 0x0987
     e8e:	80 81       	ld	r24, Z
     e90:	68 2f       	mov	r22, r24
     e92:	70 e0       	ldi	r23, 0x00	; 0
     e94:	8d b7       	in	r24, 0x3d	; 61
     e96:	9e b7       	in	r25, 0x3e	; 62
     e98:	0a 97       	sbiw	r24, 0x0a	; 10
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	f8 94       	cli
     e9e:	9e bf       	out	0x3e, r25	; 62
     ea0:	0f be       	out	0x3f, r0	; 63
     ea2:	8d bf       	out	0x3d, r24	; 61
     ea4:	ed b7       	in	r30, 0x3d	; 61
     ea6:	fe b7       	in	r31, 0x3e	; 62
     ea8:	31 96       	adiw	r30, 0x01	; 1
     eaa:	ce 01       	movw	r24, r28
     eac:	05 96       	adiw	r24, 0x05	; 5
     eae:	91 83       	std	Z+1, r25	; 0x01
     eb0:	80 83       	st	Z, r24
     eb2:	88 e8       	ldi	r24, 0x88	; 136
     eb4:	91 e0       	ldi	r25, 0x01	; 1
     eb6:	93 83       	std	Z+3, r25	; 0x03
     eb8:	82 83       	std	Z+2, r24	; 0x02
     eba:	24 83       	std	Z+4, r18	; 0x04
     ebc:	35 83       	std	Z+5, r19	; 0x05
     ebe:	46 83       	std	Z+6, r20	; 0x06
     ec0:	57 83       	std	Z+7, r21	; 0x07
     ec2:	71 87       	std	Z+9, r23	; 0x09
     ec4:	60 87       	std	Z+8, r22	; 0x08
     ec6:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
     eca:	2d b7       	in	r18, 0x3d	; 61
     ecc:	3e b7       	in	r19, 0x3e	; 62
     ece:	26 5f       	subi	r18, 0xF6	; 246
     ed0:	3f 4f       	sbci	r19, 0xFF	; 255
     ed2:	0f b6       	in	r0, 0x3f	; 63
     ed4:	f8 94       	cli
     ed6:	3e bf       	out	0x3e, r19	; 62
     ed8:	0f be       	out	0x3f, r0	; 63
     eda:	2d bf       	out	0x3d, r18	; 61
										printf("%s",serial_print_buffer);
     edc:	00 d0       	rcall	.+0      	; 0xede <APLCallback+0x1e4>
     ede:	00 d0       	rcall	.+0      	; 0xee0 <APLCallback+0x1e6>
     ee0:	ed b7       	in	r30, 0x3d	; 61
     ee2:	fe b7       	in	r31, 0x3e	; 62
     ee4:	31 96       	adiw	r30, 0x01	; 1
     ee6:	85 e8       	ldi	r24, 0x85	; 133
     ee8:	91 e0       	ldi	r25, 0x01	; 1
     eea:	91 83       	std	Z+1, r25	; 0x01
     eec:	80 83       	st	Z, r24
     eee:	ce 01       	movw	r24, r28
     ef0:	05 96       	adiw	r24, 0x05	; 5
     ef2:	93 83       	std	Z+3, r25	; 0x03
     ef4:	82 83       	std	Z+2, r24	; 0x02
     ef6:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
     efa:	0f 90       	pop	r0
     efc:	0f 90       	pop	r0
     efe:	0f 90       	pop	r0
     f00:	0f 90       	pop	r0
     f02:	8c c1       	rjmp	.+792    	; 0x121c <__stack+0x11d>
									default : break;
								}
								break;

		case PD_DATA_INDICATION:
								if (talk_to_ARM == apl->mode)
     f04:	e0 91 ec 08 	lds	r30, 0x08EC
     f08:	f0 91 ed 08 	lds	r31, 0x08ED
     f0c:	80 89       	ldd	r24, Z+16	; 0x10
     f0e:	86 30       	cpi	r24, 0x06	; 6
     f10:	09 f0       	breq	.+2      	; 0xf14 <APLCallback+0x21a>
     f12:	80 c0       	rjmp	.+256    	; 0x1014 <APLCallback+0x31a>
								{	
									if ( ! apl->inbound_packet_available_flag ) {
     f14:	80 91 ec 08 	lds	r24, 0x08EC
     f18:	90 91 ed 08 	lds	r25, 0x08ED
     f1c:	fc 01       	movw	r30, r24
     f1e:	e0 5e       	subi	r30, 0xE0	; 224
     f20:	fe 4f       	sbci	r31, 0xFE	; 254
     f22:	80 81       	ld	r24, Z
     f24:	91 81       	ldd	r25, Z+1	; 0x01
     f26:	00 97       	sbiw	r24, 0x00	; 0
     f28:	09 f0       	breq	.+2      	; 0xf2c <APLCallback+0x232>
     f2a:	74 c0       	rjmp	.+232    	; 0x1014 <APLCallback+0x31a>
										apl->inbound_packet_available_flag = 1;
     f2c:	80 91 ec 08 	lds	r24, 0x08EC
     f30:	90 91 ed 08 	lds	r25, 0x08ED
     f34:	fc 01       	movw	r30, r24
     f36:	e0 5e       	subi	r30, 0xE0	; 224
     f38:	fe 4f       	sbci	r31, 0xFE	; 254
     f3a:	81 e0       	ldi	r24, 0x01	; 1
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	91 83       	std	Z+1, r25	; 0x01
     f40:	80 83       	st	Z, r24
										if (  0 !=  memcmp (msg->addr, lastAddr, 6) ) {
     f42:	8d a1       	ldd	r24, Y+37	; 0x25
     f44:	9e a1       	ldd	r25, Y+38	; 0x26
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	2b e8       	ldi	r18, 0x8B	; 139
     f4a:	3b e0       	ldi	r19, 0x0B	; 11
     f4c:	b9 01       	movw	r22, r18
     f4e:	46 e0       	ldi	r20, 0x06	; 6
     f50:	50 e0       	ldi	r21, 0x00	; 0
     f52:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
     f56:	00 97       	sbiw	r24, 0x00	; 0
     f58:	09 f4       	brne	.+2      	; 0xf5c <APLCallback+0x262>
     f5a:	44 c0       	rjmp	.+136    	; 0xfe4 <APLCallback+0x2ea>
											memcpy (lastAddr, msg->addr, 6);
     f5c:	8d a1       	ldd	r24, Y+37	; 0x25
     f5e:	9e a1       	ldd	r25, Y+38	; 0x26
     f60:	9c 01       	movw	r18, r24
     f62:	2f 5f       	subi	r18, 0xFF	; 255
     f64:	3f 4f       	sbci	r19, 0xFF	; 255
     f66:	8b e8       	ldi	r24, 0x8B	; 139
     f68:	9b e0       	ldi	r25, 0x0B	; 11
     f6a:	b9 01       	movw	r22, r18
     f6c:	46 e0       	ldi	r20, 0x06	; 6
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
											int address_size = sizeof(msg->addr[5]);
     f74:	81 e0       	ldi	r24, 0x01	; 1
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	9a 83       	std	Y+2, r25	; 0x02
     f7a:	89 83       	std	Y+1, r24	; 0x01
											memcpy( inpkt.params, &msg->addr[5], address_size );
     f7c:	8d a1       	ldd	r24, Y+37	; 0x25
     f7e:	9e a1       	ldd	r25, Y+38	; 0x26
     f80:	9c 01       	movw	r18, r24
     f82:	2a 5f       	subi	r18, 0xFA	; 250
     f84:	3f 4f       	sbci	r19, 0xFF	; 255
     f86:	49 81       	ldd	r20, Y+1	; 0x01
     f88:	5a 81       	ldd	r21, Y+2	; 0x02
     f8a:	8e e8       	ldi	r24, 0x8E	; 142
     f8c:	9a e0       	ldi	r25, 0x0A	; 10
     f8e:	b9 01       	movw	r22, r18
     f90:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
											inpkt.params[ address_size ] = ':';
     f94:	89 81       	ldd	r24, Y+1	; 0x01
     f96:	9a 81       	ldd	r25, Y+2	; 0x02
     f98:	fc 01       	movw	r30, r24
     f9a:	e2 57       	subi	r30, 0x72	; 114
     f9c:	f5 4f       	sbci	r31, 0xF5	; 245
     f9e:	8a e3       	ldi	r24, 0x3A	; 58
     fa0:	80 83       	st	Z, r24
											memcpy( &inpkt.params[ address_size + 1 ], msg->data, msg->len );
     fa2:	89 81       	ldd	r24, Y+1	; 0x01
     fa4:	9a 81       	ldd	r25, Y+2	; 0x02
     fa6:	01 96       	adiw	r24, 0x01	; 1
     fa8:	bc 01       	movw	r22, r24
     faa:	62 57       	subi	r22, 0x72	; 114
     fac:	75 4f       	sbci	r23, 0xF5	; 245
     fae:	8d a1       	ldd	r24, Y+37	; 0x25
     fb0:	9e a1       	ldd	r25, Y+38	; 0x26
     fb2:	ac 01       	movw	r20, r24
     fb4:	48 5f       	subi	r20, 0xF8	; 248
     fb6:	5f 4f       	sbci	r21, 0xFF	; 255
     fb8:	ed a1       	ldd	r30, Y+37	; 0x25
     fba:	fe a1       	ldd	r31, Y+38	; 0x26
     fbc:	87 81       	ldd	r24, Z+7	; 0x07
     fbe:	28 2f       	mov	r18, r24
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	cb 01       	movw	r24, r22
     fc4:	ba 01       	movw	r22, r20
     fc6:	a9 01       	movw	r20, r18
     fc8:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	    										//sprintf( inpkt.params, "from %d: got %d bytes", msg->addr[5], msg->len );
											inpkt.size = msg->len + address_size + 1; // we add one because of the ":" character we use to separate the address from the data when getting information from a new source. This is an unorthodox use of Sf_packet structure, the member "size" of this struct is really supposed to mean the size of the whole message with header and checksum included but in this case we are just using it as a buffer to hold incomming info.
     fcc:	ed a1       	ldd	r30, Y+37	; 0x25
     fce:	fe a1       	ldd	r31, Y+38	; 0x26
     fd0:	97 81       	ldd	r25, Z+7	; 0x07
     fd2:	89 81       	ldd	r24, Y+1	; 0x01
     fd4:	89 0f       	add	r24, r25
     fd6:	8f 5f       	subi	r24, 0xFF	; 255
     fd8:	80 93 8b 0a 	sts	0x0A8B, r24
											inpkt.type = incomming_data_but_source_changed;
     fdc:	81 e1       	ldi	r24, 0x11	; 17
     fde:	80 93 8c 0a 	sts	0x0A8C, r24
     fe2:	18 c0       	rjmp	.+48     	; 0x1014 <APLCallback+0x31a>
										} else { //don't send data source info if it's same as last time
											memcpy( inpkt.params, msg->data, msg->len );
     fe4:	8d a1       	ldd	r24, Y+37	; 0x25
     fe6:	9e a1       	ldd	r25, Y+38	; 0x26
     fe8:	ac 01       	movw	r20, r24
     fea:	48 5f       	subi	r20, 0xF8	; 248
     fec:	5f 4f       	sbci	r21, 0xFF	; 255
     fee:	ed a1       	ldd	r30, Y+37	; 0x25
     ff0:	fe a1       	ldd	r31, Y+38	; 0x26
     ff2:	87 81       	ldd	r24, Z+7	; 0x07
     ff4:	28 2f       	mov	r18, r24
     ff6:	30 e0       	ldi	r19, 0x00	; 0
     ff8:	8e e8       	ldi	r24, 0x8E	; 142
     ffa:	9a e0       	ldi	r25, 0x0A	; 10
     ffc:	ba 01       	movw	r22, r20
     ffe:	a9 01       	movw	r20, r18
    1000:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
											inpkt.size = msg->len; // See comment above
    1004:	ed a1       	ldd	r30, Y+37	; 0x25
    1006:	fe a1       	ldd	r31, Y+38	; 0x26
    1008:	87 81       	ldd	r24, Z+7	; 0x07
    100a:	80 93 8b 0a 	sts	0x0A8B, r24
											inpkt.type = incomming_data;
    100e:	8f e0       	ldi	r24, 0x0F	; 15
    1010:	80 93 8c 0a 	sts	0x0A8C, r24
									{
										putchar (msg->data[i]);
									}
									*/
								}
								if (chat == apl->mode)
    1014:	e0 91 ec 08 	lds	r30, 0x08EC
    1018:	f0 91 ed 08 	lds	r31, 0x08ED
    101c:	80 89       	ldd	r24, Z+16	; 0x10
    101e:	81 30       	cpi	r24, 0x01	; 1
    1020:	09 f0       	breq	.+2      	; 0x1024 <APLCallback+0x32a>
    1022:	66 c0       	rjmp	.+204    	; 0x10f0 <APLCallback+0x3f6>
								{
									if (memcmp (msg->addr, lastAddr, 6) != 0)
    1024:	8d a1       	ldd	r24, Y+37	; 0x25
    1026:	9e a1       	ldd	r25, Y+38	; 0x26
    1028:	01 96       	adiw	r24, 0x01	; 1
    102a:	2b e8       	ldi	r18, 0x8B	; 139
    102c:	3b e0       	ldi	r19, 0x0B	; 11
    102e:	b9 01       	movw	r22, r18
    1030:	46 e0       	ldi	r20, 0x06	; 6
    1032:	50 e0       	ldi	r21, 0x00	; 0
    1034:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    1038:	00 97       	sbiw	r24, 0x00	; 0
    103a:	11 f1       	breq	.+68     	; 0x1080 <APLCallback+0x386>
									{
										memcpy (lastAddr, msg->addr, 6);
    103c:	8d a1       	ldd	r24, Y+37	; 0x25
    103e:	9e a1       	ldd	r25, Y+38	; 0x26
    1040:	9c 01       	movw	r18, r24
    1042:	2f 5f       	subi	r18, 0xFF	; 255
    1044:	3f 4f       	sbci	r19, 0xFF	; 255
    1046:	8b e8       	ldi	r24, 0x8B	; 139
    1048:	9b e0       	ldi	r25, 0x0B	; 11
    104a:	b9 01       	movw	r22, r18
    104c:	46 e0       	ldi	r20, 0x06	; 6
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
										GUI_CHAR;
										printf ("\n%d> ", msg->addr[5]);
    1054:	ed a1       	ldd	r30, Y+37	; 0x25
    1056:	fe a1       	ldd	r31, Y+38	; 0x26
    1058:	86 81       	ldd	r24, Z+6	; 0x06
    105a:	28 2f       	mov	r18, r24
    105c:	30 e0       	ldi	r19, 0x00	; 0
    105e:	00 d0       	rcall	.+0      	; 0x1060 <APLCallback+0x366>
    1060:	00 d0       	rcall	.+0      	; 0x1062 <APLCallback+0x368>
    1062:	ed b7       	in	r30, 0x3d	; 61
    1064:	fe b7       	in	r31, 0x3e	; 62
    1066:	31 96       	adiw	r30, 0x01	; 1
    1068:	85 e9       	ldi	r24, 0x95	; 149
    106a:	91 e0       	ldi	r25, 0x01	; 1
    106c:	91 83       	std	Z+1, r25	; 0x01
    106e:	80 83       	st	Z, r24
    1070:	33 83       	std	Z+3, r19	; 0x03
    1072:	22 83       	std	Z+2, r18	; 0x02
    1074:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    1078:	0f 90       	pop	r0
    107a:	0f 90       	pop	r0
    107c:	0f 90       	pop	r0
    107e:	0f 90       	pop	r0
									}
									GUI_CHAR;
									for (i = 0; i < msg->len; i++)
    1080:	1c 82       	std	Y+4, r1	; 0x04
    1082:	1b 82       	std	Y+3, r1	; 0x03
    1084:	2b c0       	rjmp	.+86     	; 0x10dc <APLCallback+0x3e2>
									{
										putchar (msg->data[i]);
    1086:	2b 81       	ldd	r18, Y+3	; 0x03
    1088:	3c 81       	ldd	r19, Y+4	; 0x04
    108a:	8d a1       	ldd	r24, Y+37	; 0x25
    108c:	9e a1       	ldd	r25, Y+38	; 0x26
    108e:	82 0f       	add	r24, r18
    1090:	93 1f       	adc	r25, r19
    1092:	fc 01       	movw	r30, r24
    1094:	38 96       	adiw	r30, 0x08	; 8
    1096:	80 81       	ld	r24, Z
    1098:	88 2f       	mov	r24, r24
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	20 91 5c 10 	lds	r18, 0x105C
    10a0:	30 91 5d 10 	lds	r19, 0x105D
    10a4:	b9 01       	movw	r22, r18
    10a6:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
										if (msg->data[i] == 0x0d)
    10aa:	2b 81       	ldd	r18, Y+3	; 0x03
    10ac:	3c 81       	ldd	r19, Y+4	; 0x04
    10ae:	8d a1       	ldd	r24, Y+37	; 0x25
    10b0:	9e a1       	ldd	r25, Y+38	; 0x26
    10b2:	82 0f       	add	r24, r18
    10b4:	93 1f       	adc	r25, r19
    10b6:	fc 01       	movw	r30, r24
    10b8:	38 96       	adiw	r30, 0x08	; 8
    10ba:	80 81       	ld	r24, Z
    10bc:	8d 30       	cpi	r24, 0x0D	; 13
    10be:	49 f4       	brne	.+18     	; 0x10d2 <APLCallback+0x3d8>
										{
											putchar (0x0a);
    10c0:	20 91 5c 10 	lds	r18, 0x105C
    10c4:	30 91 5d 10 	lds	r19, 0x105D
    10c8:	8a e0       	ldi	r24, 0x0A	; 10
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	b9 01       	movw	r22, r18
    10ce:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
										memcpy (lastAddr, msg->addr, 6);
										GUI_CHAR;
										printf ("\n%d> ", msg->addr[5]);
									}
									GUI_CHAR;
									for (i = 0; i < msg->len; i++)
    10d2:	8b 81       	ldd	r24, Y+3	; 0x03
    10d4:	9c 81       	ldd	r25, Y+4	; 0x04
    10d6:	01 96       	adiw	r24, 0x01	; 1
    10d8:	9c 83       	std	Y+4, r25	; 0x04
    10da:	8b 83       	std	Y+3, r24	; 0x03
    10dc:	ed a1       	ldd	r30, Y+37	; 0x25
    10de:	fe a1       	ldd	r31, Y+38	; 0x26
    10e0:	87 81       	ldd	r24, Z+7	; 0x07
    10e2:	28 2f       	mov	r18, r24
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	8b 81       	ldd	r24, Y+3	; 0x03
    10e8:	9c 81       	ldd	r25, Y+4	; 0x04
    10ea:	82 17       	cp	r24, r18
    10ec:	93 07       	cpc	r25, r19
    10ee:	5c f2       	brlt	.-106    	; 0x1086 <APLCallback+0x38c>
											putchar (0x0d);
#											endif
										}
									}
								}
								if (listen_for_range_requests == apl->mode)
    10f0:	e0 91 ec 08 	lds	r30, 0x08EC
    10f4:	f0 91 ed 08 	lds	r31, 0x08ED
    10f8:	80 89       	ldd	r24, Z+16	; 0x10
    10fa:	84 30       	cpi	r24, 0x04	; 4
    10fc:	09 f0       	breq	.+2      	; 0x1100 <__stack+0x1>
    10fe:	8e c0       	rjmp	.+284    	; 0x121c <__stack+0x11d>
								{

									if(msg->data[0] != lastPacketTag)
    1100:	ed a1       	ldd	r30, Y+37	; 0x25
    1102:	fe a1       	ldd	r31, Y+38	; 0x26
    1104:	90 85       	ldd	r25, Z+8	; 0x08
    1106:	80 91 8a 0b 	lds	r24, 0x0B8A
    110a:	98 17       	cp	r25, r24
    110c:	09 f4       	brne	.+2      	; 0x1110 <__stack+0x11>
    110e:	86 c0       	rjmp	.+268    	; 0x121c <__stack+0x11d>
									{
										lastPacketTag = msg->data[0];
    1110:	ed a1       	ldd	r30, Y+37	; 0x25
    1112:	fe a1       	ldd	r31, Y+38	; 0x26
    1114:	80 85       	ldd	r24, Z+8	; 0x08
    1116:	80 93 8a 0b 	sts	0x0B8A, r24
										packets_received++;
    111a:	80 91 88 09 	lds	r24, 0x0988
    111e:	90 91 89 09 	lds	r25, 0x0989
    1122:	01 96       	adiw	r24, 0x01	; 1
    1124:	90 93 89 09 	sts	0x0989, r25
    1128:	80 93 88 09 	sts	0x0988, r24
										printf("%d packets received ", packets_received);
    112c:	20 91 88 09 	lds	r18, 0x0988
    1130:	30 91 89 09 	lds	r19, 0x0989
    1134:	00 d0       	rcall	.+0      	; 0x1136 <__stack+0x37>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <__stack+0x39>
    1138:	ed b7       	in	r30, 0x3d	; 61
    113a:	fe b7       	in	r31, 0x3e	; 62
    113c:	31 96       	adiw	r30, 0x01	; 1
    113e:	8b e9       	ldi	r24, 0x9B	; 155
    1140:	91 e0       	ldi	r25, 0x01	; 1
    1142:	91 83       	std	Z+1, r25	; 0x01
    1144:	80 83       	st	Z, r24
    1146:	33 83       	std	Z+3, r19	; 0x03
    1148:	22 83       	std	Z+2, r18	; 0x02
    114a:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    114e:	0f 90       	pop	r0
    1150:	0f 90       	pop	r0
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
										printf("%d",msg->data[0]);
    1156:	ed a1       	ldd	r30, Y+37	; 0x25
    1158:	fe a1       	ldd	r31, Y+38	; 0x26
    115a:	80 85       	ldd	r24, Z+8	; 0x08
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	00 d0       	rcall	.+0      	; 0x1162 <__stack+0x63>
    1162:	00 d0       	rcall	.+0      	; 0x1164 <__stack+0x65>
    1164:	ed b7       	in	r30, 0x3d	; 61
    1166:	fe b7       	in	r31, 0x3e	; 62
    1168:	31 96       	adiw	r30, 0x01	; 1
    116a:	80 eb       	ldi	r24, 0xB0	; 176
    116c:	91 e0       	ldi	r25, 0x01	; 1
    116e:	91 83       	std	Z+1, r25	; 0x01
    1170:	80 83       	st	Z, r24
    1172:	33 83       	std	Z+3, r19	; 0x03
    1174:	22 83       	std	Z+2, r18	; 0x02
    1176:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    117a:	0f 90       	pop	r0
    117c:	0f 90       	pop	r0
    117e:	0f 90       	pop	r0
    1180:	0f 90       	pop	r0
										printf("\n");
    1182:	8a e0       	ldi	r24, 0x0A	; 10
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	0e 94 cd 45 	call	0x8b9a	; 0x8b9a <putchar>
    118a:	48 c0       	rjmp	.+144    	; 0x121c <__stack+0x11d>
								}
								break;

		case PD_RANGING_INDICATION:  // These cases trigger when we sent a ranging request and get a reflected response back.
		case PD_RANGING_FAST_INDICATION:
								if (terminal == apl->mode) break;
    118c:	e0 91 ec 08 	lds	r30, 0x08EC
    1190:	f0 91 ed 08 	lds	r31, 0x08ED
    1194:	80 89       	ldd	r24, Z+16	; 0x10
    1196:	88 23       	and	r24, r24
    1198:	09 f4       	brne	.+2      	; 0x119c <__stack+0x9d>
    119a:	40 c0       	rjmp	.+128    	; 0x121c <__stack+0x11d>
								if ( talk_to_ARM == apl->mode ) {
    119c:	e0 91 ec 08 	lds	r30, 0x08EC
    11a0:	f0 91 ed 08 	lds	r31, 0x08ED
    11a4:	80 89       	ldd	r24, Z+16	; 0x10
    11a6:	86 30       	cpi	r24, 0x06	; 6
    11a8:	c9 f5       	brne	.+114    	; 0x121c <__stack+0x11d>
									LED0 (LED_OFF);
    11aa:	a2 e2       	ldi	r26, 0x22	; 34
    11ac:	b0 e0       	ldi	r27, 0x00	; 0
    11ae:	e2 e2       	ldi	r30, 0x22	; 34
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	80 81       	ld	r24, Z
    11b4:	80 68       	ori	r24, 0x80	; 128
    11b6:	8c 93       	st	X, r24
									upRangingMsg = (RangingPIB*) msg->data;
    11b8:	8d a1       	ldd	r24, Y+37	; 0x25
    11ba:	9e a1       	ldd	r25, Y+38	; 0x26
    11bc:	08 96       	adiw	r24, 0x08	; 8
    11be:	90 93 87 09 	sts	0x0987, r25
    11c2:	80 93 86 09 	sts	0x0986, r24
									if (  0  ==  upRangingMsg->error ) {
    11c6:	e0 91 86 09 	lds	r30, 0x0986
    11ca:	f0 91 87 09 	lds	r31, 0x0987
    11ce:	80 81       	ld	r24, Z
    11d0:	88 23       	and	r24, r24
    11d2:	21 f5       	brne	.+72     	; 0x121c <__stack+0x11d>
										if ( 0 == apl->ranging_info_available_flag ) {
    11d4:	80 91 ec 08 	lds	r24, 0x08EC
    11d8:	90 91 ed 08 	lds	r25, 0x08ED
    11dc:	fc 01       	movw	r30, r24
    11de:	ee 5d       	subi	r30, 0xDE	; 222
    11e0:	fe 4f       	sbci	r31, 0xFE	; 254
    11e2:	80 81       	ld	r24, Z
    11e4:	91 81       	ldd	r25, Z+1	; 0x01
    11e6:	00 97       	sbiw	r24, 0x00	; 0
    11e8:	c9 f4       	brne	.+50     	; 0x121c <__stack+0x11d>
											//sprintf(serial_print_buffer,"#%07.2f:%03i:%03i\n",upRangingMsg->distance,msg->addr[0],upRangingMsg->error);
											memcpy( &ranging_info_buffer.params, &upRangingMsg->distance, sizeof(upRangingMsg->distance)  );
    11ea:	80 91 86 09 	lds	r24, 0x0986
    11ee:	90 91 87 09 	lds	r25, 0x0987
    11f2:	9c 01       	movw	r18, r24
    11f4:	2e 5f       	subi	r18, 0xFE	; 254
    11f6:	3f 4f       	sbci	r19, 0xFF	; 255
    11f8:	8e e8       	ldi	r24, 0x8E	; 142
    11fa:	99 e0       	ldi	r25, 0x09	; 9
    11fc:	b9 01       	movw	r22, r18
    11fe:	44 e0       	ldi	r20, 0x04	; 4
    1200:	50 e0       	ldi	r21, 0x00	; 0
    1202:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
											//sprintf( ((char*)&ranging_info_buffer.params) + sizeof(upRangingMsg->distance) ,"%07.2f",upRangingMsg->distance); // This line was supposed to append the ascii representation of the distance to the binary one, so we could confirm we were decoding distance properly in the ARM side
											apl->ranging_info_available_flag = 1;
    1206:	80 91 ec 08 	lds	r24, 0x08EC
    120a:	90 91 ed 08 	lds	r25, 0x08ED
    120e:	fc 01       	movw	r30, r24
    1210:	ee 5d       	subi	r30, 0xDE	; 222
    1212:	fe 4f       	sbci	r31, 0xFE	; 254
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	91 83       	std	Z+1, r25	; 0x01
    121a:	80 83       	st	Z, r24
								}
								break;

		default:				break;
	}
}
    121c:	aa 96       	adiw	r28, 0x2a	; 42
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	f8 94       	cli
    1222:	de bf       	out	0x3e, r29	; 62
    1224:	0f be       	out	0x3f, r0	; 63
    1226:	cd bf       	out	0x3d, r28	; 61
    1228:	cf 91       	pop	r28
    122a:	df 91       	pop	r29
    122c:	08 95       	ret

0000122e <APLInit>:
 * init/start of the lower layers.
 */
/***************************************************************************/
void APLInit(void)
/***************************************************************************/
{
    122e:	df 93       	push	r29
    1230:	cf 93       	push	r28
    1232:	cd b7       	in	r28, 0x3d	; 61
    1234:	de b7       	in	r29, 0x3e	; 62
    1236:	66 97       	sbiw	r28, 0x16	; 22
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
	MyByte8T		s_address[] = {0,0,0,0,0,1};
    1242:	ce 01       	movw	r24, r28
    1244:	01 96       	adiw	r24, 0x01	; 1
    1246:	9e 87       	std	Y+14, r25	; 0x0e
    1248:	8d 87       	std	Y+13, r24	; 0x0d
    124a:	e9 eb       	ldi	r30, 0xB9	; 185
    124c:	f1 e0       	ldi	r31, 0x01	; 1
    124e:	f8 8b       	std	Y+16, r31	; 0x10
    1250:	ef 87       	std	Y+15, r30	; 0x0f
    1252:	f6 e0       	ldi	r31, 0x06	; 6
    1254:	f9 8b       	std	Y+17, r31	; 0x11
    1256:	ef 85       	ldd	r30, Y+15	; 0x0f
    1258:	f8 89       	ldd	r31, Y+16	; 0x10
    125a:	00 80       	ld	r0, Z
    125c:	8f 85       	ldd	r24, Y+15	; 0x0f
    125e:	98 89       	ldd	r25, Y+16	; 0x10
    1260:	01 96       	adiw	r24, 0x01	; 1
    1262:	98 8b       	std	Y+16, r25	; 0x10
    1264:	8f 87       	std	Y+15, r24	; 0x0f
    1266:	ed 85       	ldd	r30, Y+13	; 0x0d
    1268:	fe 85       	ldd	r31, Y+14	; 0x0e
    126a:	00 82       	st	Z, r0
    126c:	8d 85       	ldd	r24, Y+13	; 0x0d
    126e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1270:	01 96       	adiw	r24, 0x01	; 1
    1272:	9e 87       	std	Y+14, r25	; 0x0e
    1274:	8d 87       	std	Y+13, r24	; 0x0d
    1276:	99 89       	ldd	r25, Y+17	; 0x11
    1278:	91 50       	subi	r25, 0x01	; 1
    127a:	99 8b       	std	Y+17, r25	; 0x11
    127c:	e9 89       	ldd	r30, Y+17	; 0x11
    127e:	ee 23       	and	r30, r30
    1280:	51 f7       	brne	.-44     	; 0x1256 <APLInit+0x28>
	MyByte8T		d_address[] = {0,0,0,0,0,2};
    1282:	ce 01       	movw	r24, r28
    1284:	07 96       	adiw	r24, 0x07	; 7
    1286:	9b 8b       	std	Y+19, r25	; 0x13
    1288:	8a 8b       	std	Y+18, r24	; 0x12
    128a:	e3 eb       	ldi	r30, 0xB3	; 179
    128c:	f1 e0       	ldi	r31, 0x01	; 1
    128e:	fd 8b       	std	Y+21, r31	; 0x15
    1290:	ec 8b       	std	Y+20, r30	; 0x14
    1292:	f6 e0       	ldi	r31, 0x06	; 6
    1294:	fe 8b       	std	Y+22, r31	; 0x16
    1296:	ec 89       	ldd	r30, Y+20	; 0x14
    1298:	fd 89       	ldd	r31, Y+21	; 0x15
    129a:	00 80       	ld	r0, Z
    129c:	8c 89       	ldd	r24, Y+20	; 0x14
    129e:	9d 89       	ldd	r25, Y+21	; 0x15
    12a0:	01 96       	adiw	r24, 0x01	; 1
    12a2:	9d 8b       	std	Y+21, r25	; 0x15
    12a4:	8c 8b       	std	Y+20, r24	; 0x14
    12a6:	ea 89       	ldd	r30, Y+18	; 0x12
    12a8:	fb 89       	ldd	r31, Y+19	; 0x13
    12aa:	00 82       	st	Z, r0
    12ac:	8a 89       	ldd	r24, Y+18	; 0x12
    12ae:	9b 89       	ldd	r25, Y+19	; 0x13
    12b0:	01 96       	adiw	r24, 0x01	; 1
    12b2:	9b 8b       	std	Y+19, r25	; 0x13
    12b4:	8a 8b       	std	Y+18, r24	; 0x12
    12b6:	9e 89       	ldd	r25, Y+22	; 0x16
    12b8:	91 50       	subi	r25, 0x01	; 1
    12ba:	9e 8b       	std	Y+22, r25	; 0x16
    12bc:	ee 89       	ldd	r30, Y+22	; 0x16
    12be:	ee 23       	and	r30, r30
    12c0:	51 f7       	brne	.-44     	; 0x1296 <APLInit+0x68>

        apl = &aplM;
    12c2:	86 ec       	ldi	r24, 0xC6	; 198
    12c4:	97 e0       	ldi	r25, 0x07	; 7
    12c6:	90 93 ed 08 	sts	0x08ED, r25
    12ca:	80 93 ec 08 	sts	0x08EC, r24
	/*
     * for this simple demo transmitter and receiver
     * use the same MAC address. This way we need only
     * one executable for both stations.
     */
	memcpy (apl->src, s_address, 6);
    12ce:	80 91 ec 08 	lds	r24, 0x08EC
    12d2:	90 91 ed 08 	lds	r25, 0x08ED
    12d6:	0a 96       	adiw	r24, 0x0a	; 10
    12d8:	9e 01       	movw	r18, r28
    12da:	2f 5f       	subi	r18, 0xFF	; 255
    12dc:	3f 4f       	sbci	r19, 0xFF	; 255
    12de:	b9 01       	movw	r22, r18
    12e0:	46 e0       	ldi	r20, 0x06	; 6
    12e2:	50 e0       	ldi	r21, 0x00	; 0
    12e4:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	memcpy (apl->dest, d_address, 6);
    12e8:	80 91 ec 08 	lds	r24, 0x08EC
    12ec:	90 91 ed 08 	lds	r25, 0x08ED
    12f0:	04 96       	adiw	r24, 0x04	; 4
    12f2:	9e 01       	movw	r18, r28
    12f4:	29 5f       	subi	r18, 0xF9	; 249
    12f6:	3f 4f       	sbci	r19, 0xFF	; 255
    12f8:	b9 01       	movw	r22, r18
    12fa:	46 e0       	ldi	r20, 0x06	; 6
    12fc:	50 e0       	ldi	r21, 0x00	; 0
    12fe:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	downMsg.prim = PLME_SET_REQUEST;
    1302:	8b e0       	ldi	r24, 0x0B	; 11
    1304:	80 93 ee 08 	sts	0x08EE, r24
	downMsg.attribute = PHY_MAC_ADDRESS1;
    1308:	83 e7       	ldi	r24, 0x73	; 115
    130a:	80 93 79 09 	sts	0x0979, r24
	memcpy (downMsg.data, s_address, 6);
    130e:	86 ef       	ldi	r24, 0xF6	; 246
    1310:	98 e0       	ldi	r25, 0x08	; 8
    1312:	9e 01       	movw	r18, r28
    1314:	2f 5f       	subi	r18, 0xFF	; 255
    1316:	3f 4f       	sbci	r19, 0xFF	; 255
    1318:	b9 01       	movw	r22, r18
    131a:	46 e0       	ldi	r20, 0x06	; 6
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	PLMESap (&downMsg);
    1322:	8e ee       	ldi	r24, 0xEE	; 238
    1324:	98 e0       	ldi	r25, 0x08	; 8
    1326:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

	/* These variables are used by the demo application.
         * They are used by the user interface
         */
        apl->hwclock = 0;
    132a:	e0 91 ec 08 	lds	r30, 0x08EC
    132e:	f0 91 ed 08 	lds	r31, 0x08ED
    1332:	10 82       	st	Z, r1
    1334:	11 82       	std	Z+1, r1	; 0x01
    1336:	12 82       	std	Z+2, r1	; 0x02
    1338:	13 82       	std	Z+3, r1	; 0x03
	apl->mode = talk_to_ARM;
    133a:	e0 91 ec 08 	lds	r30, 0x08EC
    133e:	f0 91 ed 08 	lds	r31, 0x08ED
    1342:	86 e0       	ldi	r24, 0x06	; 6
    1344:	80 8b       	std	Z+16, r24	; 0x10
	apl->help = 0;
    1346:	e0 91 ec 08 	lds	r30, 0x08EC
    134a:	f0 91 ed 08 	lds	r31, 0x08ED
    134e:	11 8a       	std	Z+17, r1	; 0x11
	apl->len = 0;
    1350:	e0 91 ec 08 	lds	r30, 0x08EC
    1354:	f0 91 ed 08 	lds	r31, 0x08ED
    1358:	12 8a       	std	Z+18, r1	; 0x12
	apl->inbound_packet_available_flag = 0;
    135a:	80 91 ec 08 	lds	r24, 0x08EC
    135e:	90 91 ed 08 	lds	r25, 0x08ED
    1362:	fc 01       	movw	r30, r24
    1364:	e0 5e       	subi	r30, 0xE0	; 224
    1366:	fe 4f       	sbci	r31, 0xFE	; 254
    1368:	11 82       	std	Z+1, r1	; 0x01
    136a:	10 82       	st	Z, r1
	apl->tkey[2] = FALSE;
	apl->tkey[3] = FALSE;
#	endif /* CONFIG_USE_KEYS */

	/* switch on receiver */
	downMsg.prim = PLME_SET_REQUEST;
    136c:	8b e0       	ldi	r24, 0x0B	; 11
    136e:	80 93 ee 08 	sts	0x08EE, r24
	downMsg.attribute = PHY_RX_CMD;
    1372:	81 e9       	ldi	r24, 0x91	; 145
    1374:	80 93 79 09 	sts	0x0979, r24
	downMsg.value = PHY_RX_ON;
    1378:	86 e0       	ldi	r24, 0x06	; 6
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	90 93 78 09 	sts	0x0978, r25
    1380:	80 93 77 09 	sts	0x0977, r24
	PLMESap (&downMsg);
    1384:	8e ee       	ldi	r24, 0xEE	; 238
    1386:	98 e0       	ldi	r25, 0x08	; 8
    1388:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
	// /* switch off receiver */
	// downMsg.prim = PLME_SET_REQUEST;
	// downMsg.attribute = PHY_RX_CMD;
	// downMsg.value = PHY_TRX_OFF;
	// PLMESap (&downMsg);
}
    138c:	66 96       	adiw	r28, 0x16	; 22
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	f8 94       	cli
    1392:	de bf       	out	0x3e, r29	; 62
    1394:	0f be       	out	0x3f, r0	; 63
    1396:	cd bf       	out	0x3d, r28	; 61
    1398:	cf 91       	pop	r28
    139a:	df 91       	pop	r29
    139c:	08 95       	ret

0000139e <setCTS>:
 * .
 */
/***************************************************************************/
void setCTS (int new_state)
/***************************************************************************/
{
    139e:	df 93       	push	r29
    13a0:	cf 93       	push	r28
    13a2:	00 d0       	rcall	.+0      	; 0x13a4 <setCTS+0x6>
    13a4:	00 d0       	rcall	.+0      	; 0x13a6 <setCTS+0x8>
    13a6:	cd b7       	in	r28, 0x3d	; 61
    13a8:	de b7       	in	r29, 0x3e	; 62
    13aa:	9a 83       	std	Y+2, r25	; 0x02
    13ac:	89 83       	std	Y+1, r24	; 0x01
	switch (new_state) {
    13ae:	89 81       	ldd	r24, Y+1	; 0x01
    13b0:	9a 81       	ldd	r25, Y+2	; 0x02
    13b2:	9c 83       	std	Y+4, r25	; 0x04
    13b4:	8b 83       	std	Y+3, r24	; 0x03
    13b6:	8b 81       	ldd	r24, Y+3	; 0x03
    13b8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ba:	00 97       	sbiw	r24, 0x00	; 0
    13bc:	31 f0       	breq	.+12     	; 0x13ca <setCTS+0x2c>
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	9c 81       	ldd	r25, Y+4	; 0x04
    13c2:	81 30       	cpi	r24, 0x01	; 1
    13c4:	91 05       	cpc	r25, r1
    13c6:	49 f0       	breq	.+18     	; 0x13da <setCTS+0x3c>
    13c8:	0f c0       	rjmp	.+30     	; 0x13e8 <setCTS+0x4a>
	   case 0:
	      CTS_PORT &= ~CTS_PIN;
    13ca:	a2 e2       	ldi	r26, 0x22	; 34
    13cc:	b0 e0       	ldi	r27, 0x00	; 0
    13ce:	e2 e2       	ldi	r30, 0x22	; 34
    13d0:	f0 e0       	ldi	r31, 0x00	; 0
    13d2:	80 81       	ld	r24, Z
    13d4:	8f 7d       	andi	r24, 0xDF	; 223
    13d6:	8c 93       	st	X, r24
    13d8:	07 c0       	rjmp	.+14     	; 0x13e8 <setCTS+0x4a>
	      break;
	   case 1:
              CTS_PORT |= CTS_PIN;
    13da:	a2 e2       	ldi	r26, 0x22	; 34
    13dc:	b0 e0       	ldi	r27, 0x00	; 0
    13de:	e2 e2       	ldi	r30, 0x22	; 34
    13e0:	f0 e0       	ldi	r31, 0x00	; 0
    13e2:	80 81       	ld	r24, Z
    13e4:	80 62       	ori	r24, 0x20	; 32
    13e6:	8c 93       	st	X, r24
	      break;
	   default: //we should never reach here
	   //puts("Error: incorrect cts signal"); //commented out to save string space
	   break;
	}
}
    13e8:	0f 90       	pop	r0
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	cf 91       	pop	r28
    13f2:	df 91       	pop	r29
    13f4:	08 95       	ret

000013f6 <SendBuffer>:
 * to the payload buffer and requests a data transmission from the lower layer.
 */
/***************************************************************************/
void SendBuffer (void)
/***************************************************************************/
{
    13f6:	df 93       	push	r29
    13f8:	cf 93       	push	r28
    13fa:	cd b7       	in	r28, 0x3d	; 61
    13fc:	de b7       	in	r29, 0x3e	; 62
	setCTS(0);
    13fe:	80 e0       	ldi	r24, 0x00	; 0
    1400:	90 e0       	ldi	r25, 0x00	; 0
    1402:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
	memcpy (downMsg.addr, apl->dest, 6);
    1406:	80 91 ec 08 	lds	r24, 0x08EC
    140a:	90 91 ed 08 	lds	r25, 0x08ED
    140e:	9c 01       	movw	r18, r24
    1410:	2c 5f       	subi	r18, 0xFC	; 252
    1412:	3f 4f       	sbci	r19, 0xFF	; 255
    1414:	8f ee       	ldi	r24, 0xEF	; 239
    1416:	98 e0       	ldi	r25, 0x08	; 8
    1418:	b9 01       	movw	r22, r18
    141a:	46 e0       	ldi	r20, 0x06	; 6
    141c:	50 e0       	ldi	r21, 0x00	; 0
    141e:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	downMsg.prim = PD_DATA_REQUEST;
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	80 93 ee 08 	sts	0x08EE, r24
	downMsg.len = apl->len;
    1428:	e0 91 ec 08 	lds	r30, 0x08EC
    142c:	f0 91 ed 08 	lds	r31, 0x08ED
    1430:	82 89       	ldd	r24, Z+18	; 0x12
    1432:	80 93 f5 08 	sts	0x08F5, r24
	apl->len = 0;
    1436:	e0 91 ec 08 	lds	r30, 0x08EC
    143a:	f0 91 ed 08 	lds	r31, 0x08ED
    143e:	12 8a       	std	Z+18, r1	; 0x12
	SendMsg (&downMsg);
    1440:	8e ee       	ldi	r24, 0xEE	; 238
    1442:	98 e0       	ldi	r25, 0x08	; 8
    1444:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <PDSap>
        setCTS(1);
    1448:	81 e0       	ldi	r24, 0x01	; 1
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
}
    1450:	cf 91       	pop	r28
    1452:	df 91       	pop	r29
    1454:	08 95       	ret

00001456 <SendRange>:


void SendRange (void)
{
    1456:	df 93       	push	r29
    1458:	cf 93       	push	r28
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
	setCTS(0);
    145e:	80 e0       	ldi	r24, 0x00	; 0
    1460:	90 e0       	ldi	r25, 0x00	; 0
    1462:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
	memcpy (downMsg.addr, apl->dest, 6);
    1466:	80 91 ec 08 	lds	r24, 0x08EC
    146a:	90 91 ed 08 	lds	r25, 0x08ED
    146e:	9c 01       	movw	r18, r24
    1470:	2c 5f       	subi	r18, 0xFC	; 252
    1472:	3f 4f       	sbci	r19, 0xFF	; 255
    1474:	8f ee       	ldi	r24, 0xEF	; 239
    1476:	98 e0       	ldi	r25, 0x08	; 8
    1478:	b9 01       	movw	r22, r18
    147a:	46 e0       	ldi	r20, 0x06	; 6
    147c:	50 e0       	ldi	r21, 0x00	; 0
    147e:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	downMsg.prim = PD_RANGING_REQUEST;
    1482:	8e e0       	ldi	r24, 0x0E	; 14
    1484:	80 93 ee 08 	sts	0x08EE, r24
	apl->len = 0;
    1488:	e0 91 ec 08 	lds	r30, 0x08EC
    148c:	f0 91 ed 08 	lds	r31, 0x08ED
    1490:	12 8a       	std	Z+18, r1	; 0x12
	SendMsg (&downMsg);
    1492:	8e ee       	ldi	r24, 0xEE	; 238
    1494:	98 e0       	ldi	r25, 0x08	; 8
    1496:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <PDSap>
	setCTS(1);
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
}
    14a2:	cf 91       	pop	r28
    14a4:	df 91       	pop	r29
    14a6:	08 95       	ret

000014a8 <SendFastRange>:

void SendFastRange (void)
{
    14a8:	df 93       	push	r29
    14aa:	cf 93       	push	r28
    14ac:	cd b7       	in	r28, 0x3d	; 61
    14ae:	de b7       	in	r29, 0x3e	; 62
	setCTS(0);
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
	memcpy (downMsg.addr, apl->dest, 6);
    14b8:	80 91 ec 08 	lds	r24, 0x08EC
    14bc:	90 91 ed 08 	lds	r25, 0x08ED
    14c0:	9c 01       	movw	r18, r24
    14c2:	2c 5f       	subi	r18, 0xFC	; 252
    14c4:	3f 4f       	sbci	r19, 0xFF	; 255
    14c6:	8f ee       	ldi	r24, 0xEF	; 239
    14c8:	98 e0       	ldi	r25, 0x08	; 8
    14ca:	b9 01       	movw	r22, r18
    14cc:	46 e0       	ldi	r20, 0x06	; 6
    14ce:	50 e0       	ldi	r21, 0x00	; 0
    14d0:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	downMsg.prim = PD_RANGING_FAST_REQUEST;
    14d4:	84 e1       	ldi	r24, 0x14	; 20
    14d6:	80 93 ee 08 	sts	0x08EE, r24
	apl->len = 0;
    14da:	e0 91 ec 08 	lds	r30, 0x08EC
    14de:	f0 91 ed 08 	lds	r31, 0x08ED
    14e2:	12 8a       	std	Z+18, r1	; 0x12
	SendMsg (&downMsg);
    14e4:	8e ee       	ldi	r24, 0xEE	; 238
    14e6:	98 e0       	ldi	r25, 0x08	; 8
    14e8:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <PDSap>
	setCTS(1);
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	0e 94 cf 09 	call	0x139e	; 0x139e <setCTS>
}
    14f4:	cf 91       	pop	r28
    14f6:	df 91       	pop	r29
    14f8:	08 95       	ret

000014fa <IsAlive>:
 * Hartbeat to indicate a normal running application
 */
/****************************************************************************/
void IsAlive (void)
/****************************************************************************/
{
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	00 d0       	rcall	.+0      	; 0x1500 <IsAlive+0x6>
    1500:	00 d0       	rcall	.+0      	; 0x1502 <IsAlive+0x8>
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
	static	int	flag = 0;
	static	unsigned long	last = 0;
	unsigned long	now;

	now = hwclock();
    1506:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    150a:	dc 01       	movw	r26, r24
    150c:	cb 01       	movw	r24, r22
    150e:	89 83       	std	Y+1, r24	; 0x01
    1510:	9a 83       	std	Y+2, r25	; 0x02
    1512:	ab 83       	std	Y+3, r26	; 0x03
    1514:	bc 83       	std	Y+4, r27	; 0x04
	if(now - last > 500)
    1516:	20 91 91 0b 	lds	r18, 0x0B91
    151a:	30 91 92 0b 	lds	r19, 0x0B92
    151e:	40 91 93 0b 	lds	r20, 0x0B93
    1522:	50 91 94 0b 	lds	r21, 0x0B94
    1526:	89 81       	ldd	r24, Y+1	; 0x01
    1528:	9a 81       	ldd	r25, Y+2	; 0x02
    152a:	ab 81       	ldd	r26, Y+3	; 0x03
    152c:	bc 81       	ldd	r27, Y+4	; 0x04
    152e:	82 1b       	sub	r24, r18
    1530:	93 0b       	sbc	r25, r19
    1532:	a4 0b       	sbc	r26, r20
    1534:	b5 0b       	sbc	r27, r21
    1536:	85 3f       	cpi	r24, 0xF5	; 245
    1538:	21 e0       	ldi	r18, 0x01	; 1
    153a:	92 07       	cpc	r25, r18
    153c:	20 e0       	ldi	r18, 0x00	; 0
    153e:	a2 07       	cpc	r26, r18
    1540:	20 e0       	ldi	r18, 0x00	; 0
    1542:	b2 07       	cpc	r27, r18
    1544:	58 f1       	brcs	.+86     	; 0x159c <IsAlive+0xa2>
	{
		last = now;
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	9a 81       	ldd	r25, Y+2	; 0x02
    154a:	ab 81       	ldd	r26, Y+3	; 0x03
    154c:	bc 81       	ldd	r27, Y+4	; 0x04
    154e:	80 93 91 0b 	sts	0x0B91, r24
    1552:	90 93 92 0b 	sts	0x0B92, r25
    1556:	a0 93 93 0b 	sts	0x0B93, r26
    155a:	b0 93 94 0b 	sts	0x0B94, r27
		if(flag == 0)
    155e:	80 91 95 0b 	lds	r24, 0x0B95
    1562:	90 91 96 0b 	lds	r25, 0x0B96
    1566:	00 97       	sbiw	r24, 0x00	; 0
    1568:	71 f4       	brne	.+28     	; 0x1586 <IsAlive+0x8c>
		{
			flag = 1;
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	90 93 96 0b 	sts	0x0B96, r25
    1572:	80 93 95 0b 	sts	0x0B95, r24
			LED_ALIVE (LED_ON);
    1576:	a8 e2       	ldi	r26, 0x28	; 40
    1578:	b0 e0       	ldi	r27, 0x00	; 0
    157a:	e8 e2       	ldi	r30, 0x28	; 40
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	80 81       	ld	r24, Z
    1580:	8d 7f       	andi	r24, 0xFD	; 253
    1582:	8c 93       	st	X, r24
    1584:	0b c0       	rjmp	.+22     	; 0x159c <IsAlive+0xa2>
		}
		else
		{
			flag = 0;
    1586:	10 92 96 0b 	sts	0x0B96, r1
    158a:	10 92 95 0b 	sts	0x0B95, r1
			LED_ALIVE (LED_OFF);
    158e:	a8 e2       	ldi	r26, 0x28	; 40
    1590:	b0 e0       	ldi	r27, 0x00	; 0
    1592:	e8 e2       	ldi	r30, 0x28	; 40
    1594:	f0 e0       	ldi	r31, 0x00	; 0
    1596:	80 81       	ld	r24, Z
    1598:	82 60       	ori	r24, 0x02	; 2
    159a:	8c 93       	st	X, r24
		}
	}
}
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	0f 90       	pop	r0
    15a2:	0f 90       	pop	r0
    15a4:	cf 91       	pop	r28
    15a6:	df 91       	pop	r29
    15a8:	08 95       	ret

000015aa <APLPoll>:
 * the serial interface
 */
/***************************************************************************/
void APLPoll (void)
/***************************************************************************/
{
    15aa:	ef 92       	push	r14
    15ac:	ff 92       	push	r15
    15ae:	0f 93       	push	r16
    15b0:	1f 93       	push	r17
    15b2:	df 93       	push	r29
    15b4:	cf 93       	push	r28
    15b6:	cd b7       	in	r28, 0x3d	; 61
    15b8:	de b7       	in	r29, 0x3e	; 62
    15ba:	60 97       	sbiw	r28, 0x10	; 16
    15bc:	0f b6       	in	r0, 0x3f	; 63
    15be:	f8 94       	cli
    15c0:	de bf       	out	0x3e, r29	; 62
    15c2:	0f be       	out	0x3f, r0	; 63
    15c4:	cd bf       	out	0x3d, r28	; 61
        static Sf_packet pkt;

	MyInt16T c;

	static MyByte8T packets_sent = 0xFF;
	MyByte8T power = 0;
    15c6:	19 82       	std	Y+1, r1	; 0x01

	//int i, j;

#	ifdef CONFIG_ALIVE_LED
	IsAlive ();
    15c8:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <IsAlive>
	//	apl->hwclock = hwclock();
	//	puts("alive");
	//}
	

        if (apl->mode == talk_to_ARM)
    15cc:	e0 91 ec 08 	lds	r30, 0x08EC
    15d0:	f0 91 ed 08 	lds	r31, 0x08ED
    15d4:	80 89       	ldd	r24, Z+16	; 0x10
    15d6:	86 30       	cpi	r24, 0x06	; 6
    15d8:	09 f0       	breq	.+2      	; 0x15dc <APLPoll+0x32>
    15da:	e1 c5       	rjmp	.+3010   	; 0x219e <APLPoll+0xbf4>
	{
            if (apl->help == 0) {
    15dc:	e0 91 ec 08 	lds	r30, 0x08EC
    15e0:	f0 91 ed 08 	lds	r31, 0x08ED
    15e4:	81 89       	ldd	r24, Z+17	; 0x11
    15e6:	88 23       	and	r24, r24
    15e8:	79 f5       	brne	.+94     	; 0x1648 <APLPoll+0x9e>
	    	sprintf(apl->outpkt.params, "rdy");
    15ea:	80 91 ec 08 	lds	r24, 0x08EC
    15ee:	90 91 ed 08 	lds	r25, 0x08ED
    15f2:	82 96       	adiw	r24, 0x22	; 34
    15f4:	22 ec       	ldi	r18, 0xC2	; 194
    15f6:	31 e0       	ldi	r19, 0x01	; 1
    15f8:	b9 01       	movw	r22, r18
    15fa:	44 e0       	ldi	r20, 0x04	; 4
    15fc:	50 e0       	ldi	r21, 0x00	; 0
    15fe:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, Sf_packet_unsolicited_msg_tag);
    1602:	80 91 ec 08 	lds	r24, 0x08EC
    1606:	90 91 ed 08 	lds	r25, 0x08ED
    160a:	8c 01       	movw	r16, r24
    160c:	0e 5d       	subi	r16, 0xDE	; 222
    160e:	1f 4f       	sbci	r17, 0xFF	; 255
    1610:	80 91 ec 08 	lds	r24, 0x08EC
    1614:	90 91 ed 08 	lds	r25, 0x08ED
    1618:	82 96       	adiw	r24, 0x22	; 34
    161a:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    161e:	01 96       	adiw	r24, 0x01	; 1
    1620:	9c 01       	movw	r18, r24
    1622:	c8 01       	movw	r24, r16
    1624:	b9 01       	movw	r22, r18
    1626:	41 e0       	ldi	r20, 0x01	; 1
    1628:	2f ef       	ldi	r18, 0xFF	; 255
    162a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
		CTS_PORT |= CTS_PIN;
    162e:	a2 e2       	ldi	r26, 0x22	; 34
    1630:	b0 e0       	ldi	r27, 0x00	; 0
    1632:	e2 e2       	ldi	r30, 0x22	; 34
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	80 81       	ld	r24, Z
    1638:	80 62       	ori	r24, 0x20	; 32
    163a:	8c 93       	st	X, r24
		apl->help = 1;
    163c:	e0 91 ec 08 	lds	r30, 0x08EC
    1640:	f0 91 ed 08 	lds	r31, 0x08ED
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	81 8b       	std	Z+17, r24	; 0x11
            }
            Read_sf_status read_oper = readSfPacket(&pkt);
    1648:	87 e9       	ldi	r24, 0x97	; 151
    164a:	9b e0       	ldi	r25, 0x0B	; 11
    164c:	0e 94 47 19 	call	0x328e	; 0x328e <readSfPacket>
    1650:	6f 83       	std	Y+7, r22	; 0x07
    1652:	78 87       	std	Y+8, r23	; 0x08
    1654:	89 87       	std	Y+9, r24	; 0x09
    1656:	9e 01       	movw	r18, r28
    1658:	2c 5f       	subi	r18, 0xFC	; 252
    165a:	3f 4f       	sbci	r19, 0xFF	; 255
    165c:	3d 87       	std	Y+13, r19	; 0x0d
    165e:	2c 87       	std	Y+12, r18	; 0x0c
    1660:	ce 01       	movw	r24, r28
    1662:	07 96       	adiw	r24, 0x07	; 7
    1664:	9f 87       	std	Y+15, r25	; 0x0f
    1666:	8e 87       	std	Y+14, r24	; 0x0e
    1668:	93 e0       	ldi	r25, 0x03	; 3
    166a:	98 8b       	std	Y+16, r25	; 0x10
    166c:	ee 85       	ldd	r30, Y+14	; 0x0e
    166e:	ff 85       	ldd	r31, Y+15	; 0x0f
    1670:	00 80       	ld	r0, Z
    1672:	2e 85       	ldd	r18, Y+14	; 0x0e
    1674:	3f 85       	ldd	r19, Y+15	; 0x0f
    1676:	2f 5f       	subi	r18, 0xFF	; 255
    1678:	3f 4f       	sbci	r19, 0xFF	; 255
    167a:	3f 87       	std	Y+15, r19	; 0x0f
    167c:	2e 87       	std	Y+14, r18	; 0x0e
    167e:	ec 85       	ldd	r30, Y+12	; 0x0c
    1680:	fd 85       	ldd	r31, Y+13	; 0x0d
    1682:	00 82       	st	Z, r0
    1684:	2c 85       	ldd	r18, Y+12	; 0x0c
    1686:	3d 85       	ldd	r19, Y+13	; 0x0d
    1688:	2f 5f       	subi	r18, 0xFF	; 255
    168a:	3f 4f       	sbci	r19, 0xFF	; 255
    168c:	3d 87       	std	Y+13, r19	; 0x0d
    168e:	2c 87       	std	Y+12, r18	; 0x0c
    1690:	38 89       	ldd	r19, Y+16	; 0x10
    1692:	31 50       	subi	r19, 0x01	; 1
    1694:	38 8b       	std	Y+16, r19	; 0x10
    1696:	88 89       	ldd	r24, Y+16	; 0x10
    1698:	88 23       	and	r24, r24
    169a:	41 f7       	brne	.-48     	; 0x166c <APLPoll+0xc2>
            switch(read_oper.state) {
    169c:	8c 81       	ldd	r24, Y+4	; 0x04
    169e:	e8 2f       	mov	r30, r24
    16a0:	f0 e0       	ldi	r31, 0x00	; 0
    16a2:	fb 87       	std	Y+11, r31	; 0x0b
    16a4:	ea 87       	std	Y+10, r30	; 0x0a
    16a6:	2a 85       	ldd	r18, Y+10	; 0x0a
    16a8:	3b 85       	ldd	r19, Y+11	; 0x0b
    16aa:	22 30       	cpi	r18, 0x02	; 2
    16ac:	31 05       	cpc	r19, r1
    16ae:	11 f4       	brne	.+4      	; 0x16b4 <APLPoll+0x10a>
    16b0:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
    16b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    16b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    16b8:	83 30       	cpi	r24, 0x03	; 3
    16ba:	91 05       	cpc	r25, r1
    16bc:	64 f4       	brge	.+24     	; 0x16d6 <APLPoll+0x12c>
    16be:	ea 85       	ldd	r30, Y+10	; 0x0a
    16c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    16c2:	30 97       	sbiw	r30, 0x00	; 0
    16c4:	d9 f0       	breq	.+54     	; 0x16fc <APLPoll+0x152>
    16c6:	2a 85       	ldd	r18, Y+10	; 0x0a
    16c8:	3b 85       	ldd	r19, Y+11	; 0x0b
    16ca:	21 30       	cpi	r18, 0x01	; 1
    16cc:	31 05       	cpc	r19, r1
    16ce:	11 f4       	brne	.+4      	; 0x16d4 <APLPoll+0x12a>
    16d0:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
    16d4:	87 c0       	rjmp	.+270    	; 0x17e4 <APLPoll+0x23a>
    16d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    16d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    16da:	84 30       	cpi	r24, 0x04	; 4
    16dc:	91 05       	cpc	r25, r1
    16de:	09 f4       	brne	.+2      	; 0x16e2 <APLPoll+0x138>
    16e0:	6b c0       	rjmp	.+214    	; 0x17b8 <APLPoll+0x20e>
    16e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    16e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    16e6:	e4 30       	cpi	r30, 0x04	; 4
    16e8:	f1 05       	cpc	r31, r1
    16ea:	0c f4       	brge	.+2      	; 0x16ee <APLPoll+0x144>
    16ec:	56 c0       	rjmp	.+172    	; 0x179a <APLPoll+0x1f0>
    16ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    16f0:	3b 85       	ldd	r19, Y+11	; 0x0b
    16f2:	25 30       	cpi	r18, 0x05	; 5
    16f4:	31 05       	cpc	r19, r1
    16f6:	09 f4       	brne	.+2      	; 0x16fa <APLPoll+0x150>
    16f8:	6a c0       	rjmp	.+212    	; 0x17ce <APLPoll+0x224>
    16fa:	74 c0       	rjmp	.+232    	; 0x17e4 <APLPoll+0x23a>
                case no_packet: // here's where we send unsolicited messages
                    //printf("no_packet, nbytes = %d\n", read_oper.nbytes);  //enable only on verbose debug
		    if ( apl->ranging_info_available_flag ) {
    16fc:	80 91 ec 08 	lds	r24, 0x08EC
    1700:	90 91 ed 08 	lds	r25, 0x08ED
    1704:	fc 01       	movw	r30, r24
    1706:	ee 5d       	subi	r30, 0xDE	; 222
    1708:	fe 4f       	sbci	r31, 0xFE	; 254
    170a:	80 81       	ld	r24, Z
    170c:	91 81       	ldd	r25, Z+1	; 0x01
    170e:	00 97       	sbiw	r24, 0x00	; 0
    1710:	89 f0       	breq	.+34     	; 0x1734 <APLPoll+0x18a>
			sendToARM (ranging_info_buffer.params, 4, incomming_range_indication, Sf_packet_unsolicited_msg_tag); // 4 is the sizeof a RangingPIB.distance element
    1712:	8e e8       	ldi	r24, 0x8E	; 142
    1714:	99 e0       	ldi	r25, 0x09	; 9
    1716:	64 e0       	ldi	r22, 0x04	; 4
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	40 e1       	ldi	r20, 0x10	; 16
    171c:	2f ef       	ldi	r18, 0xFF	; 255
    171e:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
			 // sendToARM (ranging_info_buffer.params, 4 + strlen(ranging_info_buffer.params+4) + 1, incomming_range_indication, Sf_packet_unsolicited_msg_tag); //  This line was used when we were appending the ascii representation of the distance to the binary representation of the distance in the packet sent to the ARM, for debugging purposes. We add 4 to some pointers here because 4 bytes is the length of a RangingPIB.distance element.
			apl->ranging_info_available_flag = 0;
    1722:	80 91 ec 08 	lds	r24, 0x08EC
    1726:	90 91 ed 08 	lds	r25, 0x08ED
    172a:	fc 01       	movw	r30, r24
    172c:	ee 5d       	subi	r30, 0xDE	; 222
    172e:	fe 4f       	sbci	r31, 0xFE	; 254
    1730:	11 82       	std	Z+1, r1	; 0x01
    1732:	10 82       	st	Z, r1
		    } 
		    if ( apl->inbound_packet_available_flag ) {
    1734:	80 91 ec 08 	lds	r24, 0x08EC
    1738:	90 91 ed 08 	lds	r25, 0x08ED
    173c:	fc 01       	movw	r30, r24
    173e:	e0 5e       	subi	r30, 0xE0	; 224
    1740:	fe 4f       	sbci	r31, 0xFE	; 254
    1742:	80 81       	ld	r24, Z
    1744:	91 81       	ldd	r25, Z+1	; 0x01
    1746:	00 97       	sbiw	r24, 0x00	; 0
    1748:	11 f4       	brne	.+4      	; 0x174e <APLPoll+0x1a4>
    174a:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
		    	if ( incomming_data_but_source_changed == inpkt.type ) 
    174e:	80 91 8c 0a 	lds	r24, 0x0A8C
    1752:	81 31       	cpi	r24, 0x11	; 17
    1754:	61 f4       	brne	.+24     	; 0x176e <APLPoll+0x1c4>
		    		sendToARM (inpkt.params, inpkt.size, incomming_data_but_source_changed, Sf_packet_unsolicited_msg_tag);
    1756:	80 91 8b 0a 	lds	r24, 0x0A8B
    175a:	28 2f       	mov	r18, r24
    175c:	30 e0       	ldi	r19, 0x00	; 0
    175e:	8e e8       	ldi	r24, 0x8E	; 142
    1760:	9a e0       	ldi	r25, 0x0A	; 10
    1762:	b9 01       	movw	r22, r18
    1764:	41 e1       	ldi	r20, 0x11	; 17
    1766:	2f ef       	ldi	r18, 0xFF	; 255
    1768:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    176c:	0b c0       	rjmp	.+22     	; 0x1784 <APLPoll+0x1da>
			else
				sendToARM (inpkt.params, inpkt.size, incomming_data, Sf_packet_unsolicited_msg_tag);
    176e:	80 91 8b 0a 	lds	r24, 0x0A8B
    1772:	28 2f       	mov	r18, r24
    1774:	30 e0       	ldi	r19, 0x00	; 0
    1776:	8e e8       	ldi	r24, 0x8E	; 142
    1778:	9a e0       	ldi	r25, 0x0A	; 10
    177a:	b9 01       	movw	r22, r18
    177c:	4f e0       	ldi	r20, 0x0F	; 15
    177e:	2f ef       	ldi	r18, 0xFF	; 255
    1780:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
			apl->inbound_packet_available_flag = 0;
    1784:	80 91 ec 08 	lds	r24, 0x08EC
    1788:	90 91 ed 08 	lds	r25, 0x08ED
    178c:	fc 01       	movw	r30, r24
    178e:	e0 5e       	subi	r30, 0xE0	; 224
    1790:	fe 4f       	sbci	r31, 0xFE	; 254
    1792:	11 82       	std	Z+1, r1	; 0x01
    1794:	10 82       	st	Z, r1
    1796:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
                case receiving_packet:
                    //printf("receiving packet, nbytes = %d\n", read_oper.nbytes); //enable only on verbose debug
                    return;
		    break;
                case packet_received:
                    network_stats.packets_received++;
    179a:	80 91 e7 0c 	lds	r24, 0x0CE7
    179e:	90 91 e8 0c 	lds	r25, 0x0CE8
    17a2:	01 96       	adiw	r24, 0x01	; 1
    17a4:	90 93 e8 0c 	sts	0x0CE8, r25
    17a8:	80 93 e7 0c 	sts	0x0CE7, r24
		    break;
            }

	    
            /* select the command requested by the ARM and execute it */
            if (no_op != pkt.type)  
    17ac:	80 91 99 0b 	lds	r24, 0x0B99
    17b0:	88 23       	and	r24, r24
    17b2:	b9 f5       	brne	.+110    	; 0x1822 <APLPoll+0x278>
    17b4:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
                case packet_received:
                    network_stats.packets_received++;
                    //printf("packet received, size=%d, type=%d, tag=%d, nbytes=%d payload:%s.\n", pkt.size, pkt.type, pkt.tag, read_oper.nbytes, &pkt.params[0]); //enable on debug
                    break;
                case malformed_packet:
                    network_stats.malformed_packets++;
    17b8:	80 91 e9 0c 	lds	r24, 0x0CE9
    17bc:	90 91 ea 0c 	lds	r25, 0x0CEA
    17c0:	01 96       	adiw	r24, 0x01	; 1
    17c2:	90 93 ea 0c 	sts	0x0CEA, r25
    17c6:	80 93 e9 0c 	sts	0x0CE9, r24
    17ca:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
                    //printf("malformed packet, nbytes = %d\n", read_oper.nbytes); //enable on debug
                    return;
		    break;
                case packet_timed_out:
                    network_stats.packets_timed_out++;
    17ce:	80 91 eb 0c 	lds	r24, 0x0CEB
    17d2:	90 91 ec 0c 	lds	r25, 0x0CEC
    17d6:	01 96       	adiw	r24, 0x01	; 1
    17d8:	90 93 ec 0c 	sts	0x0CEC, r25
    17dc:	80 93 eb 0c 	sts	0x0CEB, r24
    17e0:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>
		    //printf("Packet timed out, nbytes = %d\n", read_oper.nbytes); //enable on debug
		    return;
		    break;
                default:
                    printf("invalid status %d,%d\n", read_oper.state, read_oper.nbytes);
    17e4:	8c 81       	ldd	r24, Y+4	; 0x04
    17e6:	28 2f       	mov	r18, r24
    17e8:	30 e0       	ldi	r19, 0x00	; 0
    17ea:	4d 81       	ldd	r20, Y+5	; 0x05
    17ec:	5e 81       	ldd	r21, Y+6	; 0x06
    17ee:	00 d0       	rcall	.+0      	; 0x17f0 <APLPoll+0x246>
    17f0:	00 d0       	rcall	.+0      	; 0x17f2 <APLPoll+0x248>
    17f2:	00 d0       	rcall	.+0      	; 0x17f4 <APLPoll+0x24a>
    17f4:	ed b7       	in	r30, 0x3d	; 61
    17f6:	fe b7       	in	r31, 0x3e	; 62
    17f8:	31 96       	adiw	r30, 0x01	; 1
    17fa:	86 ec       	ldi	r24, 0xC6	; 198
    17fc:	91 e0       	ldi	r25, 0x01	; 1
    17fe:	91 83       	std	Z+1, r25	; 0x01
    1800:	80 83       	st	Z, r24
    1802:	33 83       	std	Z+3, r19	; 0x03
    1804:	22 83       	std	Z+2, r18	; 0x02
    1806:	55 83       	std	Z+5, r21	; 0x05
    1808:	44 83       	std	Z+4, r20	; 0x04
    180a:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    180e:	8d b7       	in	r24, 0x3d	; 61
    1810:	9e b7       	in	r25, 0x3e	; 62
    1812:	06 96       	adiw	r24, 0x06	; 6
    1814:	0f b6       	in	r0, 0x3f	; 63
    1816:	f8 94       	cli
    1818:	9e bf       	out	0x3e, r25	; 62
    181a:	0f be       	out	0x3f, r0	; 63
    181c:	8d bf       	out	0x3d, r24	; 61
    181e:	0c 94 f6 15 	jmp	0x2bec	; 0x2bec <APLPoll+0x1642>

	    
            /* select the command requested by the ARM and execute it */
            if (no_op != pkt.type)  
            {
		    if (goto_send_mode == pkt.type) { //parameters: integer (ascii)   (number of bytes to be transmitted)
    1822:	80 91 99 0b 	lds	r24, 0x0B99
    1826:	8e 30       	cpi	r24, 0x0E	; 14
    1828:	09 f0       	breq	.+2      	; 0x182c <APLPoll+0x282>
    182a:	4a c0       	rjmp	.+148    	; 0x18c0 <APLPoll+0x316>
			apl->remaining_bytes_to_be_sent = atoi(pkt.params);
    182c:	00 91 ec 08 	lds	r16, 0x08EC
    1830:	10 91 ed 08 	lds	r17, 0x08ED
    1834:	8b e9       	ldi	r24, 0x9B	; 155
    1836:	9b e0       	ldi	r25, 0x0B	; 11
    1838:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    183c:	f8 01       	movw	r30, r16
    183e:	e2 5e       	subi	r30, 0xE2	; 226
    1840:	fe 4f       	sbci	r31, 0xFE	; 254
    1842:	91 83       	std	Z+1, r25	; 0x01
    1844:	80 83       	st	Z, r24
			apl->len = 0;
    1846:	e0 91 ec 08 	lds	r30, 0x08EC
    184a:	f0 91 ed 08 	lds	r31, 0x08ED
    184e:	12 8a       	std	Z+18, r1	; 0x12
			sprintf (apl->outpkt.params, "ok send");
    1850:	80 91 ec 08 	lds	r24, 0x08EC
    1854:	90 91 ed 08 	lds	r25, 0x08ED
    1858:	82 96       	adiw	r24, 0x22	; 34
    185a:	2c ed       	ldi	r18, 0xDC	; 220
    185c:	31 e0       	ldi	r19, 0x01	; 1
    185e:	b9 01       	movw	r22, r18
    1860:	48 e0       	ldi	r20, 0x08	; 8
    1862:	50 e0       	ldi	r21, 0x00	; 0
    1864:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		        sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1868:	80 91 ec 08 	lds	r24, 0x08EC
    186c:	90 91 ed 08 	lds	r25, 0x08ED
    1870:	8c 01       	movw	r16, r24
    1872:	0e 5d       	subi	r16, 0xDE	; 222
    1874:	1f 4f       	sbci	r17, 0xFF	; 255
    1876:	80 91 ec 08 	lds	r24, 0x08EC
    187a:	90 91 ed 08 	lds	r25, 0x08ED
    187e:	82 96       	adiw	r24, 0x22	; 34
    1880:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1884:	01 96       	adiw	r24, 0x01	; 1
    1886:	9c 01       	movw	r18, r24
    1888:	50 91 9a 0b 	lds	r21, 0x0B9A
    188c:	c8 01       	movw	r24, r16
    188e:	b9 01       	movw	r22, r18
    1890:	41 e0       	ldi	r20, 0x01	; 1
    1892:	25 2f       	mov	r18, r21
    1894:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
			if (0 < apl->remaining_bytes_to_be_sent)
    1898:	80 91 ec 08 	lds	r24, 0x08EC
    189c:	90 91 ed 08 	lds	r25, 0x08ED
    18a0:	fc 01       	movw	r30, r24
    18a2:	e2 5e       	subi	r30, 0xE2	; 226
    18a4:	fe 4f       	sbci	r31, 0xFE	; 254
    18a6:	80 81       	ld	r24, Z
    18a8:	91 81       	ldd	r25, Z+1	; 0x01
    18aa:	18 16       	cp	r1, r24
    18ac:	19 06       	cpc	r1, r25
    18ae:	0c f0       	brlt	.+2      	; 0x18b2 <APLPoll+0x308>
    18b0:	73 c4       	rjmp	.+2278   	; 0x2198 <APLPoll+0xbee>
			   apl->mode = send_incoming_chars;
    18b2:	e0 91 ec 08 	lds	r30, 0x08EC
    18b6:	f0 91 ed 08 	lds	r31, 0x08ED
    18ba:	87 e0       	ldi	r24, 0x07	; 7
    18bc:	80 8b       	std	Z+16, r24	; 0x10
    18be:	6c c4       	rjmp	.+2264   	; 0x2198 <APLPoll+0xbee>
		    }
                    else if (set_src_mac_address == pkt.type)  //parameters:  integer (ascii)   (our new mac address)
    18c0:	80 91 99 0b 	lds	r24, 0x0B99
    18c4:	84 30       	cpi	r24, 0x04	; 4
    18c6:	09 f0       	breq	.+2      	; 0x18ca <APLPoll+0x320>
    18c8:	5b c0       	rjmp	.+182    	; 0x1980 <APLPoll+0x3d6>
                    {
                            apl->src[5] = atoi (pkt.params);
    18ca:	00 91 ec 08 	lds	r16, 0x08EC
    18ce:	10 91 ed 08 	lds	r17, 0x08ED
    18d2:	8b e9       	ldi	r24, 0x9B	; 155
    18d4:	9b e0       	ldi	r25, 0x0B	; 11
    18d6:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    18da:	f8 01       	movw	r30, r16
    18dc:	87 87       	std	Z+15, r24	; 0x0f
                            // NTRXSetStaAddress (app->src);
                            downMsg.prim = PLME_SET_REQUEST;
    18de:	8b e0       	ldi	r24, 0x0B	; 11
    18e0:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_MAC_ADDRESS1;
    18e4:	83 e7       	ldi	r24, 0x73	; 115
    18e6:	80 93 79 09 	sts	0x0979, r24
                            memcpy (downMsg.data, apl->src, 6);
    18ea:	80 91 ec 08 	lds	r24, 0x08EC
    18ee:	90 91 ed 08 	lds	r25, 0x08ED
    18f2:	9c 01       	movw	r18, r24
    18f4:	26 5f       	subi	r18, 0xF6	; 246
    18f6:	3f 4f       	sbci	r19, 0xFF	; 255
    18f8:	86 ef       	ldi	r24, 0xF6	; 246
    18fa:	98 e0       	ldi	r25, 0x08	; 8
    18fc:	b9 01       	movw	r22, r18
    18fe:	46 e0       	ldi	r20, 0x06	; 6
    1900:	50 e0       	ldi	r21, 0x00	; 0
    1902:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
                            PLMESap (&downMsg);
    1906:	8e ee       	ldi	r24, 0xEE	; 238
    1908:	98 e0       	ldi	r25, 0x08	; 8
    190a:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
			    sprintf (apl->outpkt.params, "src %s", pkt.params);
    190e:	80 91 ec 08 	lds	r24, 0x08EC
    1912:	90 91 ed 08 	lds	r25, 0x08ED
    1916:	82 96       	adiw	r24, 0x22	; 34
    1918:	00 d0       	rcall	.+0      	; 0x191a <APLPoll+0x370>
    191a:	00 d0       	rcall	.+0      	; 0x191c <APLPoll+0x372>
    191c:	00 d0       	rcall	.+0      	; 0x191e <APLPoll+0x374>
    191e:	ed b7       	in	r30, 0x3d	; 61
    1920:	fe b7       	in	r31, 0x3e	; 62
    1922:	31 96       	adiw	r30, 0x01	; 1
    1924:	91 83       	std	Z+1, r25	; 0x01
    1926:	80 83       	st	Z, r24
    1928:	84 ee       	ldi	r24, 0xE4	; 228
    192a:	91 e0       	ldi	r25, 0x01	; 1
    192c:	93 83       	std	Z+3, r25	; 0x03
    192e:	82 83       	std	Z+2, r24	; 0x02
    1930:	8b e9       	ldi	r24, 0x9B	; 155
    1932:	9b e0       	ldi	r25, 0x0B	; 11
    1934:	95 83       	std	Z+5, r25	; 0x05
    1936:	84 83       	std	Z+4, r24	; 0x04
    1938:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    193c:	2d b7       	in	r18, 0x3d	; 61
    193e:	3e b7       	in	r19, 0x3e	; 62
    1940:	2a 5f       	subi	r18, 0xFA	; 250
    1942:	3f 4f       	sbci	r19, 0xFF	; 255
    1944:	0f b6       	in	r0, 0x3f	; 63
    1946:	f8 94       	cli
    1948:	3e bf       	out	0x3e, r19	; 62
    194a:	0f be       	out	0x3f, r0	; 63
    194c:	2d bf       	out	0x3d, r18	; 61
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    194e:	80 91 ec 08 	lds	r24, 0x08EC
    1952:	90 91 ed 08 	lds	r25, 0x08ED
    1956:	8c 01       	movw	r16, r24
    1958:	0e 5d       	subi	r16, 0xDE	; 222
    195a:	1f 4f       	sbci	r17, 0xFF	; 255
    195c:	80 91 ec 08 	lds	r24, 0x08EC
    1960:	90 91 ed 08 	lds	r25, 0x08ED
    1964:	82 96       	adiw	r24, 0x22	; 34
    1966:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    196a:	01 96       	adiw	r24, 0x01	; 1
    196c:	9c 01       	movw	r18, r24
    196e:	50 91 9a 0b 	lds	r21, 0x0B9A
    1972:	c8 01       	movw	r24, r16
    1974:	b9 01       	movw	r22, r18
    1976:	41 e0       	ldi	r20, 0x01	; 1
    1978:	25 2f       	mov	r18, r21
    197a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    197e:	0c c4       	rjmp	.+2072   	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (set_dest_mac_address == pkt.type)  //parameters:  integer (ascii)  (sets  destination mac address for outbound packets)
    1980:	80 91 99 0b 	lds	r24, 0x0B99
    1984:	85 30       	cpi	r24, 0x05	; 5
    1986:	09 f0       	breq	.+2      	; 0x198a <APLPoll+0x3e0>
    1988:	43 c0       	rjmp	.+134    	; 0x1a10 <APLPoll+0x466>
                    {
                            apl->dest[5] = atoi (pkt.params);
    198a:	00 91 ec 08 	lds	r16, 0x08EC
    198e:	10 91 ed 08 	lds	r17, 0x08ED
    1992:	8b e9       	ldi	r24, 0x9B	; 155
    1994:	9b e0       	ldi	r25, 0x0B	; 11
    1996:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    199a:	f8 01       	movw	r30, r16
    199c:	81 87       	std	Z+9, r24	; 0x09
			    sprintf (apl->outpkt.params, "dest %s", pkt.params);
    199e:	80 91 ec 08 	lds	r24, 0x08EC
    19a2:	90 91 ed 08 	lds	r25, 0x08ED
    19a6:	82 96       	adiw	r24, 0x22	; 34
    19a8:	00 d0       	rcall	.+0      	; 0x19aa <APLPoll+0x400>
    19aa:	00 d0       	rcall	.+0      	; 0x19ac <APLPoll+0x402>
    19ac:	00 d0       	rcall	.+0      	; 0x19ae <APLPoll+0x404>
    19ae:	ed b7       	in	r30, 0x3d	; 61
    19b0:	fe b7       	in	r31, 0x3e	; 62
    19b2:	31 96       	adiw	r30, 0x01	; 1
    19b4:	91 83       	std	Z+1, r25	; 0x01
    19b6:	80 83       	st	Z, r24
    19b8:	8b ee       	ldi	r24, 0xEB	; 235
    19ba:	91 e0       	ldi	r25, 0x01	; 1
    19bc:	93 83       	std	Z+3, r25	; 0x03
    19be:	82 83       	std	Z+2, r24	; 0x02
    19c0:	8b e9       	ldi	r24, 0x9B	; 155
    19c2:	9b e0       	ldi	r25, 0x0B	; 11
    19c4:	95 83       	std	Z+5, r25	; 0x05
    19c6:	84 83       	std	Z+4, r24	; 0x04
    19c8:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    19cc:	2d b7       	in	r18, 0x3d	; 61
    19ce:	3e b7       	in	r19, 0x3e	; 62
    19d0:	2a 5f       	subi	r18, 0xFA	; 250
    19d2:	3f 4f       	sbci	r19, 0xFF	; 255
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	3e bf       	out	0x3e, r19	; 62
    19da:	0f be       	out	0x3f, r0	; 63
    19dc:	2d bf       	out	0x3d, r18	; 61
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    19de:	80 91 ec 08 	lds	r24, 0x08EC
    19e2:	90 91 ed 08 	lds	r25, 0x08ED
    19e6:	8c 01       	movw	r16, r24
    19e8:	0e 5d       	subi	r16, 0xDE	; 222
    19ea:	1f 4f       	sbci	r17, 0xFF	; 255
    19ec:	80 91 ec 08 	lds	r24, 0x08EC
    19f0:	90 91 ed 08 	lds	r25, 0x08ED
    19f4:	82 96       	adiw	r24, 0x22	; 34
    19f6:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    19fa:	01 96       	adiw	r24, 0x01	; 1
    19fc:	9c 01       	movw	r18, r24
    19fe:	50 91 9a 0b 	lds	r21, 0x0B9A
    1a02:	c8 01       	movw	r24, r16
    1a04:	b9 01       	movw	r22, r18
    1a06:	41 e0       	ldi	r20, 0x01	; 1
    1a08:	25 2f       	mov	r18, r21
    1a0a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1a0e:	c4 c3       	rjmp	.+1928   	; 0x2198 <APLPoll+0xbee>

                    }
                    else if (set_channel == pkt.type) //parameters:  integer (ascii)   (sets channel)
    1a10:	80 91 99 0b 	lds	r24, 0x0B99
    1a14:	88 30       	cpi	r24, 0x08	; 8
    1a16:	09 f0       	breq	.+2      	; 0x1a1a <APLPoll+0x470>
    1a18:	88 c0       	rjmp	.+272    	; 0x1b2a <APLPoll+0x580>
                    {
                            downMsg.value = (MyByte8T)(atoi (pkt.params));
    1a1a:	8b e9       	ldi	r24, 0x9B	; 155
    1a1c:	9b e0       	ldi	r25, 0x0B	; 11
    1a1e:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    1a22:	88 2f       	mov	r24, r24
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	90 93 78 09 	sts	0x0978, r25
    1a2a:	80 93 77 09 	sts	0x0977, r24
                            downMsg.prim = PLME_SET_REQUEST;
    1a2e:	8b e0       	ldi	r24, 0x0B	; 11
    1a30:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_LOG_CHANNEL;
    1a34:	8f e7       	ldi	r24, 0x7F	; 127
    1a36:	80 93 79 09 	sts	0x0979, r24
                            PLMESap (&downMsg);
    1a3a:	8e ee       	ldi	r24, 0xEE	; 238
    1a3c:	98 e0       	ldi	r25, 0x08	; 8
    1a3e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
                            if (downMsg.status == PHY_SUCCESS)
    1a42:	80 91 76 09 	lds	r24, 0x0976
    1a46:	87 30       	cpi	r24, 0x07	; 7
    1a48:	c1 f5       	brne	.+112    	; 0x1aba <APLPoll+0x510>
                            {
                                   sprintf (apl->outpkt.params, "channel %s", pkt.params);
    1a4a:	80 91 ec 08 	lds	r24, 0x08EC
    1a4e:	90 91 ed 08 	lds	r25, 0x08ED
    1a52:	82 96       	adiw	r24, 0x22	; 34
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <APLPoll+0x4ac>
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <APLPoll+0x4ae>
    1a58:	00 d0       	rcall	.+0      	; 0x1a5a <APLPoll+0x4b0>
    1a5a:	ed b7       	in	r30, 0x3d	; 61
    1a5c:	fe b7       	in	r31, 0x3e	; 62
    1a5e:	31 96       	adiw	r30, 0x01	; 1
    1a60:	91 83       	std	Z+1, r25	; 0x01
    1a62:	80 83       	st	Z, r24
    1a64:	83 ef       	ldi	r24, 0xF3	; 243
    1a66:	91 e0       	ldi	r25, 0x01	; 1
    1a68:	93 83       	std	Z+3, r25	; 0x03
    1a6a:	82 83       	std	Z+2, r24	; 0x02
    1a6c:	8b e9       	ldi	r24, 0x9B	; 155
    1a6e:	9b e0       	ldi	r25, 0x0B	; 11
    1a70:	95 83       	std	Z+5, r25	; 0x05
    1a72:	84 83       	std	Z+4, r24	; 0x04
    1a74:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1a78:	8d b7       	in	r24, 0x3d	; 61
    1a7a:	9e b7       	in	r25, 0x3e	; 62
    1a7c:	06 96       	adiw	r24, 0x06	; 6
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	9e bf       	out	0x3e, r25	; 62
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	8d bf       	out	0x3d, r24	; 61
		            	   sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1a88:	80 91 ec 08 	lds	r24, 0x08EC
    1a8c:	90 91 ed 08 	lds	r25, 0x08ED
    1a90:	8c 01       	movw	r16, r24
    1a92:	0e 5d       	subi	r16, 0xDE	; 222
    1a94:	1f 4f       	sbci	r17, 0xFF	; 255
    1a96:	80 91 ec 08 	lds	r24, 0x08EC
    1a9a:	90 91 ed 08 	lds	r25, 0x08ED
    1a9e:	82 96       	adiw	r24, 0x22	; 34
    1aa0:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1aa4:	01 96       	adiw	r24, 0x01	; 1
    1aa6:	9c 01       	movw	r18, r24
    1aa8:	50 91 9a 0b 	lds	r21, 0x0B9A
    1aac:	c8 01       	movw	r24, r16
    1aae:	b9 01       	movw	r22, r18
    1ab0:	41 e0       	ldi	r20, 0x01	; 1
    1ab2:	25 2f       	mov	r18, r21
    1ab4:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1ab8:	6f c3       	rjmp	.+1758   	; 0x2198 <APLPoll+0xbee>
                            }
                            else
                            {
				   sprintf (apl->outpkt.params, "Error: illegal channel: %s", pkt.params);
    1aba:	80 91 ec 08 	lds	r24, 0x08EC
    1abe:	90 91 ed 08 	lds	r25, 0x08ED
    1ac2:	82 96       	adiw	r24, 0x22	; 34
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <APLPoll+0x51c>
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <APLPoll+0x51e>
    1ac8:	00 d0       	rcall	.+0      	; 0x1aca <APLPoll+0x520>
    1aca:	ed b7       	in	r30, 0x3d	; 61
    1acc:	fe b7       	in	r31, 0x3e	; 62
    1ace:	31 96       	adiw	r30, 0x01	; 1
    1ad0:	91 83       	std	Z+1, r25	; 0x01
    1ad2:	80 83       	st	Z, r24
    1ad4:	8e ef       	ldi	r24, 0xFE	; 254
    1ad6:	91 e0       	ldi	r25, 0x01	; 1
    1ad8:	93 83       	std	Z+3, r25	; 0x03
    1ada:	82 83       	std	Z+2, r24	; 0x02
    1adc:	8b e9       	ldi	r24, 0x9B	; 155
    1ade:	9b e0       	ldi	r25, 0x0B	; 11
    1ae0:	95 83       	std	Z+5, r25	; 0x05
    1ae2:	84 83       	std	Z+4, r24	; 0x04
    1ae4:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1ae8:	ed b7       	in	r30, 0x3d	; 61
    1aea:	fe b7       	in	r31, 0x3e	; 62
    1aec:	36 96       	adiw	r30, 0x06	; 6
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	fe bf       	out	0x3e, r31	; 62
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	ed bf       	out	0x3d, r30	; 61
		            	   sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, nack, pkt.tag);
    1af8:	80 91 ec 08 	lds	r24, 0x08EC
    1afc:	90 91 ed 08 	lds	r25, 0x08ED
    1b00:	8c 01       	movw	r16, r24
    1b02:	0e 5d       	subi	r16, 0xDE	; 222
    1b04:	1f 4f       	sbci	r17, 0xFF	; 255
    1b06:	80 91 ec 08 	lds	r24, 0x08EC
    1b0a:	90 91 ed 08 	lds	r25, 0x08ED
    1b0e:	82 96       	adiw	r24, 0x22	; 34
    1b10:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1b14:	01 96       	adiw	r24, 0x01	; 1
    1b16:	9c 01       	movw	r18, r24
    1b18:	50 91 9a 0b 	lds	r21, 0x0B9A
    1b1c:	c8 01       	movw	r24, r16
    1b1e:	b9 01       	movw	r22, r18
    1b20:	42 e0       	ldi	r20, 0x02	; 2
    1b22:	25 2f       	mov	r18, r21
    1b24:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1b28:	37 c3       	rjmp	.+1646   	; 0x2198 <APLPoll+0xbee>
                            }
                    }
                    else if (set_antenna_power == pkt.type)  //parameters: <1 to 8> (ascii)  (the new antenna power)
    1b2a:	80 91 99 0b 	lds	r24, 0x0B99
    1b2e:	87 30       	cpi	r24, 0x07	; 7
    1b30:	09 f0       	breq	.+2      	; 0x1b34 <APLPoll+0x58a>
    1b32:	99 c0       	rjmp	.+306    	; 0x1c66 <APLPoll+0x6bc>
                    {
                            power = (MyByte8T)(atoi (pkt.params));
    1b34:	8b e9       	ldi	r24, 0x9B	; 155
    1b36:	9b e0       	ldi	r25, 0x0B	; 11
    1b38:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    1b3c:	89 83       	std	Y+1, r24	; 0x01
                            if (power != 0)
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
    1b40:	88 23       	and	r24, r24
    1b42:	59 f0       	breq	.+22     	; 0x1b5a <APLPoll+0x5b0>
                            {
                                    power = (power * 8) - 1;
    1b44:	89 81       	ldd	r24, Y+1	; 0x01
    1b46:	88 2f       	mov	r24, r24
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	88 0f       	add	r24, r24
    1b4c:	99 1f       	adc	r25, r25
    1b4e:	88 0f       	add	r24, r24
    1b50:	99 1f       	adc	r25, r25
    1b52:	88 0f       	add	r24, r24
    1b54:	99 1f       	adc	r25, r25
    1b56:	81 50       	subi	r24, 0x01	; 1
    1b58:	89 83       	std	Y+1, r24	; 0x01
                            }
                            downMsg.value = power;
    1b5a:	89 81       	ldd	r24, Y+1	; 0x01
    1b5c:	88 2f       	mov	r24, r24
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	90 93 78 09 	sts	0x0978, r25
    1b64:	80 93 77 09 	sts	0x0977, r24
                            downMsg.prim = PLME_SET_REQUEST;
    1b68:	8b e0       	ldi	r24, 0x0B	; 11
    1b6a:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_TX_POWER;
    1b6e:	82 e0       	ldi	r24, 0x02	; 2
    1b70:	80 93 79 09 	sts	0x0979, r24
                            PLMESap (&downMsg);
    1b74:	8e ee       	ldi	r24, 0xEE	; 238
    1b76:	98 e0       	ldi	r25, 0x08	; 8
    1b78:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
                            if (downMsg.status == PHY_SUCCESS)
    1b7c:	80 91 76 09 	lds	r24, 0x0976
    1b80:	87 30       	cpi	r24, 0x07	; 7
    1b82:	c9 f5       	brne	.+114    	; 0x1bf6 <APLPoll+0x64c>
                            {
                                    sprintf (apl->outpkt.params, "antenna power %s", pkt.params);
    1b84:	80 91 ec 08 	lds	r24, 0x08EC
    1b88:	90 91 ed 08 	lds	r25, 0x08ED
    1b8c:	82 96       	adiw	r24, 0x22	; 34
    1b8e:	00 d0       	rcall	.+0      	; 0x1b90 <APLPoll+0x5e6>
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <APLPoll+0x5e8>
    1b92:	00 d0       	rcall	.+0      	; 0x1b94 <APLPoll+0x5ea>
    1b94:	ed b7       	in	r30, 0x3d	; 61
    1b96:	fe b7       	in	r31, 0x3e	; 62
    1b98:	31 96       	adiw	r30, 0x01	; 1
    1b9a:	91 83       	std	Z+1, r25	; 0x01
    1b9c:	80 83       	st	Z, r24
    1b9e:	89 e1       	ldi	r24, 0x19	; 25
    1ba0:	92 e0       	ldi	r25, 0x02	; 2
    1ba2:	93 83       	std	Z+3, r25	; 0x03
    1ba4:	82 83       	std	Z+2, r24	; 0x02
    1ba6:	8b e9       	ldi	r24, 0x9B	; 155
    1ba8:	9b e0       	ldi	r25, 0x0B	; 11
    1baa:	95 83       	std	Z+5, r25	; 0x05
    1bac:	84 83       	std	Z+4, r24	; 0x04
    1bae:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1bb2:	2d b7       	in	r18, 0x3d	; 61
    1bb4:	3e b7       	in	r19, 0x3e	; 62
    1bb6:	2a 5f       	subi	r18, 0xFA	; 250
    1bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	3e bf       	out	0x3e, r19	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	2d bf       	out	0x3d, r18	; 61
		            	    sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1bc4:	80 91 ec 08 	lds	r24, 0x08EC
    1bc8:	90 91 ed 08 	lds	r25, 0x08ED
    1bcc:	8c 01       	movw	r16, r24
    1bce:	0e 5d       	subi	r16, 0xDE	; 222
    1bd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1bd2:	80 91 ec 08 	lds	r24, 0x08EC
    1bd6:	90 91 ed 08 	lds	r25, 0x08ED
    1bda:	82 96       	adiw	r24, 0x22	; 34
    1bdc:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1be0:	01 96       	adiw	r24, 0x01	; 1
    1be2:	9c 01       	movw	r18, r24
    1be4:	50 91 9a 0b 	lds	r21, 0x0B9A
    1be8:	c8 01       	movw	r24, r16
    1bea:	b9 01       	movw	r22, r18
    1bec:	41 e0       	ldi	r20, 0x01	; 1
    1bee:	25 2f       	mov	r18, r21
    1bf0:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1bf4:	d1 c2       	rjmp	.+1442   	; 0x2198 <APLPoll+0xbee>
                            }
                            else
                            {
                                    sprintf (apl->outpkt.params, "Error: illegal antenna power:%s", pkt.params);
    1bf6:	80 91 ec 08 	lds	r24, 0x08EC
    1bfa:	90 91 ed 08 	lds	r25, 0x08ED
    1bfe:	82 96       	adiw	r24, 0x22	; 34
    1c00:	00 d0       	rcall	.+0      	; 0x1c02 <APLPoll+0x658>
    1c02:	00 d0       	rcall	.+0      	; 0x1c04 <APLPoll+0x65a>
    1c04:	00 d0       	rcall	.+0      	; 0x1c06 <APLPoll+0x65c>
    1c06:	ed b7       	in	r30, 0x3d	; 61
    1c08:	fe b7       	in	r31, 0x3e	; 62
    1c0a:	31 96       	adiw	r30, 0x01	; 1
    1c0c:	91 83       	std	Z+1, r25	; 0x01
    1c0e:	80 83       	st	Z, r24
    1c10:	8a e2       	ldi	r24, 0x2A	; 42
    1c12:	92 e0       	ldi	r25, 0x02	; 2
    1c14:	93 83       	std	Z+3, r25	; 0x03
    1c16:	82 83       	std	Z+2, r24	; 0x02
    1c18:	8b e9       	ldi	r24, 0x9B	; 155
    1c1a:	9b e0       	ldi	r25, 0x0B	; 11
    1c1c:	95 83       	std	Z+5, r25	; 0x05
    1c1e:	84 83       	std	Z+4, r24	; 0x04
    1c20:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1c24:	8d b7       	in	r24, 0x3d	; 61
    1c26:	9e b7       	in	r25, 0x3e	; 62
    1c28:	06 96       	adiw	r24, 0x06	; 6
    1c2a:	0f b6       	in	r0, 0x3f	; 63
    1c2c:	f8 94       	cli
    1c2e:	9e bf       	out	0x3e, r25	; 62
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	8d bf       	out	0x3d, r24	; 61
		            	    sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, nack, pkt.tag);
    1c34:	80 91 ec 08 	lds	r24, 0x08EC
    1c38:	90 91 ed 08 	lds	r25, 0x08ED
    1c3c:	8c 01       	movw	r16, r24
    1c3e:	0e 5d       	subi	r16, 0xDE	; 222
    1c40:	1f 4f       	sbci	r17, 0xFF	; 255
    1c42:	80 91 ec 08 	lds	r24, 0x08EC
    1c46:	90 91 ed 08 	lds	r25, 0x08ED
    1c4a:	82 96       	adiw	r24, 0x22	; 34
    1c4c:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1c50:	01 96       	adiw	r24, 0x01	; 1
    1c52:	9c 01       	movw	r18, r24
    1c54:	50 91 9a 0b 	lds	r21, 0x0B9A
    1c58:	c8 01       	movw	r24, r16
    1c5a:	b9 01       	movw	r22, r18
    1c5c:	42 e0       	ldi	r20, 0x02	; 2
    1c5e:	25 2f       	mov	r18, r21
    1c60:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1c64:	99 c2       	rjmp	.+1330   	; 0x2198 <APLPoll+0xbee>
                            }
                    }
                    else if (set_give_acknowledgements == pkt.type)  //parameters:  <1|0> (ascii)  (enables or disables responding with acknowledgements to devices that write to us)
    1c66:	80 91 99 0b 	lds	r24, 0x0B99
    1c6a:	89 30       	cpi	r24, 0x09	; 9
    1c6c:	09 f0       	breq	.+2      	; 0x1c70 <APLPoll+0x6c6>
    1c6e:	75 c0       	rjmp	.+234    	; 0x1d5a <APLPoll+0x7b0>
                    {
                            downMsg.value = (MyByte8T)(atoi (pkt.params));
    1c70:	8b e9       	ldi	r24, 0x9B	; 155
    1c72:	9b e0       	ldi	r25, 0x0B	; 11
    1c74:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    1c78:	88 2f       	mov	r24, r24
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	90 93 78 09 	sts	0x0978, r25
    1c80:	80 93 77 09 	sts	0x0977, r24
                            downMsg.prim = PLME_SET_REQUEST;
    1c84:	8b e0       	ldi	r24, 0x0B	; 11
    1c86:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_ARQ;
    1c8a:	80 e7       	ldi	r24, 0x70	; 112
    1c8c:	80 93 79 09 	sts	0x0979, r24
                            PLMESap (&downMsg);
    1c90:	8e ee       	ldi	r24, 0xEE	; 238
    1c92:	98 e0       	ldi	r25, 0x08	; 8
    1c94:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
                            if (downMsg.status == PHY_SUCCESS)
    1c98:	80 91 76 09 	lds	r24, 0x0976
    1c9c:	87 30       	cpi	r24, 0x07	; 7
    1c9e:	c1 f5       	brne	.+112    	; 0x1d10 <APLPoll+0x766>
                            {
				    sprintf (apl->outpkt.params, "acks %s", pkt.params);
    1ca0:	80 91 ec 08 	lds	r24, 0x08EC
    1ca4:	90 91 ed 08 	lds	r25, 0x08ED
    1ca8:	82 96       	adiw	r24, 0x22	; 34
    1caa:	00 d0       	rcall	.+0      	; 0x1cac <APLPoll+0x702>
    1cac:	00 d0       	rcall	.+0      	; 0x1cae <APLPoll+0x704>
    1cae:	00 d0       	rcall	.+0      	; 0x1cb0 <APLPoll+0x706>
    1cb0:	ed b7       	in	r30, 0x3d	; 61
    1cb2:	fe b7       	in	r31, 0x3e	; 62
    1cb4:	31 96       	adiw	r30, 0x01	; 1
    1cb6:	91 83       	std	Z+1, r25	; 0x01
    1cb8:	80 83       	st	Z, r24
    1cba:	8a e4       	ldi	r24, 0x4A	; 74
    1cbc:	92 e0       	ldi	r25, 0x02	; 2
    1cbe:	93 83       	std	Z+3, r25	; 0x03
    1cc0:	82 83       	std	Z+2, r24	; 0x02
    1cc2:	8b e9       	ldi	r24, 0x9B	; 155
    1cc4:	9b e0       	ldi	r25, 0x0B	; 11
    1cc6:	95 83       	std	Z+5, r25	; 0x05
    1cc8:	84 83       	std	Z+4, r24	; 0x04
    1cca:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1cce:	ed b7       	in	r30, 0x3d	; 61
    1cd0:	fe b7       	in	r31, 0x3e	; 62
    1cd2:	36 96       	adiw	r30, 0x06	; 6
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	fe bf       	out	0x3e, r31	; 62
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	ed bf       	out	0x3d, r30	; 61
		            	    sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1cde:	80 91 ec 08 	lds	r24, 0x08EC
    1ce2:	90 91 ed 08 	lds	r25, 0x08ED
    1ce6:	8c 01       	movw	r16, r24
    1ce8:	0e 5d       	subi	r16, 0xDE	; 222
    1cea:	1f 4f       	sbci	r17, 0xFF	; 255
    1cec:	80 91 ec 08 	lds	r24, 0x08EC
    1cf0:	90 91 ed 08 	lds	r25, 0x08ED
    1cf4:	82 96       	adiw	r24, 0x22	; 34
    1cf6:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1cfa:	01 96       	adiw	r24, 0x01	; 1
    1cfc:	9c 01       	movw	r18, r24
    1cfe:	50 91 9a 0b 	lds	r21, 0x0B9A
    1d02:	c8 01       	movw	r24, r16
    1d04:	b9 01       	movw	r22, r18
    1d06:	41 e0       	ldi	r20, 0x01	; 1
    1d08:	25 2f       	mov	r18, r21
    1d0a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1d0e:	44 c2       	rjmp	.+1160   	; 0x2198 <APLPoll+0xbee>
                            }
                            else
                            {
                                    sprintf (apl->outpkt.params, "Error: invalid ack setting");
    1d10:	80 91 ec 08 	lds	r24, 0x08EC
    1d14:	90 91 ed 08 	lds	r25, 0x08ED
    1d18:	82 96       	adiw	r24, 0x22	; 34
    1d1a:	22 e5       	ldi	r18, 0x52	; 82
    1d1c:	32 e0       	ldi	r19, 0x02	; 2
    1d1e:	b9 01       	movw	r22, r18
    1d20:	4b e1       	ldi	r20, 0x1B	; 27
    1d22:	50 e0       	ldi	r21, 0x00	; 0
    1d24:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            	    sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, nack, pkt.tag);
    1d28:	80 91 ec 08 	lds	r24, 0x08EC
    1d2c:	90 91 ed 08 	lds	r25, 0x08ED
    1d30:	8c 01       	movw	r16, r24
    1d32:	0e 5d       	subi	r16, 0xDE	; 222
    1d34:	1f 4f       	sbci	r17, 0xFF	; 255
    1d36:	80 91 ec 08 	lds	r24, 0x08EC
    1d3a:	90 91 ed 08 	lds	r25, 0x08ED
    1d3e:	82 96       	adiw	r24, 0x22	; 34
    1d40:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1d44:	01 96       	adiw	r24, 0x01	; 1
    1d46:	9c 01       	movw	r18, r24
    1d48:	50 91 9a 0b 	lds	r21, 0x0B9A
    1d4c:	c8 01       	movw	r24, r16
    1d4e:	b9 01       	movw	r22, r18
    1d50:	42 e0       	ldi	r20, 0x02	; 2
    1d52:	25 2f       	mov	r18, r21
    1d54:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1d58:	1f c2       	rjmp	.+1086   	; 0x2198 <APLPoll+0xbee>
                            }
                    }
                    else if (get_net_stats == pkt.type) //parameters: none
    1d5a:	80 91 99 0b 	lds	r24, 0x0B99
    1d5e:	86 30       	cpi	r24, 0x06	; 6
    1d60:	09 f0       	breq	.+2      	; 0x1d64 <APLPoll+0x7ba>
    1d62:	4d c0       	rjmp	.+154    	; 0x1dfe <APLPoll+0x854>
                    {        
			    sprintf (apl->outpkt.params, "stats: src %d dest %d", 
    1d64:	80 91 ec 08 	lds	r24, 0x08EC
    1d68:	90 91 ed 08 	lds	r25, 0x08ED
    1d6c:	9c 01       	movw	r18, r24
    1d6e:	2e 5d       	subi	r18, 0xDE	; 222
    1d70:	3f 4f       	sbci	r19, 0xFF	; 255
    1d72:	e0 91 ec 08 	lds	r30, 0x08EC
    1d76:	f0 91 ed 08 	lds	r31, 0x08ED
    1d7a:	87 85       	ldd	r24, Z+15	; 0x0f
    1d7c:	48 2f       	mov	r20, r24
    1d7e:	50 e0       	ldi	r21, 0x00	; 0
    1d80:	e0 91 ec 08 	lds	r30, 0x08EC
    1d84:	f0 91 ed 08 	lds	r31, 0x08ED
    1d88:	81 85       	ldd	r24, Z+9	; 0x09
    1d8a:	68 2f       	mov	r22, r24
    1d8c:	70 e0       	ldi	r23, 0x00	; 0
    1d8e:	8d b7       	in	r24, 0x3d	; 61
    1d90:	9e b7       	in	r25, 0x3e	; 62
    1d92:	08 97       	sbiw	r24, 0x08	; 8
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	9e bf       	out	0x3e, r25	; 62
    1d9a:	0f be       	out	0x3f, r0	; 63
    1d9c:	8d bf       	out	0x3d, r24	; 61
    1d9e:	ed b7       	in	r30, 0x3d	; 61
    1da0:	fe b7       	in	r31, 0x3e	; 62
    1da2:	31 96       	adiw	r30, 0x01	; 1
    1da4:	31 83       	std	Z+1, r19	; 0x01
    1da6:	20 83       	st	Z, r18
    1da8:	8d e6       	ldi	r24, 0x6D	; 109
    1daa:	92 e0       	ldi	r25, 0x02	; 2
    1dac:	93 83       	std	Z+3, r25	; 0x03
    1dae:	82 83       	std	Z+2, r24	; 0x02
    1db0:	55 83       	std	Z+5, r21	; 0x05
    1db2:	44 83       	std	Z+4, r20	; 0x04
    1db4:	77 83       	std	Z+7, r23	; 0x07
    1db6:	66 83       	std	Z+6, r22	; 0x06
    1db8:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    1dbc:	ed b7       	in	r30, 0x3d	; 61
    1dbe:	fe b7       	in	r31, 0x3e	; 62
    1dc0:	38 96       	adiw	r30, 0x08	; 8
    1dc2:	0f b6       	in	r0, 0x3f	; 63
    1dc4:	f8 94       	cli
    1dc6:	fe bf       	out	0x3e, r31	; 62
    1dc8:	0f be       	out	0x3f, r0	; 63
    1dca:	ed bf       	out	0x3d, r30	; 61
			       apl->src[5],
			       apl->dest[5]
			    );
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1dcc:	80 91 ec 08 	lds	r24, 0x08EC
    1dd0:	90 91 ed 08 	lds	r25, 0x08ED
    1dd4:	8c 01       	movw	r16, r24
    1dd6:	0e 5d       	subi	r16, 0xDE	; 222
    1dd8:	1f 4f       	sbci	r17, 0xFF	; 255
    1dda:	80 91 ec 08 	lds	r24, 0x08EC
    1dde:	90 91 ed 08 	lds	r25, 0x08ED
    1de2:	82 96       	adiw	r24, 0x22	; 34
    1de4:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1de8:	01 96       	adiw	r24, 0x01	; 1
    1dea:	9c 01       	movw	r18, r24
    1dec:	50 91 9a 0b 	lds	r21, 0x0B9A
    1df0:	c8 01       	movw	r24, r16
    1df2:	b9 01       	movw	r22, r18
    1df4:	41 e0       	ldi	r20, 0x01	; 1
    1df6:	25 2f       	mov	r18, r21
    1df8:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    1dfc:	cd c1       	rjmp	.+922    	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (goto_chat_mode == pkt.type) //parameters: none
    1dfe:	80 91 99 0b 	lds	r24, 0x0B99
    1e02:	8a 30       	cpi	r24, 0x0A	; 10
    1e04:	d9 f5       	brne	.+118    	; 0x1e7c <APLPoll+0x8d2>
                    {
			    sprintf (apl->outpkt.params, "chat");
    1e06:	80 91 ec 08 	lds	r24, 0x08EC
    1e0a:	90 91 ed 08 	lds	r25, 0x08ED
    1e0e:	82 96       	adiw	r24, 0x22	; 34
    1e10:	23 e8       	ldi	r18, 0x83	; 131
    1e12:	32 e0       	ldi	r19, 0x02	; 2
    1e14:	b9 01       	movw	r22, r18
    1e16:	45 e0       	ldi	r20, 0x05	; 5
    1e18:	50 e0       	ldi	r21, 0x00	; 0
    1e1a:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1e1e:	80 91 ec 08 	lds	r24, 0x08EC
    1e22:	90 91 ed 08 	lds	r25, 0x08ED
    1e26:	8c 01       	movw	r16, r24
    1e28:	0e 5d       	subi	r16, 0xDE	; 222
    1e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e2c:	80 91 ec 08 	lds	r24, 0x08EC
    1e30:	90 91 ed 08 	lds	r25, 0x08ED
    1e34:	82 96       	adiw	r24, 0x22	; 34
    1e36:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1e3a:	01 96       	adiw	r24, 0x01	; 1
    1e3c:	9c 01       	movw	r18, r24
    1e3e:	50 91 9a 0b 	lds	r21, 0x0B9A
    1e42:	c8 01       	movw	r24, r16
    1e44:	b9 01       	movw	r22, r18
    1e46:	41 e0       	ldi	r20, 0x01	; 1
    1e48:	25 2f       	mov	r18, r21
    1e4a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
                            apl->mode = chat;
    1e4e:	e0 91 ec 08 	lds	r30, 0x08EC
    1e52:	f0 91 ed 08 	lds	r31, 0x08ED
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	80 8b       	std	Z+16, r24	; 0x10
                            /* switch on receiver */
                            downMsg.prim = PLME_SET_REQUEST;
    1e5a:	8b e0       	ldi	r24, 0x0B	; 11
    1e5c:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_RX_CMD;
    1e60:	81 e9       	ldi	r24, 0x91	; 145
    1e62:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = PHY_RX_ON;
    1e66:	86 e0       	ldi	r24, 0x06	; 6
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	90 93 78 09 	sts	0x0978, r25
    1e6e:	80 93 77 09 	sts	0x0977, r24
                            PLMESap (&downMsg);
    1e72:	8e ee       	ldi	r24, 0xEE	; 238
    1e74:	98 e0       	ldi	r25, 0x08	; 8
    1e76:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    1e7a:	8e c1       	rjmp	.+796    	; 0x2198 <APLPoll+0xbee>
		    }
                    else if (request_2way_range == pkt.type) //parameters: none  (command for sending range packets, range is calculated on the way to the bouncer node, and also on the way back)
    1e7c:	80 91 99 0b 	lds	r24, 0x0B99
    1e80:	8b 30       	cpi	r24, 0x0B	; 11
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <APLPoll+0x8dc>
    1e84:	45 c0       	rjmp	.+138    	; 0x1f10 <APLPoll+0x966>
                    {
                            /* switch FEC on */
                            downMsg.prim = PLME_SET_REQUEST;
    1e86:	8b e0       	ldi	r24, 0x0B	; 11
    1e88:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_FEC;
    1e8c:	82 e7       	ldi	r24, 0x72	; 114
    1e8e:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = FALSE;
    1e92:	10 92 78 09 	sts	0x0978, r1
    1e96:	10 92 77 09 	sts	0x0977, r1
                            PLMESap (&downMsg);
    1e9a:	8e ee       	ldi	r24, 0xEE	; 238
    1e9c:	98 e0       	ldi	r25, 0x08	; 8
    1e9e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

                            /* switch on receiver */
                            downMsg.prim = PLME_SET_REQUEST;
    1ea2:	8b e0       	ldi	r24, 0x0B	; 11
    1ea4:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_RX_CMD;
    1ea8:	81 e9       	ldi	r24, 0x91	; 145
    1eaa:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = PHY_RX_ON;
    1eae:	86 e0       	ldi	r24, 0x06	; 6
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	90 93 78 09 	sts	0x0978, r25
    1eb6:	80 93 77 09 	sts	0x0977, r24
                            PLMESap (&downMsg);
    1eba:	8e ee       	ldi	r24, 0xEE	; 238
    1ebc:	98 e0       	ldi	r25, 0x08	; 8
    1ebe:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

		            sprintf (apl->outpkt.params, "2way rng");
    1ec2:	80 91 ec 08 	lds	r24, 0x08EC
    1ec6:	90 91 ed 08 	lds	r25, 0x08ED
    1eca:	82 96       	adiw	r24, 0x22	; 34
    1ecc:	28 e8       	ldi	r18, 0x88	; 136
    1ece:	32 e0       	ldi	r19, 0x02	; 2
    1ed0:	b9 01       	movw	r22, r18
    1ed2:	49 e0       	ldi	r20, 0x09	; 9
    1ed4:	50 e0       	ldi	r21, 0x00	; 0
    1ed6:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag); //we acknowledge the command first to prevent the possibility that the ARM gets a range response before the acknowledgement for the command.
    1eda:	80 91 ec 08 	lds	r24, 0x08EC
    1ede:	90 91 ed 08 	lds	r25, 0x08ED
    1ee2:	8c 01       	movw	r16, r24
    1ee4:	0e 5d       	subi	r16, 0xDE	; 222
    1ee6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee8:	80 91 ec 08 	lds	r24, 0x08EC
    1eec:	90 91 ed 08 	lds	r25, 0x08ED
    1ef0:	82 96       	adiw	r24, 0x22	; 34
    1ef2:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1ef6:	01 96       	adiw	r24, 0x01	; 1
    1ef8:	9c 01       	movw	r18, r24
    1efa:	50 91 9a 0b 	lds	r21, 0x0B9A
    1efe:	c8 01       	movw	r24, r16
    1f00:	b9 01       	movw	r22, r18
    1f02:	41 e0       	ldi	r20, 0x01	; 1
    1f04:	25 2f       	mov	r18, r21
    1f06:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
			    SendRange();
    1f0a:	0e 94 2b 0a 	call	0x1456	; 0x1456 <SendRange>
    1f0e:	44 c1       	rjmp	.+648    	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (request_1way_range == pkt.type)  //parameters: none (command sends range request packets, range is calculated only on the way to the bouncer node (or on the way back, not sure, but only in one of the two)
    1f10:	80 91 99 0b 	lds	r24, 0x0B99
    1f14:	8c 30       	cpi	r24, 0x0C	; 12
    1f16:	09 f0       	breq	.+2      	; 0x1f1a <APLPoll+0x970>
    1f18:	45 c0       	rjmp	.+138    	; 0x1fa4 <APLPoll+0x9fa>
                    {
                            /* switch FEC on */
                            downMsg.prim = PLME_SET_REQUEST;
    1f1a:	8b e0       	ldi	r24, 0x0B	; 11
    1f1c:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_FEC;
    1f20:	82 e7       	ldi	r24, 0x72	; 114
    1f22:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = FALSE;
    1f26:	10 92 78 09 	sts	0x0978, r1
    1f2a:	10 92 77 09 	sts	0x0977, r1
                            PLMESap (&downMsg);
    1f2e:	8e ee       	ldi	r24, 0xEE	; 238
    1f30:	98 e0       	ldi	r25, 0x08	; 8
    1f32:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

                            /* switch on receiver */
                            downMsg.prim = PLME_SET_REQUEST;
    1f36:	8b e0       	ldi	r24, 0x0B	; 11
    1f38:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_RX_CMD;
    1f3c:	81 e9       	ldi	r24, 0x91	; 145
    1f3e:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = PHY_RX_ON;
    1f42:	86 e0       	ldi	r24, 0x06	; 6
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	90 93 78 09 	sts	0x0978, r25
    1f4a:	80 93 77 09 	sts	0x0977, r24
                            PLMESap (&downMsg);
    1f4e:	8e ee       	ldi	r24, 0xEE	; 238
    1f50:	98 e0       	ldi	r25, 0x08	; 8
    1f52:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
		            
			    sprintf (apl->outpkt.params, "1way rng");
    1f56:	80 91 ec 08 	lds	r24, 0x08EC
    1f5a:	90 91 ed 08 	lds	r25, 0x08ED
    1f5e:	82 96       	adiw	r24, 0x22	; 34
    1f60:	21 e9       	ldi	r18, 0x91	; 145
    1f62:	32 e0       	ldi	r19, 0x02	; 2
    1f64:	b9 01       	movw	r22, r18
    1f66:	49 e0       	ldi	r20, 0x09	; 9
    1f68:	50 e0       	ldi	r21, 0x00	; 0
    1f6a:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag); //we acknowledge the command first to prevent the possibiltity that the ARM gets a range response before the acknowledgement for the command.
    1f6e:	80 91 ec 08 	lds	r24, 0x08EC
    1f72:	90 91 ed 08 	lds	r25, 0x08ED
    1f76:	8c 01       	movw	r16, r24
    1f78:	0e 5d       	subi	r16, 0xDE	; 222
    1f7a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f7c:	80 91 ec 08 	lds	r24, 0x08EC
    1f80:	90 91 ed 08 	lds	r25, 0x08ED
    1f84:	82 96       	adiw	r24, 0x22	; 34
    1f86:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    1f8a:	01 96       	adiw	r24, 0x01	; 1
    1f8c:	9c 01       	movw	r18, r24
    1f8e:	50 91 9a 0b 	lds	r21, 0x0B9A
    1f92:	c8 01       	movw	r24, r16
    1f94:	b9 01       	movw	r22, r18
    1f96:	41 e0       	ldi	r20, 0x01	; 1
    1f98:	25 2f       	mov	r18, r21
    1f9a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
			    SendFastRange();	
    1f9e:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <SendFastRange>
    1fa2:	fa c0       	rjmp	.+500    	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (spray == pkt.type) //parameters: none  (sprays messages to the destination mac address, used for measure of pkt loss)
    1fa4:	80 91 99 0b 	lds	r24, 0x0B99
    1fa8:	85 30       	cpi	r24, 0x05	; 5
    1faa:	09 f0       	breq	.+2      	; 0x1fae <APLPoll+0xa04>
    1fac:	3f c0       	rjmp	.+126    	; 0x202c <APLPoll+0xa82>
                    {
                            apl->mode = spray;
    1fae:	e0 91 ec 08 	lds	r30, 0x08EC
    1fb2:	f0 91 ed 08 	lds	r31, 0x08ED
    1fb6:	85 e0       	ldi	r24, 0x05	; 5
    1fb8:	80 8b       	std	Z+16, r24	; 0x10
                            packets_received = 0;
    1fba:	10 92 89 09 	sts	0x0989, r1
    1fbe:	10 92 88 09 	sts	0x0988, r1

                            /* switch on receiver */
                            downMsg.prim = PLME_SET_REQUEST;
    1fc2:	8b e0       	ldi	r24, 0x0B	; 11
    1fc4:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_RX_CMD;
    1fc8:	81 e9       	ldi	r24, 0x91	; 145
    1fca:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = PHY_RX_ON;
    1fce:	86 e0       	ldi	r24, 0x06	; 6
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	90 93 78 09 	sts	0x0978, r25
    1fd6:	80 93 77 09 	sts	0x0977, r24
                            PLMESap (&downMsg);
    1fda:	8e ee       	ldi	r24, 0xEE	; 238
    1fdc:	98 e0       	ldi	r25, 0x08	; 8
    1fde:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
		            sprintf (apl->outpkt.params, "spray");
    1fe2:	80 91 ec 08 	lds	r24, 0x08EC
    1fe6:	90 91 ed 08 	lds	r25, 0x08ED
    1fea:	82 96       	adiw	r24, 0x22	; 34
    1fec:	2a e9       	ldi	r18, 0x9A	; 154
    1fee:	32 e0       	ldi	r19, 0x02	; 2
    1ff0:	b9 01       	movw	r22, r18
    1ff2:	46 e0       	ldi	r20, 0x06	; 6
    1ff4:	50 e0       	ldi	r21, 0x00	; 0
    1ff6:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    1ffa:	80 91 ec 08 	lds	r24, 0x08EC
    1ffe:	90 91 ed 08 	lds	r25, 0x08ED
    2002:	8c 01       	movw	r16, r24
    2004:	0e 5d       	subi	r16, 0xDE	; 222
    2006:	1f 4f       	sbci	r17, 0xFF	; 255
    2008:	80 91 ec 08 	lds	r24, 0x08EC
    200c:	90 91 ed 08 	lds	r25, 0x08ED
    2010:	82 96       	adiw	r24, 0x22	; 34
    2012:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    2016:	01 96       	adiw	r24, 0x01	; 1
    2018:	9c 01       	movw	r18, r24
    201a:	50 91 9a 0b 	lds	r21, 0x0B9A
    201e:	c8 01       	movw	r24, r16
    2020:	b9 01       	movw	r22, r18
    2022:	41 e0       	ldi	r20, 0x01	; 1
    2024:	25 2f       	mov	r18, r21
    2026:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    202a:	b6 c0       	rjmp	.+364    	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (range_listen == pkt.type)  //parameters: none  (command for awaiting range packets)
    202c:	80 91 99 0b 	lds	r24, 0x0B99
    2030:	8d 30       	cpi	r24, 0x0D	; 13
    2032:	a9 f5       	brne	.+106    	; 0x209e <APLPoll+0xaf4>
                    {
                            /* switch on receiver */
                            downMsg.prim = PLME_SET_REQUEST;
    2034:	8b e0       	ldi	r24, 0x0B	; 11
    2036:	80 93 ee 08 	sts	0x08EE, r24
                            downMsg.attribute = PHY_RX_CMD;
    203a:	81 e9       	ldi	r24, 0x91	; 145
    203c:	80 93 79 09 	sts	0x0979, r24
                            downMsg.value = PHY_RX_ON;
    2040:	86 e0       	ldi	r24, 0x06	; 6
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	90 93 78 09 	sts	0x0978, r25
    2048:	80 93 77 09 	sts	0x0977, r24
                            PLMESap (&downMsg);
    204c:	8e ee       	ldi	r24, 0xEE	; 238
    204e:	98 e0       	ldi	r25, 0x08	; 8
    2050:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
			    sprintf (apl->outpkt.params, "rng listen");
    2054:	80 91 ec 08 	lds	r24, 0x08EC
    2058:	90 91 ed 08 	lds	r25, 0x08ED
    205c:	82 96       	adiw	r24, 0x22	; 34
    205e:	20 ea       	ldi	r18, 0xA0	; 160
    2060:	32 e0       	ldi	r19, 0x02	; 2
    2062:	b9 01       	movw	r22, r18
    2064:	4b e0       	ldi	r20, 0x0B	; 11
    2066:	50 e0       	ldi	r21, 0x00	; 0
    2068:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		            sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    206c:	80 91 ec 08 	lds	r24, 0x08EC
    2070:	90 91 ed 08 	lds	r25, 0x08ED
    2074:	8c 01       	movw	r16, r24
    2076:	0e 5d       	subi	r16, 0xDE	; 222
    2078:	1f 4f       	sbci	r17, 0xFF	; 255
    207a:	80 91 ec 08 	lds	r24, 0x08EC
    207e:	90 91 ed 08 	lds	r25, 0x08ED
    2082:	82 96       	adiw	r24, 0x22	; 34
    2084:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    2088:	01 96       	adiw	r24, 0x01	; 1
    208a:	9c 01       	movw	r18, r24
    208c:	50 91 9a 0b 	lds	r21, 0x0B9A
    2090:	c8 01       	movw	r24, r16
    2092:	b9 01       	movw	r22, r18
    2094:	41 e0       	ldi	r20, 0x01	; 1
    2096:	25 2f       	mov	r18, r21
    2098:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    209c:	7d c0       	rjmp	.+250    	; 0x2198 <APLPoll+0xbee>
                    }
                    else if (send_msg == pkt.type)  { //parameters:  the data to send over-the-air, may be binary.
    209e:	80 91 99 0b 	lds	r24, 0x0B99
    20a2:	83 30       	cpi	r24, 0x03	; 3
    20a4:	e9 f5       	brne	.+122    	; 0x2120 <APLPoll+0xb76>
		        //TODO: react if message from uart doesn't fit into a single radio message
			apl->len = pkt.size - Sf_packet_header_overhead - sizeof(crc);
    20a6:	e0 91 ec 08 	lds	r30, 0x08EC
    20aa:	f0 91 ed 08 	lds	r31, 0x08ED
    20ae:	80 91 98 0b 	lds	r24, 0x0B98
    20b2:	85 50       	subi	r24, 0x05	; 5
    20b4:	82 8b       	std	Z+18, r24	; 0x12
			memcpy (downMsg.data, pkt.params, apl->len ); //need a checksum here for the data that will be transmitted over-the-air
    20b6:	e0 91 ec 08 	lds	r30, 0x08EC
    20ba:	f0 91 ed 08 	lds	r31, 0x08ED
    20be:	82 89       	ldd	r24, Z+18	; 0x12
    20c0:	48 2f       	mov	r20, r24
    20c2:	50 e0       	ldi	r21, 0x00	; 0
    20c4:	86 ef       	ldi	r24, 0xF6	; 246
    20c6:	98 e0       	ldi	r25, 0x08	; 8
    20c8:	2b e9       	ldi	r18, 0x9B	; 155
    20ca:	3b e0       	ldi	r19, 0x0B	; 11
    20cc:	b9 01       	movw	r22, r18
    20ce:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
			SendBuffer();
    20d2:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <SendBuffer>
			sprintf (apl->outpkt.params, "msg sent");
    20d6:	80 91 ec 08 	lds	r24, 0x08EC
    20da:	90 91 ed 08 	lds	r25, 0x08ED
    20de:	82 96       	adiw	r24, 0x22	; 34
    20e0:	2b ea       	ldi	r18, 0xAB	; 171
    20e2:	32 e0       	ldi	r19, 0x02	; 2
    20e4:	b9 01       	movw	r22, r18
    20e6:	49 e0       	ldi	r20, 0x09	; 9
    20e8:	50 e0       	ldi	r21, 0x00	; 0
    20ea:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
			sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, pkt.tag);
    20ee:	80 91 ec 08 	lds	r24, 0x08EC
    20f2:	90 91 ed 08 	lds	r25, 0x08ED
    20f6:	8c 01       	movw	r16, r24
    20f8:	0e 5d       	subi	r16, 0xDE	; 222
    20fa:	1f 4f       	sbci	r17, 0xFF	; 255
    20fc:	80 91 ec 08 	lds	r24, 0x08EC
    2100:	90 91 ed 08 	lds	r25, 0x08ED
    2104:	82 96       	adiw	r24, 0x22	; 34
    2106:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    210a:	01 96       	adiw	r24, 0x01	; 1
    210c:	9c 01       	movw	r18, r24
    210e:	50 91 9a 0b 	lds	r21, 0x0B9A
    2112:	c8 01       	movw	r24, r16
    2114:	b9 01       	movw	r22, r18
    2116:	41 e0       	ldi	r20, 0x01	; 1
    2118:	25 2f       	mov	r18, r21
    211a:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
    211e:	3c c0       	rjmp	.+120    	; 0x2198 <APLPoll+0xbee>
		    }
                    else {
		        sprintf(apl->outpkt.params, "unknown command:%d", pkt.type);
    2120:	80 91 ec 08 	lds	r24, 0x08EC
    2124:	90 91 ed 08 	lds	r25, 0x08ED
    2128:	9c 01       	movw	r18, r24
    212a:	2e 5d       	subi	r18, 0xDE	; 222
    212c:	3f 4f       	sbci	r19, 0xFF	; 255
    212e:	80 91 99 0b 	lds	r24, 0x0B99
    2132:	48 2f       	mov	r20, r24
    2134:	50 e0       	ldi	r21, 0x00	; 0
    2136:	00 d0       	rcall	.+0      	; 0x2138 <APLPoll+0xb8e>
    2138:	00 d0       	rcall	.+0      	; 0x213a <APLPoll+0xb90>
    213a:	00 d0       	rcall	.+0      	; 0x213c <APLPoll+0xb92>
    213c:	ed b7       	in	r30, 0x3d	; 61
    213e:	fe b7       	in	r31, 0x3e	; 62
    2140:	31 96       	adiw	r30, 0x01	; 1
    2142:	31 83       	std	Z+1, r19	; 0x01
    2144:	20 83       	st	Z, r18
    2146:	84 eb       	ldi	r24, 0xB4	; 180
    2148:	92 e0       	ldi	r25, 0x02	; 2
    214a:	93 83       	std	Z+3, r25	; 0x03
    214c:	82 83       	std	Z+2, r24	; 0x02
    214e:	55 83       	std	Z+5, r21	; 0x05
    2150:	44 83       	std	Z+4, r20	; 0x04
    2152:	0e 94 09 46 	call	0x8c12	; 0x8c12 <sprintf>
    2156:	2d b7       	in	r18, 0x3d	; 61
    2158:	3e b7       	in	r19, 0x3e	; 62
    215a:	2a 5f       	subi	r18, 0xFA	; 250
    215c:	3f 4f       	sbci	r19, 0xFF	; 255
    215e:	0f b6       	in	r0, 0x3f	; 63
    2160:	f8 94       	cli
    2162:	3e bf       	out	0x3e, r19	; 62
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	2d bf       	out	0x3d, r18	; 61
			sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, nack, pkt.tag);
    2168:	80 91 ec 08 	lds	r24, 0x08EC
    216c:	90 91 ed 08 	lds	r25, 0x08ED
    2170:	8c 01       	movw	r16, r24
    2172:	0e 5d       	subi	r16, 0xDE	; 222
    2174:	1f 4f       	sbci	r17, 0xFF	; 255
    2176:	80 91 ec 08 	lds	r24, 0x08EC
    217a:	90 91 ed 08 	lds	r25, 0x08ED
    217e:	82 96       	adiw	r24, 0x22	; 34
    2180:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    2184:	01 96       	adiw	r24, 0x01	; 1
    2186:	9c 01       	movw	r18, r24
    2188:	50 91 9a 0b 	lds	r21, 0x0B9A
    218c:	c8 01       	movw	r24, r16
    218e:	b9 01       	movw	r22, r18
    2190:	42 e0       	ldi	r20, 0x02	; 2
    2192:	25 2f       	mov	r18, r21
    2194:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
                    }
		    downMsg.len = 0;
    2198:	10 92 f5 08 	sts	0x08F5, r1
    219c:	27 c5       	rjmp	.+2638   	; 0x2bec <APLPoll+0x1642>
            }
	}
        else if (terminal == apl->mode)
    219e:	e0 91 ec 08 	lds	r30, 0x08EC
    21a2:	f0 91 ed 08 	lds	r31, 0x08ED
    21a6:	80 89       	ldd	r24, Z+16	; 0x10
    21a8:	88 23       	and	r24, r24
    21aa:	09 f0       	breq	.+2      	; 0x21ae <APLPoll+0xc04>
    21ac:	39 c2       	rjmp	.+1138   	; 0x2620 <APLPoll+0x1076>
	{
		/* Help text for all available commands */
		if (apl->help == 0)
    21ae:	e0 91 ec 08 	lds	r30, 0x08EC
    21b2:	f0 91 ed 08 	lds	r31, 0x08ED
    21b6:	81 89       	ldd	r24, Z+17	; 0x11
    21b8:	88 23       	and	r24, r24
    21ba:	09 f0       	breq	.+2      	; 0x21be <APLPoll+0xc14>
    21bc:	46 c0       	rjmp	.+140    	; 0x224a <APLPoll+0xca0>
		{
			apl->help = 1;
    21be:	e0 91 ec 08 	lds	r30, 0x08EC
    21c2:	f0 91 ed 08 	lds	r31, 0x08ED
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	81 8b       	std	Z+17, r24	; 0x11
			GUI_CHAR;
			printf ("Usage:\n");
    21ca:	87 ec       	ldi	r24, 0xC7	; 199
    21cc:	92 e0       	ldi	r25, 0x02	; 2
    21ce:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("src  <mac addr>        set local MAC address\n");
    21d2:	8e ec       	ldi	r24, 0xCE	; 206
    21d4:	92 e0       	ldi	r25, 0x02	; 2
    21d6:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("dest <mac addr>        set destination MAC address\n");
    21da:	8b ef       	ldi	r24, 0xFB	; 251
    21dc:	92 e0       	ldi	r25, 0x02	; 2
    21de:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("sc <n>                 set channel [0 80MHz, 1us, 2.441GHz cf, no FEC]\n");
    21e2:	8e e2       	ldi	r24, 0x2E	; 46
    21e4:	93 e0       	ldi	r25, 0x03	; 3
    21e6:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("                                   [1 22MHz, 4us, 2.412GHz cf, no FEC]\n");
    21ea:	85 e7       	ldi	r24, 0x75	; 117
    21ec:	93 e0       	ldi	r25, 0x03	; 3
    21ee:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("                                   [2 22MHz, 4us, 2.442GHz cf, no FEC]\n");
    21f2:	8c eb       	ldi	r24, 0xBC	; 188
    21f4:	93 e0       	ldi	r25, 0x03	; 3
    21f6:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("                                   [3 22MHz, 4us, 2.472GHz cf, no FEC]\n");
    21fa:	83 e0       	ldi	r24, 0x03	; 3
    21fc:	94 e0       	ldi	r25, 0x04	; 4
    21fe:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("pow <value>			set power	[0 - 8 ( * 8), -33dBm to 0dBm]\n");
    2202:	8a e4       	ldi	r24, 0x4A	; 74
    2204:	94 e0       	ldi	r25, 0x04	; 4
    2206:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("ack <value>			set auto ack [0 False, 1 True]\n");
    220a:	81 e8       	ldi	r24, 0x81	; 129
    220c:	94 e0       	ldi	r25, 0x04	; 4
    220e:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>

			printf ("chat                   start communication\n");
    2212:	8e ea       	ldi	r24, 0xAE	; 174
    2214:	94 e0       	ldi	r25, 0x04	; 4
    2216:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("rang                   send ranging request\n");
    221a:	89 ed       	ldi	r24, 0xD9	; 217
    221c:	94 e0       	ldi	r25, 0x04	; 4
    221e:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("ranf                   send fast ranging request\n");
    2222:	85 e0       	ldi	r24, 0x05	; 5
    2224:	95 e0       	ldi	r25, 0x05	; 5
    2226:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("ptes 			packet loss test | send packets\n");
    222a:	86 e3       	ldi	r24, 0x36	; 54
    222c:	95 e0       	ldi	r25, 0x05	; 5
    222e:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("plis                   packet loss/ range test | listen packets\n");
    2232:	8e e5       	ldi	r24, 0x5E	; 94
    2234:	95 e0       	ldi	r25, 0x05	; 5
    2236:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("help                   this menu\n");
    223a:	8e e9       	ldi	r24, 0x9E	; 158
    223c:	95 e0       	ldi	r25, 0x05	; 5
    223e:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			printf ("[ESC]                  leave chat mode\n");
    2242:	8f eb       	ldi	r24, 0xBF	; 191
    2244:	95 e0       	ldi	r25, 0x05	; 5
    2246:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
		}

		/* write a promt to mark configuration mode */
		if(write_prompt)
    224a:	80 91 c0 01 	lds	r24, 0x01C0
    224e:	90 91 c1 01 	lds	r25, 0x01C1
    2252:	00 97       	sbiw	r24, 0x00	; 0
    2254:	81 f0       	breq	.+32     	; 0x2276 <APLPoll+0xccc>
		{
			printf(PROMPT);
    2256:	00 d0       	rcall	.+0      	; 0x2258 <APLPoll+0xcae>
    2258:	ed b7       	in	r30, 0x3d	; 61
    225a:	fe b7       	in	r31, 0x3e	; 62
    225c:	31 96       	adiw	r30, 0x01	; 1
    225e:	86 ee       	ldi	r24, 0xE6	; 230
    2260:	95 e0       	ldi	r25, 0x05	; 5
    2262:	91 83       	std	Z+1, r25	; 0x01
    2264:	80 83       	st	Z, r24
    2266:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    226a:	0f 90       	pop	r0
    226c:	0f 90       	pop	r0
			write_prompt = 0;
    226e:	10 92 c1 01 	sts	0x01C1, r1
    2272:	10 92 c0 01 	sts	0x01C0, r1
		}

		if(!read_line(buf))
    2276:	87 e9       	ldi	r24, 0x97	; 151
    2278:	9c e0       	ldi	r25, 0x0C	; 12
    227a:	0e 94 9b 18 	call	0x3136	; 0x3136 <read_line>
    227e:	00 97       	sbiw	r24, 0x00	; 0
    2280:	09 f4       	brne	.+2      	; 0x2284 <APLPoll+0xcda>
    2282:	b4 c4       	rjmp	.+2408   	; 0x2bec <APLPoll+0x1642>
		{
			return;
		}

		write_prompt = 1;
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	90 e0       	ldi	r25, 0x00	; 0
    2288:	90 93 c1 01 	sts	0x01C1, r25
    228c:	80 93 c0 01 	sts	0x01C0, r24

		/* select the requested command by the user and execute it */
		if(buf[0] != 0)
    2290:	80 91 97 0c 	lds	r24, 0x0C97
    2294:	88 23       	and	r24, r24
    2296:	09 f4       	brne	.+2      	; 0x229a <APLPoll+0xcf0>
    2298:	a9 c4       	rjmp	.+2386   	; 0x2bec <APLPoll+0x1642>
		{
			if (memcmp (buf, "src ", 4) == 0)
    229a:	87 e9       	ldi	r24, 0x97	; 151
    229c:	9c e0       	ldi	r25, 0x0C	; 12
    229e:	2b ee       	ldi	r18, 0xEB	; 235
    22a0:	35 e0       	ldi	r19, 0x05	; 5
    22a2:	b9 01       	movw	r22, r18
    22a4:	44 e0       	ldi	r20, 0x04	; 4
    22a6:	50 e0       	ldi	r21, 0x00	; 0
    22a8:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    22ac:	00 97       	sbiw	r24, 0x00	; 0
    22ae:	39 f5       	brne	.+78     	; 0x22fe <APLPoll+0xd54>
			{
				apl->src[5] = atoi (&(buf[4]));
    22b0:	00 91 ec 08 	lds	r16, 0x08EC
    22b4:	10 91 ed 08 	lds	r17, 0x08ED
    22b8:	8b e9       	ldi	r24, 0x9B	; 155
    22ba:	9c e0       	ldi	r25, 0x0C	; 12
    22bc:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    22c0:	f8 01       	movw	r30, r16
    22c2:	87 87       	std	Z+15, r24	; 0x0f
				// NTRXSetStaAddress (app->src);
				downMsg.prim = PLME_SET_REQUEST;
    22c4:	8b e0       	ldi	r24, 0x0B	; 11
    22c6:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_MAC_ADDRESS1;
    22ca:	83 e7       	ldi	r24, 0x73	; 115
    22cc:	80 93 79 09 	sts	0x0979, r24
				memcpy (downMsg.data, apl->src, 6);
    22d0:	80 91 ec 08 	lds	r24, 0x08EC
    22d4:	90 91 ed 08 	lds	r25, 0x08ED
    22d8:	9c 01       	movw	r18, r24
    22da:	26 5f       	subi	r18, 0xF6	; 246
    22dc:	3f 4f       	sbci	r19, 0xFF	; 255
    22de:	86 ef       	ldi	r24, 0xF6	; 246
    22e0:	98 e0       	ldi	r25, 0x08	; 8
    22e2:	b9 01       	movw	r22, r18
    22e4:	46 e0       	ldi	r20, 0x06	; 6
    22e6:	50 e0       	ldi	r21, 0x00	; 0
    22e8:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				PLMESap (&downMsg);
    22ec:	8e ee       	ldi	r24, 0xEE	; 238
    22ee:	98 e0       	ldi	r25, 0x08	; 8
    22f0:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
				puts ("Ok");
    22f4:	80 ef       	ldi	r24, 0xF0	; 240
    22f6:	95 e0       	ldi	r25, 0x05	; 5
    22f8:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    22fc:	19 c0       	rjmp	.+50     	; 0x2330 <APLPoll+0xd86>
			}
			else if (memcmp (buf, "dest ", 5) == 0)
    22fe:	87 e9       	ldi	r24, 0x97	; 151
    2300:	9c e0       	ldi	r25, 0x0C	; 12
    2302:	23 ef       	ldi	r18, 0xF3	; 243
    2304:	35 e0       	ldi	r19, 0x05	; 5
    2306:	b9 01       	movw	r22, r18
    2308:	45 e0       	ldi	r20, 0x05	; 5
    230a:	50 e0       	ldi	r21, 0x00	; 0
    230c:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    2310:	00 97       	sbiw	r24, 0x00	; 0
    2312:	71 f4       	brne	.+28     	; 0x2330 <APLPoll+0xd86>
			{
				apl->dest[5] = atoi (&(buf[5]));
    2314:	00 91 ec 08 	lds	r16, 0x08EC
    2318:	10 91 ed 08 	lds	r17, 0x08ED
    231c:	8c e9       	ldi	r24, 0x9C	; 156
    231e:	9c e0       	ldi	r25, 0x0C	; 12
    2320:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    2324:	f8 01       	movw	r30, r16
    2326:	81 87       	std	Z+9, r24	; 0x09
				puts ("Ok");
    2328:	80 ef       	ldi	r24, 0xF0	; 240
    232a:	95 e0       	ldi	r25, 0x05	; 5
    232c:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>

			}


			if (strncmp (buf, "sc ", 3) == 0)
    2330:	87 e9       	ldi	r24, 0x97	; 151
    2332:	9c e0       	ldi	r25, 0x0C	; 12
    2334:	29 ef       	ldi	r18, 0xF9	; 249
    2336:	35 e0       	ldi	r19, 0x05	; 5
    2338:	b9 01       	movw	r22, r18
    233a:	43 e0       	ldi	r20, 0x03	; 3
    233c:	50 e0       	ldi	r21, 0x00	; 0
    233e:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2342:	00 97       	sbiw	r24, 0x00	; 0
    2344:	11 f5       	brne	.+68     	; 0x238a <APLPoll+0xde0>
			{
				downMsg.value = (MyByte8T)(atoi (&(buf[3])));
    2346:	8a e9       	ldi	r24, 0x9A	; 154
    2348:	9c e0       	ldi	r25, 0x0C	; 12
    234a:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    234e:	88 2f       	mov	r24, r24
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	90 93 78 09 	sts	0x0978, r25
    2356:	80 93 77 09 	sts	0x0977, r24
				downMsg.prim = PLME_SET_REQUEST;
    235a:	8b e0       	ldi	r24, 0x0B	; 11
    235c:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_LOG_CHANNEL;
    2360:	8f e7       	ldi	r24, 0x7F	; 127
    2362:	80 93 79 09 	sts	0x0979, r24
				PLMESap (&downMsg);
    2366:	8e ee       	ldi	r24, 0xEE	; 238
    2368:	98 e0       	ldi	r25, 0x08	; 8
    236a:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
				if (downMsg.status == PHY_SUCCESS)
    236e:	80 91 76 09 	lds	r24, 0x0976
    2372:	87 30       	cpi	r24, 0x07	; 7
    2374:	29 f4       	brne	.+10     	; 0x2380 <APLPoll+0xdd6>
				{
					puts ("Ok");
    2376:	80 ef       	ldi	r24, 0xF0	; 240
    2378:	95 e0       	ldi	r25, 0x05	; 5
    237a:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    237e:	4d c1       	rjmp	.+666    	; 0x261a <APLPoll+0x1070>
				}
				else
				{
					puts ("illegal channel");
    2380:	8d ef       	ldi	r24, 0xFD	; 253
    2382:	95 e0       	ldi	r25, 0x05	; 5
    2384:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    2388:	48 c1       	rjmp	.+656    	; 0x261a <APLPoll+0x1070>
				}

			}
			else if (strncmp (buf, "pow ", 4) == 0)
    238a:	87 e9       	ldi	r24, 0x97	; 151
    238c:	9c e0       	ldi	r25, 0x0C	; 12
    238e:	2d e0       	ldi	r18, 0x0D	; 13
    2390:	36 e0       	ldi	r19, 0x06	; 6
    2392:	b9 01       	movw	r22, r18
    2394:	44 e0       	ldi	r20, 0x04	; 4
    2396:	50 e0       	ldi	r21, 0x00	; 0
    2398:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    239c:	00 97       	sbiw	r24, 0x00	; 0
    239e:	91 f5       	brne	.+100    	; 0x2404 <APLPoll+0xe5a>
			{
				power = (MyByte8T)(atoi (&(buf[3])));
    23a0:	8a e9       	ldi	r24, 0x9A	; 154
    23a2:	9c e0       	ldi	r25, 0x0C	; 12
    23a4:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    23a8:	89 83       	std	Y+1, r24	; 0x01
				if (power != 0)
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	88 23       	and	r24, r24
    23ae:	59 f0       	breq	.+22     	; 0x23c6 <APLPoll+0xe1c>
				{
					power = (power * 8) - 1;
    23b0:	89 81       	ldd	r24, Y+1	; 0x01
    23b2:	88 2f       	mov	r24, r24
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	88 0f       	add	r24, r24
    23b8:	99 1f       	adc	r25, r25
    23ba:	88 0f       	add	r24, r24
    23bc:	99 1f       	adc	r25, r25
    23be:	88 0f       	add	r24, r24
    23c0:	99 1f       	adc	r25, r25
    23c2:	81 50       	subi	r24, 0x01	; 1
    23c4:	89 83       	std	Y+1, r24	; 0x01
				}
				downMsg.value = power;
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	88 2f       	mov	r24, r24
    23ca:	90 e0       	ldi	r25, 0x00	; 0
    23cc:	90 93 78 09 	sts	0x0978, r25
    23d0:	80 93 77 09 	sts	0x0977, r24
				downMsg.prim = PLME_SET_REQUEST;
    23d4:	8b e0       	ldi	r24, 0x0B	; 11
    23d6:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_TX_POWER;
    23da:	82 e0       	ldi	r24, 0x02	; 2
    23dc:	80 93 79 09 	sts	0x0979, r24
				PLMESap (&downMsg);
    23e0:	8e ee       	ldi	r24, 0xEE	; 238
    23e2:	98 e0       	ldi	r25, 0x08	; 8
    23e4:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
				if (downMsg.status == PHY_SUCCESS)
    23e8:	80 91 76 09 	lds	r24, 0x0976
    23ec:	87 30       	cpi	r24, 0x07	; 7
    23ee:	29 f4       	brne	.+10     	; 0x23fa <APLPoll+0xe50>
				{
					puts ("Ok");
    23f0:	80 ef       	ldi	r24, 0xF0	; 240
    23f2:	95 e0       	ldi	r25, 0x05	; 5
    23f4:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    23f8:	10 c1       	rjmp	.+544    	; 0x261a <APLPoll+0x1070>
				}
				else
				{
					puts ("illegal pow val");
    23fa:	82 e1       	ldi	r24, 0x12	; 18
    23fc:	96 e0       	ldi	r25, 0x06	; 6
    23fe:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    2402:	0b c1       	rjmp	.+534    	; 0x261a <APLPoll+0x1070>
				}
			}
			else if (strncmp (buf, "ack ", 4) == 0)
    2404:	87 e9       	ldi	r24, 0x97	; 151
    2406:	9c e0       	ldi	r25, 0x0C	; 12
    2408:	22 e2       	ldi	r18, 0x22	; 34
    240a:	36 e0       	ldi	r19, 0x06	; 6
    240c:	b9 01       	movw	r22, r18
    240e:	44 e0       	ldi	r20, 0x04	; 4
    2410:	50 e0       	ldi	r21, 0x00	; 0
    2412:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2416:	00 97       	sbiw	r24, 0x00	; 0
    2418:	11 f5       	brne	.+68     	; 0x245e <APLPoll+0xeb4>
			{
				downMsg.value = (MyByte8T)(atoi (&(buf[3])));
    241a:	8a e9       	ldi	r24, 0x9A	; 154
    241c:	9c e0       	ldi	r25, 0x0C	; 12
    241e:	0e 94 c4 43 	call	0x8788	; 0x8788 <atoi>
    2422:	88 2f       	mov	r24, r24
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	90 93 78 09 	sts	0x0978, r25
    242a:	80 93 77 09 	sts	0x0977, r24
				downMsg.prim = PLME_SET_REQUEST;
    242e:	8b e0       	ldi	r24, 0x0B	; 11
    2430:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_ARQ;
    2434:	80 e7       	ldi	r24, 0x70	; 112
    2436:	80 93 79 09 	sts	0x0979, r24
				PLMESap (&downMsg);
    243a:	8e ee       	ldi	r24, 0xEE	; 238
    243c:	98 e0       	ldi	r25, 0x08	; 8
    243e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
				if (downMsg.status == PHY_SUCCESS)
    2442:	80 91 76 09 	lds	r24, 0x0976
    2446:	87 30       	cpi	r24, 0x07	; 7
    2448:	29 f4       	brne	.+10     	; 0x2454 <APLPoll+0xeaa>
				{
					puts ("Ok");
    244a:	80 ef       	ldi	r24, 0xF0	; 240
    244c:	95 e0       	ldi	r25, 0x05	; 5
    244e:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    2452:	e3 c0       	rjmp	.+454    	; 0x261a <APLPoll+0x1070>
				}
				else
				{
					puts ("invalid axk val");
    2454:	87 e2       	ldi	r24, 0x27	; 39
    2456:	96 e0       	ldi	r25, 0x06	; 6
    2458:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    245c:	de c0       	rjmp	.+444    	; 0x261a <APLPoll+0x1070>
				}
			}

			else if (strncmp (buf, "help", 4) == 0)
    245e:	87 e9       	ldi	r24, 0x97	; 151
    2460:	9c e0       	ldi	r25, 0x0C	; 12
    2462:	27 e3       	ldi	r18, 0x37	; 55
    2464:	36 e0       	ldi	r19, 0x06	; 6
    2466:	b9 01       	movw	r22, r18
    2468:	44 e0       	ldi	r20, 0x04	; 4
    246a:	50 e0       	ldi	r21, 0x00	; 0
    246c:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2470:	00 97       	sbiw	r24, 0x00	; 0
    2472:	31 f4       	brne	.+12     	; 0x2480 <APLPoll+0xed6>
			{
				apl->help = 0;
    2474:	e0 91 ec 08 	lds	r30, 0x08EC
    2478:	f0 91 ed 08 	lds	r31, 0x08ED
    247c:	11 8a       	std	Z+17, r1	; 0x11
    247e:	cd c0       	rjmp	.+410    	; 0x261a <APLPoll+0x1070>
			}
			else if (strncmp (buf, "chat", 4) == 0)
    2480:	87 e9       	ldi	r24, 0x97	; 151
    2482:	9c e0       	ldi	r25, 0x0C	; 12
    2484:	23 e8       	ldi	r18, 0x83	; 131
    2486:	32 e0       	ldi	r19, 0x02	; 2
    2488:	b9 01       	movw	r22, r18
    248a:	44 e0       	ldi	r20, 0x04	; 4
    248c:	50 e0       	ldi	r21, 0x00	; 0
    248e:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2492:	00 97       	sbiw	r24, 0x00	; 0
    2494:	b9 f4       	brne	.+46     	; 0x24c4 <APLPoll+0xf1a>
			{
				apl->mode = chat;
    2496:	e0 91 ec 08 	lds	r30, 0x08EC
    249a:	f0 91 ed 08 	lds	r31, 0x08ED
    249e:	81 e0       	ldi	r24, 0x01	; 1
    24a0:	80 8b       	std	Z+16, r24	; 0x10
				/* switch on receiver */
				downMsg.prim = PLME_SET_REQUEST;
    24a2:	8b e0       	ldi	r24, 0x0B	; 11
    24a4:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    24a8:	81 e9       	ldi	r24, 0x91	; 145
    24aa:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_RX_ON;
    24ae:	86 e0       	ldi	r24, 0x06	; 6
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	90 93 78 09 	sts	0x0978, r25
    24b6:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    24ba:	8e ee       	ldi	r24, 0xEE	; 238
    24bc:	98 e0       	ldi	r25, 0x08	; 8
    24be:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    24c2:	ab c0       	rjmp	.+342    	; 0x261a <APLPoll+0x1070>
			}
			else if (strncmp (buf, "rang", 4) == 0)
    24c4:	87 e9       	ldi	r24, 0x97	; 151
    24c6:	9c e0       	ldi	r25, 0x0C	; 12
    24c8:	2c e3       	ldi	r18, 0x3C	; 60
    24ca:	36 e0       	ldi	r19, 0x06	; 6
    24cc:	b9 01       	movw	r22, r18
    24ce:	44 e0       	ldi	r20, 0x04	; 4
    24d0:	50 e0       	ldi	r21, 0x00	; 0
    24d2:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    24d6:	00 97       	sbiw	r24, 0x00	; 0
    24d8:	29 f5       	brne	.+74     	; 0x2524 <APLPoll+0xf7a>
			{
				apl->mode = request_two_way_range;
    24da:	e0 91 ec 08 	lds	r30, 0x08EC
    24de:	f0 91 ed 08 	lds	r31, 0x08ED
    24e2:	82 e0       	ldi	r24, 0x02	; 2
    24e4:	80 8b       	std	Z+16, r24	; 0x10
				/* switch FEC on */
				downMsg.prim = PLME_SET_REQUEST;
    24e6:	8b e0       	ldi	r24, 0x0B	; 11
    24e8:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_FEC;
    24ec:	82 e7       	ldi	r24, 0x72	; 114
    24ee:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = FALSE;
    24f2:	10 92 78 09 	sts	0x0978, r1
    24f6:	10 92 77 09 	sts	0x0977, r1
				PLMESap (&downMsg);
    24fa:	8e ee       	ldi	r24, 0xEE	; 238
    24fc:	98 e0       	ldi	r25, 0x08	; 8
    24fe:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

				/* switch on receiver */
				downMsg.prim = PLME_SET_REQUEST;
    2502:	8b e0       	ldi	r24, 0x0B	; 11
    2504:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    2508:	81 e9       	ldi	r24, 0x91	; 145
    250a:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_RX_ON;
    250e:	86 e0       	ldi	r24, 0x06	; 6
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	90 93 78 09 	sts	0x0978, r25
    2516:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    251a:	8e ee       	ldi	r24, 0xEE	; 238
    251c:	98 e0       	ldi	r25, 0x08	; 8
    251e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2522:	7b c0       	rjmp	.+246    	; 0x261a <APLPoll+0x1070>
			}
			else if (strncmp (buf, "ranf", 4) == 0)
    2524:	87 e9       	ldi	r24, 0x97	; 151
    2526:	9c e0       	ldi	r25, 0x0C	; 12
    2528:	21 e4       	ldi	r18, 0x41	; 65
    252a:	36 e0       	ldi	r19, 0x06	; 6
    252c:	b9 01       	movw	r22, r18
    252e:	44 e0       	ldi	r20, 0x04	; 4
    2530:	50 e0       	ldi	r21, 0x00	; 0
    2532:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2536:	00 97       	sbiw	r24, 0x00	; 0
    2538:	29 f5       	brne	.+74     	; 0x2584 <APLPoll+0xfda>
			{
				apl->mode = request_fast_range;
    253a:	e0 91 ec 08 	lds	r30, 0x08EC
    253e:	f0 91 ed 08 	lds	r31, 0x08ED
    2542:	83 e0       	ldi	r24, 0x03	; 3
    2544:	80 8b       	std	Z+16, r24	; 0x10

				/* switch FEC on */
				downMsg.prim = PLME_SET_REQUEST;
    2546:	8b e0       	ldi	r24, 0x0B	; 11
    2548:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_FEC;
    254c:	82 e7       	ldi	r24, 0x72	; 114
    254e:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = FALSE;
    2552:	10 92 78 09 	sts	0x0978, r1
    2556:	10 92 77 09 	sts	0x0977, r1
				PLMESap (&downMsg);
    255a:	8e ee       	ldi	r24, 0xEE	; 238
    255c:	98 e0       	ldi	r25, 0x08	; 8
    255e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>

				/* switch on receiver */
				downMsg.prim = PLME_SET_REQUEST;
    2562:	8b e0       	ldi	r24, 0x0B	; 11
    2564:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    2568:	81 e9       	ldi	r24, 0x91	; 145
    256a:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_RX_ON;
    256e:	86 e0       	ldi	r24, 0x06	; 6
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	90 93 78 09 	sts	0x0978, r25
    2576:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    257a:	8e ee       	ldi	r24, 0xEE	; 238
    257c:	98 e0       	ldi	r25, 0x08	; 8
    257e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2582:	4b c0       	rjmp	.+150    	; 0x261a <APLPoll+0x1070>
			}
			else if (strncmp (buf, "ptes", 4) == 0)
    2584:	87 e9       	ldi	r24, 0x97	; 151
    2586:	9c e0       	ldi	r25, 0x0C	; 12
    2588:	26 e4       	ldi	r18, 0x46	; 70
    258a:	36 e0       	ldi	r19, 0x06	; 6
    258c:	b9 01       	movw	r22, r18
    258e:	44 e0       	ldi	r20, 0x04	; 4
    2590:	50 e0       	ldi	r21, 0x00	; 0
    2592:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    2596:	00 97       	sbiw	r24, 0x00	; 0
    2598:	d9 f4       	brne	.+54     	; 0x25d0 <APLPoll+0x1026>
			{
				apl->mode = spray;
    259a:	e0 91 ec 08 	lds	r30, 0x08EC
    259e:	f0 91 ed 08 	lds	r31, 0x08ED
    25a2:	85 e0       	ldi	r24, 0x05	; 5
    25a4:	80 8b       	std	Z+16, r24	; 0x10
				packets_received = 0;
    25a6:	10 92 89 09 	sts	0x0989, r1
    25aa:	10 92 88 09 	sts	0x0988, r1

				/* switch on receiver */
				downMsg.prim = PLME_SET_REQUEST;
    25ae:	8b e0       	ldi	r24, 0x0B	; 11
    25b0:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    25b4:	81 e9       	ldi	r24, 0x91	; 145
    25b6:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_RX_ON;
    25ba:	86 e0       	ldi	r24, 0x06	; 6
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	90 93 78 09 	sts	0x0978, r25
    25c2:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    25c6:	8e ee       	ldi	r24, 0xEE	; 238
    25c8:	98 e0       	ldi	r25, 0x08	; 8
    25ca:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    25ce:	25 c0       	rjmp	.+74     	; 0x261a <APLPoll+0x1070>
			}
			else if (strncmp (buf, "plis", 4) == 0)
    25d0:	87 e9       	ldi	r24, 0x97	; 151
    25d2:	9c e0       	ldi	r25, 0x0C	; 12
    25d4:	2b e4       	ldi	r18, 0x4B	; 75
    25d6:	36 e0       	ldi	r19, 0x06	; 6
    25d8:	b9 01       	movw	r22, r18
    25da:	44 e0       	ldi	r20, 0x04	; 4
    25dc:	50 e0       	ldi	r21, 0x00	; 0
    25de:	0e 94 f4 44 	call	0x89e8	; 0x89e8 <strncmp>
    25e2:	00 97       	sbiw	r24, 0x00	; 0
    25e4:	d1 f4       	brne	.+52     	; 0x261a <APLPoll+0x1070>
			{
				apl->mode = listen_for_range_requests;
    25e6:	e0 91 ec 08 	lds	r30, 0x08EC
    25ea:	f0 91 ed 08 	lds	r31, 0x08ED
    25ee:	84 e0       	ldi	r24, 0x04	; 4
    25f0:	80 8b       	std	Z+16, r24	; 0x10
				packets_received = 0;
    25f2:	10 92 89 09 	sts	0x0989, r1
    25f6:	10 92 88 09 	sts	0x0988, r1

				/* switch on receiver */
				downMsg.prim = PLME_SET_REQUEST;
    25fa:	8b e0       	ldi	r24, 0x0B	; 11
    25fc:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    2600:	81 e9       	ldi	r24, 0x91	; 145
    2602:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_RX_ON;
    2606:	86 e0       	ldi	r24, 0x06	; 6
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	90 93 78 09 	sts	0x0978, r25
    260e:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    2612:	8e ee       	ldi	r24, 0xEE	; 238
    2614:	98 e0       	ldi	r25, 0x08	; 8
    2616:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
			}
			downMsg.len = 0;
    261a:	10 92 f5 08 	sts	0x08F5, r1
    261e:	e6 c2       	rjmp	.+1484   	; 0x2bec <APLPoll+0x1642>
		}
	}
	else if (chat == apl->mode)
    2620:	e0 91 ec 08 	lds	r30, 0x08EC
    2624:	f0 91 ed 08 	lds	r31, 0x08ED
    2628:	80 89       	ldd	r24, Z+16	; 0x10
    262a:	81 30       	cpi	r24, 0x01	; 1
    262c:	09 f0       	breq	.+2      	; 0x2630 <APLPoll+0x1086>
    262e:	94 c0       	rjmp	.+296    	; 0x2758 <APLPoll+0x11ae>
	{
		/* In chat mode collect all user input and transmit it to the peer device */
		if(!kbhit())
    2630:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    2634:	00 97       	sbiw	r24, 0x00	; 0
    2636:	59 f5       	brne	.+86     	; 0x268e <APLPoll+0x10e4>
		{
			if ((apl->hwclock + TIME_OUT < hwclock ()) && (apl->len > 0))
    2638:	e0 91 ec 08 	lds	r30, 0x08EC
    263c:	f0 91 ed 08 	lds	r31, 0x08ED
    2640:	80 81       	ld	r24, Z
    2642:	91 81       	ldd	r25, Z+1	; 0x01
    2644:	a2 81       	ldd	r26, Z+2	; 0x02
    2646:	b3 81       	ldd	r27, Z+3	; 0x03
    2648:	0f 2e       	mov	r0, r31
    264a:	f4 e1       	ldi	r31, 0x14	; 20
    264c:	ef 2e       	mov	r14, r31
    264e:	f0 e0       	ldi	r31, 0x00	; 0
    2650:	ff 2e       	mov	r15, r31
    2652:	f0 e0       	ldi	r31, 0x00	; 0
    2654:	0f 2f       	mov	r16, r31
    2656:	f0 e0       	ldi	r31, 0x00	; 0
    2658:	1f 2f       	mov	r17, r31
    265a:	f0 2d       	mov	r31, r0
    265c:	e8 0e       	add	r14, r24
    265e:	f9 1e       	adc	r15, r25
    2660:	0a 1f       	adc	r16, r26
    2662:	1b 1f       	adc	r17, r27
    2664:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    2668:	dc 01       	movw	r26, r24
    266a:	cb 01       	movw	r24, r22
    266c:	e8 16       	cp	r14, r24
    266e:	f9 06       	cpc	r15, r25
    2670:	0a 07       	cpc	r16, r26
    2672:	1b 07       	cpc	r17, r27
    2674:	08 f0       	brcs	.+2      	; 0x2678 <APLPoll+0x10ce>
    2676:	ba c2       	rjmp	.+1396   	; 0x2bec <APLPoll+0x1642>
    2678:	e0 91 ec 08 	lds	r30, 0x08EC
    267c:	f0 91 ed 08 	lds	r31, 0x08ED
    2680:	82 89       	ldd	r24, Z+18	; 0x12
    2682:	88 23       	and	r24, r24
    2684:	09 f4       	brne	.+2      	; 0x2688 <APLPoll+0x10de>
    2686:	b2 c2       	rjmp	.+1380   	; 0x2bec <APLPoll+0x1642>
			{
				SendBuffer ();
    2688:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <SendBuffer>
    268c:	af c2       	rjmp	.+1374   	; 0x2bec <APLPoll+0x1642>
			}
			return;
		}
		/* reset timer */
		apl->hwclock = hwclock ();
    268e:	00 91 ec 08 	lds	r16, 0x08EC
    2692:	10 91 ed 08 	lds	r17, 0x08ED
    2696:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    269a:	dc 01       	movw	r26, r24
    269c:	cb 01       	movw	r24, r22
    269e:	f8 01       	movw	r30, r16
    26a0:	80 83       	st	Z, r24
    26a2:	91 83       	std	Z+1, r25	; 0x01
    26a4:	a2 83       	std	Z+2, r26	; 0x02
    26a6:	b3 83       	std	Z+3, r27	; 0x03
    26a8:	47 c0       	rjmp	.+142    	; 0x2738 <APLPoll+0x118e>
		while (kbhit())
		{
			c = getchar ();
    26aa:	80 91 5a 10 	lds	r24, 0x105A
    26ae:	90 91 5b 10 	lds	r25, 0x105B
    26b2:	0e 94 15 45 	call	0x8a2a	; 0x8a2a <fgetc>
    26b6:	9b 83       	std	Y+3, r25	; 0x03
    26b8:	8a 83       	std	Y+2, r24	; 0x02
			if (c == 0x1b)
    26ba:	8a 81       	ldd	r24, Y+2	; 0x02
    26bc:	9b 81       	ldd	r25, Y+3	; 0x03
    26be:	8b 31       	cpi	r24, 0x1B	; 27
    26c0:	91 05       	cpc	r25, r1
    26c2:	f9 f4       	brne	.+62     	; 0x2702 <APLPoll+0x1158>
			{
				apl->mode = terminal;
    26c4:	e0 91 ec 08 	lds	r30, 0x08EC
    26c8:	f0 91 ed 08 	lds	r31, 0x08ED
    26cc:	10 8a       	std	Z+16, r1	; 0x10
				apl->len = 0;
    26ce:	e0 91 ec 08 	lds	r30, 0x08EC
    26d2:	f0 91 ed 08 	lds	r31, 0x08ED
    26d6:	12 8a       	std	Z+18, r1	; 0x12
				printf ("\nEnd of chat mode.\n");
    26d8:	80 e5       	ldi	r24, 0x50	; 80
    26da:	96 e0       	ldi	r25, 0x06	; 6
    26dc:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
				/* switch off receiver */
				downMsg.prim = PLME_SET_REQUEST;
    26e0:	8b e0       	ldi	r24, 0x0B	; 11
    26e2:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    26e6:	81 e9       	ldi	r24, 0x91	; 145
    26e8:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_TRX_OFF;
    26ec:	88 e0       	ldi	r24, 0x08	; 8
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	90 93 78 09 	sts	0x0978, r25
    26f4:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    26f8:	8e ee       	ldi	r24, 0xEE	; 238
    26fa:	98 e0       	ldi	r25, 0x08	; 8
    26fc:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2700:	75 c2       	rjmp	.+1258   	; 0x2bec <APLPoll+0x1642>
			}

#			ifdef GUI
			if( c != 0x0d )
#			endif
				putchar (c);
    2702:	20 91 5c 10 	lds	r18, 0x105C
    2706:	30 91 5d 10 	lds	r19, 0x105D
    270a:	8a 81       	ldd	r24, Y+2	; 0x02
    270c:	9b 81       	ldd	r25, Y+3	; 0x03
    270e:	b9 01       	movw	r22, r18
    2710:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>

			downMsg.data[apl->len++] = (MyByte8T)c;
    2714:	a0 91 ec 08 	lds	r26, 0x08EC
    2718:	b0 91 ed 08 	lds	r27, 0x08ED
    271c:	52 96       	adiw	r26, 0x12	; 18
    271e:	3c 91       	ld	r19, X
    2720:	52 97       	sbiw	r26, 0x12	; 18
    2722:	83 2f       	mov	r24, r19
    2724:	90 e0       	ldi	r25, 0x00	; 0
    2726:	2a 81       	ldd	r18, Y+2	; 0x02
    2728:	fc 01       	movw	r30, r24
    272a:	ea 50       	subi	r30, 0x0A	; 10
    272c:	f7 4f       	sbci	r31, 0xF7	; 247
    272e:	20 83       	st	Z, r18
    2730:	83 2f       	mov	r24, r19
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	52 96       	adiw	r26, 0x12	; 18
    2736:	8c 93       	st	X, r24
			}
			return;
		}
		/* reset timer */
		apl->hwclock = hwclock ();
		while (kbhit())
    2738:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	09 f0       	breq	.+2      	; 0x2742 <APLPoll+0x1198>
    2740:	b4 cf       	rjmp	.-152    	; 0x26aa <APLPoll+0x1100>
				putchar (c);

			downMsg.data[apl->len++] = (MyByte8T)c;
		}

		if (apl->len >= CONFIG_PAYLOAD_LEN - 1)
    2742:	e0 91 ec 08 	lds	r30, 0x08EC
    2746:	f0 91 ed 08 	lds	r31, 0x08ED
    274a:	82 89       	ldd	r24, Z+18	; 0x12
    274c:	8f 37       	cpi	r24, 0x7F	; 127
    274e:	08 f4       	brcc	.+2      	; 0x2752 <APLPoll+0x11a8>
    2750:	4d c2       	rjmp	.+1178   	; 0x2bec <APLPoll+0x1642>
		{
			SendBuffer ();
    2752:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <SendBuffer>
    2756:	4a c2       	rjmp	.+1172   	; 0x2bec <APLPoll+0x1642>
		}
	}
	else if (send_incoming_chars == apl->mode)
    2758:	e0 91 ec 08 	lds	r30, 0x08EC
    275c:	f0 91 ed 08 	lds	r31, 0x08ED
    2760:	80 89       	ldd	r24, Z+16	; 0x10
    2762:	87 30       	cpi	r24, 0x07	; 7
    2764:	09 f0       	breq	.+2      	; 0x2768 <APLPoll+0x11be>
    2766:	78 c0       	rjmp	.+240    	; 0x2858 <APLPoll+0x12ae>
    2768:	71 c0       	rjmp	.+226    	; 0x284c <APLPoll+0x12a2>
	{
		while (kbhit()) {
			//expect 1 byte less
			apl->remaining_bytes_to_be_sent --;
    276a:	20 91 ec 08 	lds	r18, 0x08EC
    276e:	30 91 ed 08 	lds	r19, 0x08ED
    2772:	f9 01       	movw	r30, r18
    2774:	e2 5e       	subi	r30, 0xE2	; 226
    2776:	fe 4f       	sbci	r31, 0xFE	; 254
    2778:	80 81       	ld	r24, Z
    277a:	91 81       	ldd	r25, Z+1	; 0x01
    277c:	01 97       	sbiw	r24, 0x01	; 1
    277e:	f9 01       	movw	r30, r18
    2780:	e2 5e       	subi	r30, 0xE2	; 226
    2782:	fe 4f       	sbci	r31, 0xFE	; 254
    2784:	91 83       	std	Z+1, r25	; 0x01
    2786:	80 83       	st	Z, r24
			//put byte in buffer
			c = getchar();
    2788:	80 91 5a 10 	lds	r24, 0x105A
    278c:	90 91 5b 10 	lds	r25, 0x105B
    2790:	0e 94 15 45 	call	0x8a2a	; 0x8a2a <fgetc>
    2794:	9b 83       	std	Y+3, r25	; 0x03
    2796:	8a 83       	std	Y+2, r24	; 0x02
			downMsg.data[apl->len++] = (MyByte8T)c;
    2798:	a0 91 ec 08 	lds	r26, 0x08EC
    279c:	b0 91 ed 08 	lds	r27, 0x08ED
    27a0:	52 96       	adiw	r26, 0x12	; 18
    27a2:	3c 91       	ld	r19, X
    27a4:	52 97       	sbiw	r26, 0x12	; 18
    27a6:	83 2f       	mov	r24, r19
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	2a 81       	ldd	r18, Y+2	; 0x02
    27ac:	fc 01       	movw	r30, r24
    27ae:	ea 50       	subi	r30, 0x0A	; 10
    27b0:	f7 4f       	sbci	r31, 0xF7	; 247
    27b2:	20 83       	st	Z, r18
    27b4:	83 2f       	mov	r24, r19
    27b6:	8f 5f       	subi	r24, 0xFF	; 255
    27b8:	52 96       	adiw	r26, 0x12	; 18
    27ba:	8c 93       	st	X, r24
    27bc:	52 97       	sbiw	r26, 0x12	; 18
			//if buffer is full or this is the last byte, then send buffer (this will reset buffer index)
			if (   ( apl->len >= CONFIG_PAYLOAD_LEN - 1 )   ||    ( apl->remaining_bytes_to_be_sent == 0 )   )  {
    27be:	e0 91 ec 08 	lds	r30, 0x08EC
    27c2:	f0 91 ed 08 	lds	r31, 0x08ED
    27c6:	82 89       	ldd	r24, Z+18	; 0x12
    27c8:	8f 37       	cpi	r24, 0x7F	; 127
    27ca:	58 f4       	brcc	.+22     	; 0x27e2 <APLPoll+0x1238>
    27cc:	80 91 ec 08 	lds	r24, 0x08EC
    27d0:	90 91 ed 08 	lds	r25, 0x08ED
    27d4:	fc 01       	movw	r30, r24
    27d6:	e2 5e       	subi	r30, 0xE2	; 226
    27d8:	fe 4f       	sbci	r31, 0xFE	; 254
    27da:	80 81       	ld	r24, Z
    27dc:	91 81       	ldd	r25, Z+1	; 0x01
    27de:	00 97       	sbiw	r24, 0x00	; 0
    27e0:	11 f4       	brne	.+4      	; 0x27e6 <APLPoll+0x123c>
				SendBuffer ();
    27e2:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <SendBuffer>
			}
			//if we are done expecting bytes, exit send mode
			if (0 == apl->remaining_bytes_to_be_sent) {
    27e6:	80 91 ec 08 	lds	r24, 0x08EC
    27ea:	90 91 ed 08 	lds	r25, 0x08ED
    27ee:	fc 01       	movw	r30, r24
    27f0:	e2 5e       	subi	r30, 0xE2	; 226
    27f2:	fe 4f       	sbci	r31, 0xFE	; 254
    27f4:	80 81       	ld	r24, Z
    27f6:	91 81       	ldd	r25, Z+1	; 0x01
    27f8:	00 97       	sbiw	r24, 0x00	; 0
    27fa:	41 f5       	brne	.+80     	; 0x284c <APLPoll+0x12a2>
				sprintf (apl->outpkt.params, "sent");
    27fc:	80 91 ec 08 	lds	r24, 0x08EC
    2800:	90 91 ed 08 	lds	r25, 0x08ED
    2804:	82 96       	adiw	r24, 0x22	; 34
    2806:	23 e6       	ldi	r18, 0x63	; 99
    2808:	36 e0       	ldi	r19, 0x06	; 6
    280a:	b9 01       	movw	r22, r18
    280c:	45 e0       	ldi	r20, 0x05	; 5
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
		        	sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, Sf_packet_unsolicited_msg_tag);
    2814:	80 91 ec 08 	lds	r24, 0x08EC
    2818:	90 91 ed 08 	lds	r25, 0x08ED
    281c:	8c 01       	movw	r16, r24
    281e:	0e 5d       	subi	r16, 0xDE	; 222
    2820:	1f 4f       	sbci	r17, 0xFF	; 255
    2822:	80 91 ec 08 	lds	r24, 0x08EC
    2826:	90 91 ed 08 	lds	r25, 0x08ED
    282a:	82 96       	adiw	r24, 0x22	; 34
    282c:	0e 94 eb 44 	call	0x89d6	; 0x89d6 <strlen>
    2830:	01 96       	adiw	r24, 0x01	; 1
    2832:	9c 01       	movw	r18, r24
    2834:	c8 01       	movw	r24, r16
    2836:	b9 01       	movw	r22, r18
    2838:	41 e0       	ldi	r20, 0x01	; 1
    283a:	2f ef       	ldi	r18, 0xFF	; 255
    283c:	0e 94 d2 05 	call	0xba4	; 0xba4 <sendToARM>
				apl->mode = talk_to_ARM;
    2840:	e0 91 ec 08 	lds	r30, 0x08EC
    2844:	f0 91 ed 08 	lds	r31, 0x08ED
    2848:	86 e0       	ldi	r24, 0x06	; 6
    284a:	80 8b       	std	Z+16, r24	; 0x10
			SendBuffer ();
		}
	}
	else if (send_incoming_chars == apl->mode)
	{
		while (kbhit()) {
    284c:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	09 f0       	breq	.+2      	; 0x2856 <APLPoll+0x12ac>
    2854:	8a cf       	rjmp	.-236    	; 0x276a <APLPoll+0x11c0>
    2856:	ca c1       	rjmp	.+916    	; 0x2bec <APLPoll+0x1642>
		        	sendToARM (apl->outpkt.params, strlen(apl->outpkt.params) + 1, ack, Sf_packet_unsolicited_msg_tag);
				apl->mode = talk_to_ARM;
			}
		}	
	}
        else if (request_two_way_range == apl->mode)
    2858:	e0 91 ec 08 	lds	r30, 0x08EC
    285c:	f0 91 ed 08 	lds	r31, 0x08ED
    2860:	80 89       	ldd	r24, Z+16	; 0x10
    2862:	82 30       	cpi	r24, 0x02	; 2
    2864:	09 f0       	breq	.+2      	; 0x2868 <APLPoll+0x12be>
    2866:	75 c0       	rjmp	.+234    	; 0x2952 <APLPoll+0x13a8>
	{
		/* In ptes mode sends 100 range to peer */

		if ((apl->hwclock + TIME_OUT < hwclock ()) && (packets_sent < 101))
    2868:	e0 91 ec 08 	lds	r30, 0x08EC
    286c:	f0 91 ed 08 	lds	r31, 0x08ED
    2870:	80 81       	ld	r24, Z
    2872:	91 81       	ldd	r25, Z+1	; 0x01
    2874:	a2 81       	ldd	r26, Z+2	; 0x02
    2876:	b3 81       	ldd	r27, Z+3	; 0x03
    2878:	0f 2e       	mov	r0, r31
    287a:	f4 e1       	ldi	r31, 0x14	; 20
    287c:	ef 2e       	mov	r14, r31
    287e:	f0 e0       	ldi	r31, 0x00	; 0
    2880:	ff 2e       	mov	r15, r31
    2882:	f0 e0       	ldi	r31, 0x00	; 0
    2884:	0f 2f       	mov	r16, r31
    2886:	f0 e0       	ldi	r31, 0x00	; 0
    2888:	1f 2f       	mov	r17, r31
    288a:	f0 2d       	mov	r31, r0
    288c:	e8 0e       	add	r14, r24
    288e:	f9 1e       	adc	r15, r25
    2890:	0a 1f       	adc	r16, r26
    2892:	1b 1f       	adc	r17, r27
    2894:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    2898:	dc 01       	movw	r26, r24
    289a:	cb 01       	movw	r24, r22
    289c:	e8 16       	cp	r14, r24
    289e:	f9 06       	cpc	r15, r25
    28a0:	0a 07       	cpc	r16, r26
    28a2:	1b 07       	cpc	r17, r27
    28a4:	c0 f4       	brcc	.+48     	; 0x28d6 <APLPoll+0x132c>
    28a6:	80 91 bf 01 	lds	r24, 0x01BF
    28aa:	85 36       	cpi	r24, 0x65	; 101
    28ac:	a0 f4       	brcc	.+40     	; 0x28d6 <APLPoll+0x132c>
		{
			packets_sent++;
    28ae:	80 91 bf 01 	lds	r24, 0x01BF
    28b2:	8f 5f       	subi	r24, 0xFF	; 255
    28b4:	80 93 bf 01 	sts	0x01BF, r24
			SendRange ();
    28b8:	0e 94 2b 0a 	call	0x1456	; 0x1456 <SendRange>
			/* reset timer */
			apl->hwclock = hwclock ();
    28bc:	00 91 ec 08 	lds	r16, 0x08EC
    28c0:	10 91 ed 08 	lds	r17, 0x08ED
    28c4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    28c8:	dc 01       	movw	r26, r24
    28ca:	cb 01       	movw	r24, r22
    28cc:	f8 01       	movw	r30, r16
    28ce:	80 83       	st	Z, r24
    28d0:	91 83       	std	Z+1, r25	; 0x01
    28d2:	a2 83       	std	Z+2, r26	; 0x02
    28d4:	b3 83       	std	Z+3, r27	; 0x03
		}

		if(packets_sent >= 101)
    28d6:	80 91 bf 01 	lds	r24, 0x01BF
    28da:	85 36       	cpi	r24, 0x65	; 101
    28dc:	08 f4       	brcc	.+2      	; 0x28e0 <APLPoll+0x1336>
    28de:	86 c1       	rjmp	.+780    	; 0x2bec <APLPoll+0x1642>
		{
			printf("Sent %d range reqs.\n", packets_sent-1);
    28e0:	80 91 bf 01 	lds	r24, 0x01BF
    28e4:	88 2f       	mov	r24, r24
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	9c 01       	movw	r18, r24
    28ea:	21 50       	subi	r18, 0x01	; 1
    28ec:	30 40       	sbci	r19, 0x00	; 0
    28ee:	00 d0       	rcall	.+0      	; 0x28f0 <APLPoll+0x1346>
    28f0:	00 d0       	rcall	.+0      	; 0x28f2 <APLPoll+0x1348>
    28f2:	ed b7       	in	r30, 0x3d	; 61
    28f4:	fe b7       	in	r31, 0x3e	; 62
    28f6:	31 96       	adiw	r30, 0x01	; 1
    28f8:	88 e6       	ldi	r24, 0x68	; 104
    28fa:	96 e0       	ldi	r25, 0x06	; 6
    28fc:	91 83       	std	Z+1, r25	; 0x01
    28fe:	80 83       	st	Z, r24
    2900:	33 83       	std	Z+3, r19	; 0x03
    2902:	22 83       	std	Z+2, r18	; 0x02
    2904:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    2908:	0f 90       	pop	r0
    290a:	0f 90       	pop	r0
    290c:	0f 90       	pop	r0
    290e:	0f 90       	pop	r0
			packets_sent = 0;
    2910:	10 92 bf 01 	sts	0x01BF, r1
			apl->mode = terminal;
    2914:	e0 91 ec 08 	lds	r30, 0x08EC
    2918:	f0 91 ed 08 	lds	r31, 0x08ED
    291c:	10 8a       	std	Z+16, r1	; 0x10
			apl->len = 0;
    291e:	e0 91 ec 08 	lds	r30, 0x08EC
    2922:	f0 91 ed 08 	lds	r31, 0x08ED
    2926:	12 8a       	std	Z+18, r1	; 0x12
			printf ("\nEnd of range test.\n");
    2928:	8d e7       	ldi	r24, 0x7D	; 125
    292a:	96 e0       	ldi	r25, 0x06	; 6
    292c:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			/* switch off receiver */
			downMsg.prim = PLME_SET_REQUEST;
    2930:	8b e0       	ldi	r24, 0x0B	; 11
    2932:	80 93 ee 08 	sts	0x08EE, r24
			downMsg.attribute = PHY_RX_CMD;
    2936:	81 e9       	ldi	r24, 0x91	; 145
    2938:	80 93 79 09 	sts	0x0979, r24
			downMsg.value = PHY_TRX_OFF;
    293c:	88 e0       	ldi	r24, 0x08	; 8
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	90 93 78 09 	sts	0x0978, r25
    2944:	80 93 77 09 	sts	0x0977, r24
			PLMESap (&downMsg);
    2948:	8e ee       	ldi	r24, 0xEE	; 238
    294a:	98 e0       	ldi	r25, 0x08	; 8
    294c:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2950:	4d c1       	rjmp	.+666    	; 0x2bec <APLPoll+0x1642>
		}
		return;
	}
        else if (request_fast_range == apl->mode)
    2952:	e0 91 ec 08 	lds	r30, 0x08EC
    2956:	f0 91 ed 08 	lds	r31, 0x08ED
    295a:	80 89       	ldd	r24, Z+16	; 0x10
    295c:	83 30       	cpi	r24, 0x03	; 3
    295e:	09 f0       	breq	.+2      	; 0x2962 <APLPoll+0x13b8>
    2960:	72 c0       	rjmp	.+228    	; 0x2a46 <APLPoll+0x149c>
	{
			/* In ptes mode sends 100 range to peer */

			if ((apl->hwclock + TIME_OUT < hwclock ()) && (packets_sent < 101))
    2962:	e0 91 ec 08 	lds	r30, 0x08EC
    2966:	f0 91 ed 08 	lds	r31, 0x08ED
    296a:	80 81       	ld	r24, Z
    296c:	91 81       	ldd	r25, Z+1	; 0x01
    296e:	a2 81       	ldd	r26, Z+2	; 0x02
    2970:	b3 81       	ldd	r27, Z+3	; 0x03
    2972:	0f 2e       	mov	r0, r31
    2974:	f4 e1       	ldi	r31, 0x14	; 20
    2976:	ef 2e       	mov	r14, r31
    2978:	f0 e0       	ldi	r31, 0x00	; 0
    297a:	ff 2e       	mov	r15, r31
    297c:	f0 e0       	ldi	r31, 0x00	; 0
    297e:	0f 2f       	mov	r16, r31
    2980:	f0 e0       	ldi	r31, 0x00	; 0
    2982:	1f 2f       	mov	r17, r31
    2984:	f0 2d       	mov	r31, r0
    2986:	e8 0e       	add	r14, r24
    2988:	f9 1e       	adc	r15, r25
    298a:	0a 1f       	adc	r16, r26
    298c:	1b 1f       	adc	r17, r27
    298e:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    2992:	dc 01       	movw	r26, r24
    2994:	cb 01       	movw	r24, r22
    2996:	e8 16       	cp	r14, r24
    2998:	f9 06       	cpc	r15, r25
    299a:	0a 07       	cpc	r16, r26
    299c:	1b 07       	cpc	r17, r27
    299e:	c0 f4       	brcc	.+48     	; 0x29d0 <APLPoll+0x1426>
    29a0:	80 91 bf 01 	lds	r24, 0x01BF
    29a4:	85 36       	cpi	r24, 0x65	; 101
    29a6:	a0 f4       	brcc	.+40     	; 0x29d0 <APLPoll+0x1426>
			{
				packets_sent++;
    29a8:	80 91 bf 01 	lds	r24, 0x01BF
    29ac:	8f 5f       	subi	r24, 0xFF	; 255
    29ae:	80 93 bf 01 	sts	0x01BF, r24
				SendFastRange ();
    29b2:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <SendFastRange>
				/* reset timer */
				apl->hwclock = hwclock ();
    29b6:	00 91 ec 08 	lds	r16, 0x08EC
    29ba:	10 91 ed 08 	lds	r17, 0x08ED
    29be:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    29c2:	dc 01       	movw	r26, r24
    29c4:	cb 01       	movw	r24, r22
    29c6:	f8 01       	movw	r30, r16
    29c8:	80 83       	st	Z, r24
    29ca:	91 83       	std	Z+1, r25	; 0x01
    29cc:	a2 83       	std	Z+2, r26	; 0x02
    29ce:	b3 83       	std	Z+3, r27	; 0x03
			}

			if(packets_sent >= 101)
    29d0:	80 91 bf 01 	lds	r24, 0x01BF
    29d4:	85 36       	cpi	r24, 0x65	; 101
    29d6:	08 f4       	brcc	.+2      	; 0x29da <APLPoll+0x1430>
    29d8:	09 c1       	rjmp	.+530    	; 0x2bec <APLPoll+0x1642>
			{
				printf("Sent %d range reqs.\n", packets_sent);
    29da:	80 91 bf 01 	lds	r24, 0x01BF
    29de:	28 2f       	mov	r18, r24
    29e0:	30 e0       	ldi	r19, 0x00	; 0
    29e2:	00 d0       	rcall	.+0      	; 0x29e4 <APLPoll+0x143a>
    29e4:	00 d0       	rcall	.+0      	; 0x29e6 <APLPoll+0x143c>
    29e6:	ed b7       	in	r30, 0x3d	; 61
    29e8:	fe b7       	in	r31, 0x3e	; 62
    29ea:	31 96       	adiw	r30, 0x01	; 1
    29ec:	88 e6       	ldi	r24, 0x68	; 104
    29ee:	96 e0       	ldi	r25, 0x06	; 6
    29f0:	91 83       	std	Z+1, r25	; 0x01
    29f2:	80 83       	st	Z, r24
    29f4:	33 83       	std	Z+3, r19	; 0x03
    29f6:	22 83       	std	Z+2, r18	; 0x02
    29f8:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	0f 90       	pop	r0
    2a02:	0f 90       	pop	r0
				packets_sent = 0;
    2a04:	10 92 bf 01 	sts	0x01BF, r1
				apl->mode = terminal;
    2a08:	e0 91 ec 08 	lds	r30, 0x08EC
    2a0c:	f0 91 ed 08 	lds	r31, 0x08ED
    2a10:	10 8a       	std	Z+16, r1	; 0x10
				apl->len = 0;
    2a12:	e0 91 ec 08 	lds	r30, 0x08EC
    2a16:	f0 91 ed 08 	lds	r31, 0x08ED
    2a1a:	12 8a       	std	Z+18, r1	; 0x12
				printf ("\nEnd of range test.\n");
    2a1c:	8d e7       	ldi	r24, 0x7D	; 125
    2a1e:	96 e0       	ldi	r25, 0x06	; 6
    2a20:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
				/* switch off receiver */
				downMsg.prim = PLME_SET_REQUEST;
    2a24:	8b e0       	ldi	r24, 0x0B	; 11
    2a26:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    2a2a:	81 e9       	ldi	r24, 0x91	; 145
    2a2c:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_TRX_OFF;
    2a30:	88 e0       	ldi	r24, 0x08	; 8
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	90 93 78 09 	sts	0x0978, r25
    2a38:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    2a3c:	8e ee       	ldi	r24, 0xEE	; 238
    2a3e:	98 e0       	ldi	r25, 0x08	; 8
    2a40:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2a44:	d3 c0       	rjmp	.+422    	; 0x2bec <APLPoll+0x1642>
			}
			return;
	}
	else if (spray == apl->mode)
    2a46:	e0 91 ec 08 	lds	r30, 0x08EC
    2a4a:	f0 91 ed 08 	lds	r31, 0x08ED
    2a4e:	80 89       	ldd	r24, Z+16	; 0x10
    2a50:	85 30       	cpi	r24, 0x05	; 5
    2a52:	09 f0       	breq	.+2      	; 0x2a56 <APLPoll+0x14ac>
    2a54:	93 c0       	rjmp	.+294    	; 0x2b7c <APLPoll+0x15d2>
	{
		/* In ptes mode sends 100 packets to peer */

		if( (apl->len == 0) && (packets_sent < 100) )
    2a56:	e0 91 ec 08 	lds	r30, 0x08EC
    2a5a:	f0 91 ed 08 	lds	r31, 0x08ED
    2a5e:	82 89       	ldd	r24, Z+18	; 0x12
    2a60:	88 23       	and	r24, r24
    2a62:	b9 f4       	brne	.+46     	; 0x2a92 <APLPoll+0x14e8>
    2a64:	80 91 bf 01 	lds	r24, 0x01BF
    2a68:	84 36       	cpi	r24, 0x64	; 100
    2a6a:	98 f4       	brcc	.+38     	; 0x2a92 <APLPoll+0x14e8>
		{
			downMsg.data[apl->len++] = packets_sent;
    2a6c:	a0 91 ec 08 	lds	r26, 0x08EC
    2a70:	b0 91 ed 08 	lds	r27, 0x08ED
    2a74:	52 96       	adiw	r26, 0x12	; 18
    2a76:	3c 91       	ld	r19, X
    2a78:	52 97       	sbiw	r26, 0x12	; 18
    2a7a:	83 2f       	mov	r24, r19
    2a7c:	90 e0       	ldi	r25, 0x00	; 0
    2a7e:	20 91 bf 01 	lds	r18, 0x01BF
    2a82:	fc 01       	movw	r30, r24
    2a84:	ea 50       	subi	r30, 0x0A	; 10
    2a86:	f7 4f       	sbci	r31, 0xF7	; 247
    2a88:	20 83       	st	Z, r18
    2a8a:	83 2f       	mov	r24, r19
    2a8c:	8f 5f       	subi	r24, 0xFF	; 255
    2a8e:	52 96       	adiw	r26, 0x12	; 18
    2a90:	8c 93       	st	X, r24
		}

		if ((apl->hwclock + TIME_OUT < hwclock ()) && (apl->len > 0))
    2a92:	e0 91 ec 08 	lds	r30, 0x08EC
    2a96:	f0 91 ed 08 	lds	r31, 0x08ED
    2a9a:	80 81       	ld	r24, Z
    2a9c:	91 81       	ldd	r25, Z+1	; 0x01
    2a9e:	a2 81       	ldd	r26, Z+2	; 0x02
    2aa0:	b3 81       	ldd	r27, Z+3	; 0x03
    2aa2:	0f 2e       	mov	r0, r31
    2aa4:	f4 e1       	ldi	r31, 0x14	; 20
    2aa6:	ef 2e       	mov	r14, r31
    2aa8:	f0 e0       	ldi	r31, 0x00	; 0
    2aaa:	ff 2e       	mov	r15, r31
    2aac:	f0 e0       	ldi	r31, 0x00	; 0
    2aae:	0f 2f       	mov	r16, r31
    2ab0:	f0 e0       	ldi	r31, 0x00	; 0
    2ab2:	1f 2f       	mov	r17, r31
    2ab4:	f0 2d       	mov	r31, r0
    2ab6:	e8 0e       	add	r14, r24
    2ab8:	f9 1e       	adc	r15, r25
    2aba:	0a 1f       	adc	r16, r26
    2abc:	1b 1f       	adc	r17, r27
    2abe:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    2ac2:	dc 01       	movw	r26, r24
    2ac4:	cb 01       	movw	r24, r22
    2ac6:	e8 16       	cp	r14, r24
    2ac8:	f9 06       	cpc	r15, r25
    2aca:	0a 07       	cpc	r16, r26
    2acc:	1b 07       	cpc	r17, r27
    2ace:	d8 f4       	brcc	.+54     	; 0x2b06 <APLPoll+0x155c>
    2ad0:	e0 91 ec 08 	lds	r30, 0x08EC
    2ad4:	f0 91 ed 08 	lds	r31, 0x08ED
    2ad8:	82 89       	ldd	r24, Z+18	; 0x12
    2ada:	88 23       	and	r24, r24
    2adc:	a1 f0       	breq	.+40     	; 0x2b06 <APLPoll+0x155c>
		{
			packets_sent++;
    2ade:	80 91 bf 01 	lds	r24, 0x01BF
    2ae2:	8f 5f       	subi	r24, 0xFF	; 255
    2ae4:	80 93 bf 01 	sts	0x01BF, r24
			SendBuffer ();
    2ae8:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <SendBuffer>
			/* reset timer */
			apl->hwclock = hwclock ();
    2aec:	00 91 ec 08 	lds	r16, 0x08EC
    2af0:	10 91 ed 08 	lds	r17, 0x08ED
    2af4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    2af8:	dc 01       	movw	r26, r24
    2afa:	cb 01       	movw	r24, r22
    2afc:	f8 01       	movw	r30, r16
    2afe:	80 83       	st	Z, r24
    2b00:	91 83       	std	Z+1, r25	; 0x01
    2b02:	a2 83       	std	Z+2, r26	; 0x02
    2b04:	b3 83       	std	Z+3, r27	; 0x03
		}

		if(packets_sent >= 100)
    2b06:	80 91 bf 01 	lds	r24, 0x01BF
    2b0a:	84 36       	cpi	r24, 0x64	; 100
    2b0c:	08 f4       	brcc	.+2      	; 0x2b10 <APLPoll+0x1566>
    2b0e:	6e c0       	rjmp	.+220    	; 0x2bec <APLPoll+0x1642>
		{
			printf("Sent %d packets.\n", packets_sent);
    2b10:	80 91 bf 01 	lds	r24, 0x01BF
    2b14:	28 2f       	mov	r18, r24
    2b16:	30 e0       	ldi	r19, 0x00	; 0
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <APLPoll+0x1570>
    2b1a:	00 d0       	rcall	.+0      	; 0x2b1c <APLPoll+0x1572>
    2b1c:	ed b7       	in	r30, 0x3d	; 61
    2b1e:	fe b7       	in	r31, 0x3e	; 62
    2b20:	31 96       	adiw	r30, 0x01	; 1
    2b22:	81 e9       	ldi	r24, 0x91	; 145
    2b24:	96 e0       	ldi	r25, 0x06	; 6
    2b26:	91 83       	std	Z+1, r25	; 0x01
    2b28:	80 83       	st	Z, r24
    2b2a:	33 83       	std	Z+3, r19	; 0x03
    2b2c:	22 83       	std	Z+2, r18	; 0x02
    2b2e:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	0f 90       	pop	r0
			packets_sent = 0;
    2b3a:	10 92 bf 01 	sts	0x01BF, r1
			apl->mode = terminal;
    2b3e:	e0 91 ec 08 	lds	r30, 0x08EC
    2b42:	f0 91 ed 08 	lds	r31, 0x08ED
    2b46:	10 8a       	std	Z+16, r1	; 0x10
			apl->len = 0;
    2b48:	e0 91 ec 08 	lds	r30, 0x08EC
    2b4c:	f0 91 ed 08 	lds	r31, 0x08ED
    2b50:	12 8a       	std	Z+18, r1	; 0x12
			printf ("\nEnd of packet test.\n");
    2b52:	83 ea       	ldi	r24, 0xA3	; 163
    2b54:	96 e0       	ldi	r25, 0x06	; 6
    2b56:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
			/* switch off receiver */
			downMsg.prim = PLME_SET_REQUEST;
    2b5a:	8b e0       	ldi	r24, 0x0B	; 11
    2b5c:	80 93 ee 08 	sts	0x08EE, r24
			downMsg.attribute = PHY_RX_CMD;
    2b60:	81 e9       	ldi	r24, 0x91	; 145
    2b62:	80 93 79 09 	sts	0x0979, r24
			downMsg.value = PHY_TRX_OFF;
    2b66:	88 e0       	ldi	r24, 0x08	; 8
    2b68:	90 e0       	ldi	r25, 0x00	; 0
    2b6a:	90 93 78 09 	sts	0x0978, r25
    2b6e:	80 93 77 09 	sts	0x0977, r24
			PLMESap (&downMsg);
    2b72:	8e ee       	ldi	r24, 0xEE	; 238
    2b74:	98 e0       	ldi	r25, 0x08	; 8
    2b76:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2b7a:	38 c0       	rjmp	.+112    	; 0x2bec <APLPoll+0x1642>
		}
		return;

	}
        else if (listen_for_range_requests == apl->mode)
    2b7c:	e0 91 ec 08 	lds	r30, 0x08EC
    2b80:	f0 91 ed 08 	lds	r31, 0x08ED
    2b84:	80 89       	ldd	r24, Z+16	; 0x10
    2b86:	84 30       	cpi	r24, 0x04	; 4
    2b88:	89 f5       	brne	.+98     	; 0x2bec <APLPoll+0x1642>
    2b8a:	2c c0       	rjmp	.+88     	; 0x2be4 <APLPoll+0x163a>
	{
		while (kbhit())
		{
			c = getchar ();
    2b8c:	80 91 5a 10 	lds	r24, 0x105A
    2b90:	90 91 5b 10 	lds	r25, 0x105B
    2b94:	0e 94 15 45 	call	0x8a2a	; 0x8a2a <fgetc>
    2b98:	9b 83       	std	Y+3, r25	; 0x03
    2b9a:	8a 83       	std	Y+2, r24	; 0x02
			if (c == 0x1b)
    2b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b9e:	9b 81       	ldd	r25, Y+3	; 0x03
    2ba0:	8b 31       	cpi	r24, 0x1B	; 27
    2ba2:	91 05       	cpc	r25, r1
    2ba4:	f9 f4       	brne	.+62     	; 0x2be4 <APLPoll+0x163a>
			{
				apl->mode = terminal;
    2ba6:	e0 91 ec 08 	lds	r30, 0x08EC
    2baa:	f0 91 ed 08 	lds	r31, 0x08ED
    2bae:	10 8a       	std	Z+16, r1	; 0x10
				apl->len = 0;
    2bb0:	e0 91 ec 08 	lds	r30, 0x08EC
    2bb4:	f0 91 ed 08 	lds	r31, 0x08ED
    2bb8:	12 8a       	std	Z+18, r1	; 0x12
				puts ("end listen");
    2bba:	88 eb       	ldi	r24, 0xB8	; 184
    2bbc:	96 e0       	ldi	r25, 0x06	; 6
    2bbe:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
				/* switch off receiver */
				downMsg.prim = PLME_SET_REQUEST;
    2bc2:	8b e0       	ldi	r24, 0x0B	; 11
    2bc4:	80 93 ee 08 	sts	0x08EE, r24
				downMsg.attribute = PHY_RX_CMD;
    2bc8:	81 e9       	ldi	r24, 0x91	; 145
    2bca:	80 93 79 09 	sts	0x0979, r24
				downMsg.value = PHY_TRX_OFF;
    2bce:	88 e0       	ldi	r24, 0x08	; 8
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	90 93 78 09 	sts	0x0978, r25
    2bd6:	80 93 77 09 	sts	0x0977, r24
				PLMESap (&downMsg);
    2bda:	8e ee       	ldi	r24, 0xEE	; 238
    2bdc:	98 e0       	ldi	r25, 0x08	; 8
    2bde:	0e 94 5e 20 	call	0x40bc	; 0x40bc <PLMESap>
    2be2:	04 c0       	rjmp	.+8      	; 0x2bec <APLPoll+0x1642>
		return;

	}
        else if (listen_for_range_requests == apl->mode)
	{
		while (kbhit())
    2be4:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    2be8:	00 97       	sbiw	r24, 0x00	; 0
    2bea:	81 f6       	brne	.-96     	; 0x2b8c <APLPoll+0x15e2>
				PLMESap (&downMsg);
				return;
			}
		}
	}
}
    2bec:	60 96       	adiw	r28, 0x10	; 16
    2bee:	0f b6       	in	r0, 0x3f	; 63
    2bf0:	f8 94       	cli
    2bf2:	de bf       	out	0x3e, r29	; 62
    2bf4:	0f be       	out	0x3f, r0	; 63
    2bf6:	cd bf       	out	0x3d, r28	; 61
    2bf8:	cf 91       	pop	r28
    2bfa:	df 91       	pop	r29
    2bfc:	1f 91       	pop	r17
    2bfe:	0f 91       	pop	r16
    2c00:	ff 90       	pop	r15
    2c02:	ef 90       	pop	r14
    2c04:	08 95       	ret

00002c06 <HWDelayus>:
 * Because of the high inaccuracy of the delay function
 * this function tries to compensate the delay error
 * by adding an offset.
 */
void HWDelayus( MyWord16T us )
{
    2c06:	df 93       	push	r29
    2c08:	cf 93       	push	r28
    2c0a:	00 d0       	rcall	.+0      	; 0x2c0c <HWDelayus+0x6>
    2c0c:	00 d0       	rcall	.+0      	; 0x2c0e <HWDelayus+0x8>
    2c0e:	00 d0       	rcall	.+0      	; 0x2c10 <HWDelayus+0xa>
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
    2c14:	9e 83       	std	Y+6, r25	; 0x06
    2c16:	8d 83       	std	Y+5, r24	; 0x05
	MyWord16T ti;

	if( us == 0 ) return;
    2c18:	8d 81       	ldd	r24, Y+5	; 0x05
    2c1a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c1c:	00 97       	sbiw	r24, 0x00	; 0
    2c1e:	a1 f1       	breq	.+104    	; 0x2c88 <HWDelayus+0x82>
	 * this is for the loop processing time
	 * Delays in ms are about 10% longer.
	 * Delays in us between 100% down to 10%.
	 * _delay_us seams to be not very accurate.
	 */
	ti = us << 1;
    2c20:	8d 81       	ldd	r24, Y+5	; 0x05
    2c22:	9e 81       	ldd	r25, Y+6	; 0x06
    2c24:	88 0f       	add	r24, r24
    2c26:	99 1f       	adc	r25, r25
    2c28:	9c 83       	std	Y+4, r25	; 0x04
    2c2a:	8b 83       	std	Y+3, r24	; 0x03
	if( us > 90 )
    2c2c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c2e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c30:	8b 35       	cpi	r24, 0x5B	; 91
    2c32:	91 05       	cpc	r25, r1
    2c34:	d0 f0       	brcs	.+52     	; 0x2c6a <HWDelayus+0x64>
	{
		ti += (us >> 2);
    2c36:	8d 81       	ldd	r24, Y+5	; 0x05
    2c38:	9e 81       	ldd	r25, Y+6	; 0x06
    2c3a:	9c 01       	movw	r18, r24
    2c3c:	36 95       	lsr	r19
    2c3e:	27 95       	ror	r18
    2c40:	36 95       	lsr	r19
    2c42:	27 95       	ror	r18
    2c44:	8b 81       	ldd	r24, Y+3	; 0x03
    2c46:	9c 81       	ldd	r25, Y+4	; 0x04
    2c48:	82 0f       	add	r24, r18
    2c4a:	93 1f       	adc	r25, r19
    2c4c:	9c 83       	std	Y+4, r25	; 0x04
    2c4e:	8b 83       	std	Y+3, r24	; 0x03
    2c50:	0c c0       	rjmp	.+24     	; 0x2c6a <HWDelayus+0x64>
	}

	while( ti > MAX_DELAY_US )
    2c52:	8d e6       	ldi	r24, 0x6D	; 109
    2c54:	8a 83       	std	Y+2, r24	; 0x02
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2c56:	8a 81       	ldd	r24, Y+2	; 0x02
    2c58:	8a 95       	dec	r24
    2c5a:	f1 f7       	brne	.-4      	; 0x2c58 <HWDelayus+0x52>
    2c5c:	8a 83       	std	Y+2, r24	; 0x02
	{
		_delay_loop_1( MAX_DELAY_US );
		ti -= MAX_DELAY_US;
    2c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c60:	9c 81       	ldd	r25, Y+4	; 0x04
    2c62:	8d 56       	subi	r24, 0x6D	; 109
    2c64:	90 40       	sbci	r25, 0x00	; 0
    2c66:	9c 83       	std	Y+4, r25	; 0x04
    2c68:	8b 83       	std	Y+3, r24	; 0x03
	if( us > 90 )
	{
		ti += (us >> 2);
	}

	while( ti > MAX_DELAY_US )
    2c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c6e:	8e 36       	cpi	r24, 0x6E	; 110
    2c70:	91 05       	cpc	r25, r1
    2c72:	78 f7       	brcc	.-34     	; 0x2c52 <HWDelayus+0x4c>
	{
		_delay_loop_1( MAX_DELAY_US );
		ti -= MAX_DELAY_US;
	}
	if( ti > 0 )
    2c74:	8b 81       	ldd	r24, Y+3	; 0x03
    2c76:	9c 81       	ldd	r25, Y+4	; 0x04
    2c78:	00 97       	sbiw	r24, 0x00	; 0
    2c7a:	31 f0       	breq	.+12     	; 0x2c88 <HWDelayus+0x82>
	{
		_delay_loop_1( ti );
    2c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7e:	89 83       	std	Y+1, r24	; 0x01
    2c80:	89 81       	ldd	r24, Y+1	; 0x01
    2c82:	8a 95       	dec	r24
    2c84:	f1 f7       	brne	.-4      	; 0x2c82 <HWDelayus+0x7c>
    2c86:	89 83       	std	Y+1, r24	; 0x01
	}
}
    2c88:	26 96       	adiw	r28, 0x06	; 6
    2c8a:	0f b6       	in	r0, 0x3f	; 63
    2c8c:	f8 94       	cli
    2c8e:	de bf       	out	0x3e, r29	; 62
    2c90:	0f be       	out	0x3f, r0	; 63
    2c92:	cd bf       	out	0x3d, r28	; 61
    2c94:	cf 91       	pop	r28
    2c96:	df 91       	pop	r29
    2c98:	08 95       	ret

00002c9a <HWDelayms>:
 *
 * This function is used for waiting before continue with
 * programm execution. Interrupts are still processed.
 */
void HWDelayms( MyWord16T ms )
{
    2c9a:	df 93       	push	r29
    2c9c:	cf 93       	push	r28
    2c9e:	cd b7       	in	r28, 0x3d	; 61
    2ca0:	de b7       	in	r29, 0x3e	; 62
    2ca2:	6e 97       	sbiw	r28, 0x1e	; 30
    2ca4:	0f b6       	in	r0, 0x3f	; 63
    2ca6:	f8 94       	cli
    2ca8:	de bf       	out	0x3e, r29	; 62
    2caa:	0f be       	out	0x3f, r0	; 63
    2cac:	cd bf       	out	0x3d, r28	; 61
    2cae:	9e 8f       	std	Y+30, r25	; 0x1e
    2cb0:	8d 8f       	std	Y+29, r24	; 0x1d
	if( ms == 0 ) return;
    2cb2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2cb4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2cb6:	00 97       	sbiw	r24, 0x00	; 0
    2cb8:	09 f4       	brne	.+2      	; 0x2cbc <HWDelayms+0x22>
    2cba:	fc c0       	rjmp	.+504    	; 0x2eb4 <HWDelayms+0x21a>
    2cbc:	77 c0       	rjmp	.+238    	; 0x2dac <HWDelayms+0x112>
	 * this is for the loop processing time
	 * Delays in ms are about 10% longer.
	 * Delays in us between 100% down to 10%.
	 * _delay_us seams to be not very accurate.
	 */
	while( ms > MAX_DELAY_MS )
    2cbe:	80 e0       	ldi	r24, 0x00	; 0
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	a4 e1       	ldi	r26, 0x14	; 20
    2cc4:	b2 e4       	ldi	r27, 0x42	; 66
    2cc6:	89 8f       	std	Y+25, r24	; 0x19
    2cc8:	9a 8f       	std	Y+26, r25	; 0x1a
    2cca:	ab 8f       	std	Y+27, r26	; 0x1b
    2ccc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2cce:	69 8d       	ldd	r22, Y+25	; 0x19
    2cd0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2cd2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2cd4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2cd6:	26 e6       	ldi	r18, 0x66	; 102
    2cd8:	36 e6       	ldi	r19, 0x66	; 102
    2cda:	46 ee       	ldi	r20, 0xE6	; 230
    2cdc:	54 e4       	ldi	r21, 0x44	; 68
    2cde:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    2ce2:	dc 01       	movw	r26, r24
    2ce4:	cb 01       	movw	r24, r22
    2ce6:	8d 8b       	std	Y+21, r24	; 0x15
    2ce8:	9e 8b       	std	Y+22, r25	; 0x16
    2cea:	af 8b       	std	Y+23, r26	; 0x17
    2cec:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2cee:	6d 89       	ldd	r22, Y+21	; 0x15
    2cf0:	7e 89       	ldd	r23, Y+22	; 0x16
    2cf2:	8f 89       	ldd	r24, Y+23	; 0x17
    2cf4:	98 8d       	ldd	r25, Y+24	; 0x18
    2cf6:	20 e0       	ldi	r18, 0x00	; 0
    2cf8:	30 e0       	ldi	r19, 0x00	; 0
    2cfa:	40 e8       	ldi	r20, 0x80	; 128
    2cfc:	5f e3       	ldi	r21, 0x3F	; 63
    2cfe:	0e 94 ba 41 	call	0x8374	; 0x8374 <__cmpsf2>
    2d02:	88 23       	and	r24, r24
    2d04:	2c f4       	brge	.+10     	; 0x2d10 <HWDelayms+0x76>
		__ticks = 1;
    2d06:	81 e0       	ldi	r24, 0x01	; 1
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	9c 8b       	std	Y+20, r25	; 0x14
    2d0c:	8b 8b       	std	Y+19, r24	; 0x13
    2d0e:	3f c0       	rjmp	.+126    	; 0x2d8e <HWDelayms+0xf4>
	else if (__tmp > 65535)
    2d10:	6d 89       	ldd	r22, Y+21	; 0x15
    2d12:	7e 89       	ldd	r23, Y+22	; 0x16
    2d14:	8f 89       	ldd	r24, Y+23	; 0x17
    2d16:	98 8d       	ldd	r25, Y+24	; 0x18
    2d18:	20 e0       	ldi	r18, 0x00	; 0
    2d1a:	3f ef       	ldi	r19, 0xFF	; 255
    2d1c:	4f e7       	ldi	r20, 0x7F	; 127
    2d1e:	57 e4       	ldi	r21, 0x47	; 71
    2d20:	0e 94 04 43 	call	0x8608	; 0x8608 <__gesf2>
    2d24:	18 16       	cp	r1, r24
    2d26:	4c f5       	brge	.+82     	; 0x2d7a <HWDelayms+0xe0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d28:	69 8d       	ldd	r22, Y+25	; 0x19
    2d2a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2d2c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d2e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2d30:	20 e0       	ldi	r18, 0x00	; 0
    2d32:	30 e0       	ldi	r19, 0x00	; 0
    2d34:	40 e2       	ldi	r20, 0x20	; 32
    2d36:	51 e4       	ldi	r21, 0x41	; 65
    2d38:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    2d3c:	dc 01       	movw	r26, r24
    2d3e:	cb 01       	movw	r24, r22
    2d40:	bc 01       	movw	r22, r24
    2d42:	cd 01       	movw	r24, r26
    2d44:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    2d48:	dc 01       	movw	r26, r24
    2d4a:	cb 01       	movw	r24, r22
    2d4c:	9c 8b       	std	Y+20, r25	; 0x14
    2d4e:	8b 8b       	std	Y+19, r24	; 0x13
    2d50:	0f c0       	rjmp	.+30     	; 0x2d70 <HWDelayms+0xd6>
    2d52:	88 eb       	ldi	r24, 0xB8	; 184
    2d54:	90 e0       	ldi	r25, 0x00	; 0
    2d56:	9a 8b       	std	Y+18, r25	; 0x12
    2d58:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2d5a:	89 89       	ldd	r24, Y+17	; 0x11
    2d5c:	9a 89       	ldd	r25, Y+18	; 0x12
    2d5e:	01 97       	sbiw	r24, 0x01	; 1
    2d60:	f1 f7       	brne	.-4      	; 0x2d5e <HWDelayms+0xc4>
    2d62:	9a 8b       	std	Y+18, r25	; 0x12
    2d64:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d66:	8b 89       	ldd	r24, Y+19	; 0x13
    2d68:	9c 89       	ldd	r25, Y+20	; 0x14
    2d6a:	01 97       	sbiw	r24, 0x01	; 1
    2d6c:	9c 8b       	std	Y+20, r25	; 0x14
    2d6e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2d70:	8b 89       	ldd	r24, Y+19	; 0x13
    2d72:	9c 89       	ldd	r25, Y+20	; 0x14
    2d74:	00 97       	sbiw	r24, 0x00	; 0
    2d76:	69 f7       	brne	.-38     	; 0x2d52 <HWDelayms+0xb8>
    2d78:	14 c0       	rjmp	.+40     	; 0x2da2 <HWDelayms+0x108>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2d7a:	6d 89       	ldd	r22, Y+21	; 0x15
    2d7c:	7e 89       	ldd	r23, Y+22	; 0x16
    2d7e:	8f 89       	ldd	r24, Y+23	; 0x17
    2d80:	98 8d       	ldd	r25, Y+24	; 0x18
    2d82:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    2d86:	dc 01       	movw	r26, r24
    2d88:	cb 01       	movw	r24, r22
    2d8a:	9c 8b       	std	Y+20, r25	; 0x14
    2d8c:	8b 8b       	std	Y+19, r24	; 0x13
    2d8e:	8b 89       	ldd	r24, Y+19	; 0x13
    2d90:	9c 89       	ldd	r25, Y+20	; 0x14
    2d92:	98 8b       	std	Y+16, r25	; 0x10
    2d94:	8f 87       	std	Y+15, r24	; 0x0f
    2d96:	8f 85       	ldd	r24, Y+15	; 0x0f
    2d98:	98 89       	ldd	r25, Y+16	; 0x10
    2d9a:	01 97       	sbiw	r24, 0x01	; 1
    2d9c:	f1 f7       	brne	.-4      	; 0x2d9a <HWDelayms+0x100>
    2d9e:	98 8b       	std	Y+16, r25	; 0x10
    2da0:	8f 87       	std	Y+15, r24	; 0x0f
	{
		_delay_ms( MAX_DELAY_MS );
		ms -= MAX_DELAY_MS;
    2da2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2da4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2da6:	85 97       	sbiw	r24, 0x25	; 37
    2da8:	9e 8f       	std	Y+30, r25	; 0x1e
    2daa:	8d 8f       	std	Y+29, r24	; 0x1d
	 * this is for the loop processing time
	 * Delays in ms are about 10% longer.
	 * Delays in us between 100% down to 10%.
	 * _delay_us seams to be not very accurate.
	 */
	while( ms > MAX_DELAY_MS )
    2dac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2dae:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2db0:	86 32       	cpi	r24, 0x26	; 38
    2db2:	91 05       	cpc	r25, r1
    2db4:	08 f0       	brcs	.+2      	; 0x2db8 <HWDelayms+0x11e>
    2db6:	83 cf       	rjmp	.-250    	; 0x2cbe <HWDelayms+0x24>
	{
		_delay_ms( MAX_DELAY_MS );
		ms -= MAX_DELAY_MS;
	}

	if( ms > 0 )
    2db8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2dba:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2dbc:	00 97       	sbiw	r24, 0x00	; 0
    2dbe:	09 f4       	brne	.+2      	; 0x2dc2 <HWDelayms+0x128>
    2dc0:	79 c0       	rjmp	.+242    	; 0x2eb4 <HWDelayms+0x21a>
	{
		_delay_ms( ms );
    2dc2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2dc4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2dc6:	cc 01       	movw	r24, r24
    2dc8:	a0 e0       	ldi	r26, 0x00	; 0
    2dca:	b0 e0       	ldi	r27, 0x00	; 0
    2dcc:	bc 01       	movw	r22, r24
    2dce:	cd 01       	movw	r24, r26
    2dd0:	0e 94 52 42 	call	0x84a4	; 0x84a4 <__floatunsisf>
    2dd4:	dc 01       	movw	r26, r24
    2dd6:	cb 01       	movw	r24, r22
    2dd8:	8b 87       	std	Y+11, r24	; 0x0b
    2dda:	9c 87       	std	Y+12, r25	; 0x0c
    2ddc:	ad 87       	std	Y+13, r26	; 0x0d
    2dde:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2de0:	6b 85       	ldd	r22, Y+11	; 0x0b
    2de2:	7c 85       	ldd	r23, Y+12	; 0x0c
    2de4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2de6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2de8:	26 e6       	ldi	r18, 0x66	; 102
    2dea:	36 e6       	ldi	r19, 0x66	; 102
    2dec:	46 ee       	ldi	r20, 0xE6	; 230
    2dee:	54 e4       	ldi	r21, 0x44	; 68
    2df0:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    2df4:	dc 01       	movw	r26, r24
    2df6:	cb 01       	movw	r24, r22
    2df8:	8f 83       	std	Y+7, r24	; 0x07
    2dfa:	98 87       	std	Y+8, r25	; 0x08
    2dfc:	a9 87       	std	Y+9, r26	; 0x09
    2dfe:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2e00:	6f 81       	ldd	r22, Y+7	; 0x07
    2e02:	78 85       	ldd	r23, Y+8	; 0x08
    2e04:	89 85       	ldd	r24, Y+9	; 0x09
    2e06:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e08:	20 e0       	ldi	r18, 0x00	; 0
    2e0a:	30 e0       	ldi	r19, 0x00	; 0
    2e0c:	40 e8       	ldi	r20, 0x80	; 128
    2e0e:	5f e3       	ldi	r21, 0x3F	; 63
    2e10:	0e 94 ba 41 	call	0x8374	; 0x8374 <__cmpsf2>
    2e14:	88 23       	and	r24, r24
    2e16:	2c f4       	brge	.+10     	; 0x2e22 <HWDelayms+0x188>
		__ticks = 1;
    2e18:	81 e0       	ldi	r24, 0x01	; 1
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	9e 83       	std	Y+6, r25	; 0x06
    2e1e:	8d 83       	std	Y+5, r24	; 0x05
    2e20:	3f c0       	rjmp	.+126    	; 0x2ea0 <HWDelayms+0x206>
	else if (__tmp > 65535)
    2e22:	6f 81       	ldd	r22, Y+7	; 0x07
    2e24:	78 85       	ldd	r23, Y+8	; 0x08
    2e26:	89 85       	ldd	r24, Y+9	; 0x09
    2e28:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e2a:	20 e0       	ldi	r18, 0x00	; 0
    2e2c:	3f ef       	ldi	r19, 0xFF	; 255
    2e2e:	4f e7       	ldi	r20, 0x7F	; 127
    2e30:	57 e4       	ldi	r21, 0x47	; 71
    2e32:	0e 94 04 43 	call	0x8608	; 0x8608 <__gesf2>
    2e36:	18 16       	cp	r1, r24
    2e38:	4c f5       	brge	.+82     	; 0x2e8c <HWDelayms+0x1f2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2e3a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2e3c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2e3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e40:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e42:	20 e0       	ldi	r18, 0x00	; 0
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	40 e2       	ldi	r20, 0x20	; 32
    2e48:	51 e4       	ldi	r21, 0x41	; 65
    2e4a:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    2e4e:	dc 01       	movw	r26, r24
    2e50:	cb 01       	movw	r24, r22
    2e52:	bc 01       	movw	r22, r24
    2e54:	cd 01       	movw	r24, r26
    2e56:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    2e5a:	dc 01       	movw	r26, r24
    2e5c:	cb 01       	movw	r24, r22
    2e5e:	9e 83       	std	Y+6, r25	; 0x06
    2e60:	8d 83       	std	Y+5, r24	; 0x05
    2e62:	0f c0       	rjmp	.+30     	; 0x2e82 <HWDelayms+0x1e8>
    2e64:	88 eb       	ldi	r24, 0xB8	; 184
    2e66:	90 e0       	ldi	r25, 0x00	; 0
    2e68:	9c 83       	std	Y+4, r25	; 0x04
    2e6a:	8b 83       	std	Y+3, r24	; 0x03
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	01 97       	sbiw	r24, 0x01	; 1
    2e72:	f1 f7       	brne	.-4      	; 0x2e70 <HWDelayms+0x1d6>
    2e74:	9c 83       	std	Y+4, r25	; 0x04
    2e76:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e78:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7c:	01 97       	sbiw	r24, 0x01	; 1
    2e7e:	9e 83       	std	Y+6, r25	; 0x06
    2e80:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e82:	8d 81       	ldd	r24, Y+5	; 0x05
    2e84:	9e 81       	ldd	r25, Y+6	; 0x06
    2e86:	00 97       	sbiw	r24, 0x00	; 0
    2e88:	69 f7       	brne	.-38     	; 0x2e64 <HWDelayms+0x1ca>
    2e8a:	14 c0       	rjmp	.+40     	; 0x2eb4 <HWDelayms+0x21a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e8c:	6f 81       	ldd	r22, Y+7	; 0x07
    2e8e:	78 85       	ldd	r23, Y+8	; 0x08
    2e90:	89 85       	ldd	r24, Y+9	; 0x09
    2e92:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e94:	0e 94 26 42 	call	0x844c	; 0x844c <__fixunssfsi>
    2e98:	dc 01       	movw	r26, r24
    2e9a:	cb 01       	movw	r24, r22
    2e9c:	9e 83       	std	Y+6, r25	; 0x06
    2e9e:	8d 83       	std	Y+5, r24	; 0x05
    2ea0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ea2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ea4:	9a 83       	std	Y+2, r25	; 0x02
    2ea6:	89 83       	std	Y+1, r24	; 0x01
    2ea8:	89 81       	ldd	r24, Y+1	; 0x01
    2eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    2eac:	01 97       	sbiw	r24, 0x01	; 1
    2eae:	f1 f7       	brne	.-4      	; 0x2eac <HWDelayms+0x212>
    2eb0:	9a 83       	std	Y+2, r25	; 0x02
    2eb2:	89 83       	std	Y+1, r24	; 0x01
	}
}
    2eb4:	6e 96       	adiw	r28, 0x1e	; 30
    2eb6:	0f b6       	in	r0, 0x3f	; 63
    2eb8:	f8 94       	cli
    2eba:	de bf       	out	0x3e, r29	; 62
    2ebc:	0f be       	out	0x3f, r0	; 63
    2ebe:	cd bf       	out	0x3d, r28	; 61
    2ec0:	cf 91       	pop	r28
    2ec2:	df 91       	pop	r29
    2ec4:	08 95       	ret

00002ec6 <hwclockRestart>:
 *
 * This function initializes the Timer 0 in the AVR to
 * generate an interrupt ever 10 ms.
 */
void hwclockRestart (MyDword32T start)
{
    2ec6:	df 93       	push	r29
    2ec8:	cf 93       	push	r28
    2eca:	00 d0       	rcall	.+0      	; 0x2ecc <hwclockRestart+0x6>
    2ecc:	00 d0       	rcall	.+0      	; 0x2ece <hwclockRestart+0x8>
    2ece:	cd b7       	in	r28, 0x3d	; 61
    2ed0:	de b7       	in	r29, 0x3e	; 62
    2ed2:	69 83       	std	Y+1, r22	; 0x01
    2ed4:	7a 83       	std	Y+2, r23	; 0x02
    2ed6:	8b 83       	std	Y+3, r24	; 0x03
    2ed8:	9c 83       	std	Y+4, r25	; 0x04
	AVR_TCCR0 = (1 << CS02) | (1 << CS00);  /* Timer0 clk/1024 normal mode int every 0.13888 ms */
    2eda:	e5 e4       	ldi	r30, 0x45	; 69
    2edc:	f0 e0       	ldi	r31, 0x00	; 0
    2ede:	85 e0       	ldi	r24, 0x05	; 5
    2ee0:	80 83       	st	Z, r24
	AVR_TCCR0 &= ~( 1 << CS01 );
    2ee2:	a5 e4       	ldi	r26, 0x45	; 69
    2ee4:	b0 e0       	ldi	r27, 0x00	; 0
    2ee6:	e5 e4       	ldi	r30, 0x45	; 69
    2ee8:	f0 e0       	ldi	r31, 0x00	; 0
    2eea:	80 81       	ld	r24, Z
    2eec:	8d 7f       	andi	r24, 0xFD	; 253
    2eee:	8c 93       	st	X, r24
	AVR_TIMSK = (1 << TOIE0);
    2ef0:	ee e6       	ldi	r30, 0x6E	; 110
    2ef2:	f0 e0       	ldi	r31, 0x00	; 0
    2ef4:	81 e0       	ldi	r24, 0x01	; 1
    2ef6:	80 83       	st	Z, r24
	AVR_TCNT0 = TICK_OFFSET; 					/* 10 ms at 8MHz */
    2ef8:	e6 e4       	ldi	r30, 0x46	; 70
    2efa:	f0 e0       	ldi	r31, 0x00	; 0
    2efc:	88 eb       	ldi	r24, 0xB8	; 184
    2efe:	80 83       	st	Z, r24

	jiffies = start;
    2f00:	89 81       	ldd	r24, Y+1	; 0x01
    2f02:	9a 81       	ldd	r25, Y+2	; 0x02
    2f04:	ab 81       	ldd	r26, Y+3	; 0x03
    2f06:	bc 81       	ldd	r27, Y+4	; 0x04
    2f08:	80 93 ee 0c 	sts	0x0CEE, r24
    2f0c:	90 93 ef 0c 	sts	0x0CEF, r25
    2f10:	a0 93 f0 0c 	sts	0x0CF0, r26
    2f14:	b0 93 f1 0c 	sts	0x0CF1, r27
}
    2f18:	0f 90       	pop	r0
    2f1a:	0f 90       	pop	r0
    2f1c:	0f 90       	pop	r0
    2f1e:	0f 90       	pop	r0
    2f20:	cf 91       	pop	r28
    2f22:	df 91       	pop	r29
    2f24:	08 95       	ret

00002f26 <hwclock_init>:
 *
 * This function initializes the Timer 0 in the AVR to
 * generate an interrupt ever 10 ms.
 */
void hwclock_init(void)
{
    2f26:	df 93       	push	r29
    2f28:	cf 93       	push	r28
    2f2a:	cd b7       	in	r28, 0x3d	; 61
    2f2c:	de b7       	in	r29, 0x3e	; 62
#	ifdef CONFIG_USE_KEYS
	SW0_DIR &= ~SW0_PIN;
	SW0_PORT |= SW0_PIN;
#	endif /* CONFIG_USE_KEYS */
	hwclockRestart (0);
    2f2e:	60 e0       	ldi	r22, 0x00	; 0
    2f30:	70 e0       	ldi	r23, 0x00	; 0
    2f32:	80 e0       	ldi	r24, 0x00	; 0
    2f34:	90 e0       	ldi	r25, 0x00	; 0
    2f36:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <hwclockRestart>
	sei ();
    2f3a:	78 94       	sei
}
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	08 95       	ret

00002f42 <hwclock>:
 *
 * This function returns the elapsed time since
 * program start in milliseconds.
 */
MyDword32T	hwclock(void)
{
    2f42:	df 93       	push	r29
    2f44:	cf 93       	push	r28
    2f46:	00 d0       	rcall	.+0      	; 0x2f48 <hwclock+0x6>
    2f48:	00 d0       	rcall	.+0      	; 0x2f4a <hwclock+0x8>
    2f4a:	cd b7       	in	r28, 0x3d	; 61
    2f4c:	de b7       	in	r29, 0x3e	; 62
	MyDword32T r;

	cli();
    2f4e:	f8 94       	cli
	r = jiffies;
    2f50:	80 91 ee 0c 	lds	r24, 0x0CEE
    2f54:	90 91 ef 0c 	lds	r25, 0x0CEF
    2f58:	a0 91 f0 0c 	lds	r26, 0x0CF0
    2f5c:	b0 91 f1 0c 	lds	r27, 0x0CF1
    2f60:	89 83       	std	Y+1, r24	; 0x01
    2f62:	9a 83       	std	Y+2, r25	; 0x02
    2f64:	ab 83       	std	Y+3, r26	; 0x03
    2f66:	bc 83       	std	Y+4, r27	; 0x04
	sei();
    2f68:	78 94       	sei

	return (r);
    2f6a:	89 81       	ldd	r24, Y+1	; 0x01
    2f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6e:	ab 81       	ldd	r26, Y+3	; 0x03
    2f70:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2f72:	bc 01       	movw	r22, r24
    2f74:	cd 01       	movw	r24, r26
    2f76:	0f 90       	pop	r0
    2f78:	0f 90       	pop	r0
    2f7a:	0f 90       	pop	r0
    2f7c:	0f 90       	pop	r0
    2f7e:	cf 91       	pop	r28
    2f80:	df 91       	pop	r29
    2f82:	08 95       	ret

00002f84 <__vector_18>:
 * @brief Timer 0 overflow interrupt
 *
 * Interrupt service routine for the hardware timer
 */
SIGNAL( SIG_OVERFLOW0 )
{
    2f84:	1f 92       	push	r1
    2f86:	0f 92       	push	r0
    2f88:	0f b6       	in	r0, 0x3f	; 63
    2f8a:	0f 92       	push	r0
    2f8c:	11 24       	eor	r1, r1
    2f8e:	8f 93       	push	r24
    2f90:	9f 93       	push	r25
    2f92:	af 93       	push	r26
    2f94:	bf 93       	push	r27
    2f96:	ef 93       	push	r30
    2f98:	ff 93       	push	r31
    2f9a:	df 93       	push	r29
    2f9c:	cf 93       	push	r28
    2f9e:	cd b7       	in	r28, 0x3d	; 61
    2fa0:	de b7       	in	r29, 0x3e	; 62
#	ifdef CONFIG_USE_KEYS
	unsigned char i;
	static		int		state[NKEYS] = { 0 };
#	endif /* CONFIG_USE_KEYS */

	AVR_TCNT0 = TICK_OFFSET;
    2fa2:	e6 e4       	ldi	r30, 0x46	; 70
    2fa4:	f0 e0       	ldi	r31, 0x00	; 0
    2fa6:	88 eb       	ldi	r24, 0xB8	; 184
    2fa8:	80 83       	st	Z, r24
		if(state[i] == STATE_LOW)	{
			key_flags[i] = TRUE;
		}
	}
#	endif
	jiffies += MILLISECONDS_PER_TICK;
    2faa:	80 91 ee 0c 	lds	r24, 0x0CEE
    2fae:	90 91 ef 0c 	lds	r25, 0x0CEF
    2fb2:	a0 91 f0 0c 	lds	r26, 0x0CF0
    2fb6:	b0 91 f1 0c 	lds	r27, 0x0CF1
    2fba:	0a 96       	adiw	r24, 0x0a	; 10
    2fbc:	a1 1d       	adc	r26, r1
    2fbe:	b1 1d       	adc	r27, r1
    2fc0:	80 93 ee 0c 	sts	0x0CEE, r24
    2fc4:	90 93 ef 0c 	sts	0x0CEF, r25
    2fc8:	a0 93 f0 0c 	sts	0x0CF0, r26
    2fcc:	b0 93 f1 0c 	sts	0x0CF1, r27
}
    2fd0:	cf 91       	pop	r28
    2fd2:	df 91       	pop	r29
    2fd4:	ff 91       	pop	r31
    2fd6:	ef 91       	pop	r30
    2fd8:	bf 91       	pop	r27
    2fda:	af 91       	pop	r26
    2fdc:	9f 91       	pop	r25
    2fde:	8f 91       	pop	r24
    2fe0:	0f 90       	pop	r0
    2fe2:	0f be       	out	0x3f, r0	; 63
    2fe4:	0f 90       	pop	r0
    2fe6:	1f 90       	pop	r1
    2fe8:	18 95       	reti

00002fea <__vector_20>:
 * The interrupt service routine for receiving characters on the console i/f
 *
 * Returns: none
 */
SIGNAL(AVR_USART_RECV)
{
    2fea:	1f 92       	push	r1
    2fec:	0f 92       	push	r0
    2fee:	0f b6       	in	r0, 0x3f	; 63
    2ff0:	0f 92       	push	r0
    2ff2:	11 24       	eor	r1, r1
    2ff4:	8f 93       	push	r24
    2ff6:	ef 93       	push	r30
    2ff8:	ff 93       	push	r31
    2ffa:	df 93       	push	r29
    2ffc:	cf 93       	push	r28
    2ffe:	cd b7       	in	r28, 0x3d	; 61
    3000:	de b7       	in	r29, 0x3e	; 62
	serBuffer = AVR_UDR1;
    3002:	e6 ec       	ldi	r30, 0xC6	; 198
    3004:	f0 e0       	ldi	r31, 0x00	; 0
    3006:	80 81       	ld	r24, Z
    3008:	80 93 f2 0c 	sts	0x0CF2, r24
	full = 1;
    300c:	81 e0       	ldi	r24, 0x01	; 1
    300e:	80 93 f3 0c 	sts	0x0CF3, r24
}
    3012:	cf 91       	pop	r28
    3014:	df 91       	pop	r29
    3016:	ff 91       	pop	r31
    3018:	ef 91       	pop	r30
    301a:	8f 91       	pop	r24
    301c:	0f 90       	pop	r0
    301e:	0f be       	out	0x3f, r0	; 63
    3020:	0f 90       	pop	r0
    3022:	1f 90       	pop	r1
    3024:	18 95       	reti

00003026 <console_init>:
 * Initialize console i/o support
 *
 * Returns: none.
 */
void	console_init(void)
{
    3026:	df 93       	push	r29
    3028:	cf 93       	push	r28
    302a:	cd b7       	in	r28, 0x3d	; 61
    302c:	de b7       	in	r29, 0x3e	; 62
	cli();
    302e:	f8 94       	cli
     */
	
	//PORTD |= (1 << PD0);
	//DDRD &= ~(1 << DDD0);
		
	AVR_UBRR1H = 0;                                    		/* USART1: 38400 bps */
    3030:	e5 ec       	ldi	r30, 0xC5	; 197
    3032:	f0 e0       	ldi	r31, 0x00	; 0
    3034:	10 82       	st	Z, r1
	AVR_UBRR1L = 25;
    3036:	e4 ec       	ldi	r30, 0xC4	; 196
    3038:	f0 e0       	ldi	r31, 0x00	; 0
    303a:	89 e1       	ldi	r24, 0x19	; 25
    303c:	80 83       	st	Z, r24
	AVR_UCSR1C |= (1 << AVR_UCSZ11) | (1 << AVR_UCSZ10);     /* USART1: asynchronous 8N1 */
    303e:	a2 ec       	ldi	r26, 0xC2	; 194
    3040:	b0 e0       	ldi	r27, 0x00	; 0
    3042:	e2 ec       	ldi	r30, 0xC2	; 194
    3044:	f0 e0       	ldi	r31, 0x00	; 0
    3046:	80 81       	ld	r24, Z
    3048:	86 60       	ori	r24, 0x06	; 6
    304a:	8c 93       	st	X, r24
	AVR_UCSR1B |= (1 << AVR_RXCIE1) | (1 << AVR_RXEN1)
    304c:	a1 ec       	ldi	r26, 0xC1	; 193
    304e:	b0 e0       	ldi	r27, 0x00	; 0
    3050:	e1 ec       	ldi	r30, 0xC1	; 193
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	80 81       	ld	r24, Z
    3056:	88 69       	ori	r24, 0x98	; 152
    3058:	8c 93       	st	X, r24
				| (1 << AVR_TXEN1);							/* USART1: TX and RX
													 			and RXCIE enabled */
	AVR_UCSR1A |= (1 << AVR_U2X1);
    305a:	a0 ec       	ldi	r26, 0xC0	; 192
    305c:	b0 e0       	ldi	r27, 0x00	; 0
    305e:	e0 ec       	ldi	r30, 0xC0	; 192
    3060:	f0 e0       	ldi	r31, 0x00	; 0
    3062:	80 81       	ld	r24, Z
    3064:	82 60       	ori	r24, 0x02	; 2
    3066:	8c 93       	st	X, r24

	full = 0;
    3068:	10 92 f3 0c 	sts	0x0CF3, r1
    stdout = &stdinouterr;
    306c:	83 ec       	ldi	r24, 0xC3	; 195
    306e:	96 e0       	ldi	r25, 0x06	; 6
    3070:	90 93 5d 10 	sts	0x105D, r25
    3074:	80 93 5c 10 	sts	0x105C, r24
    stdin  = &stdinouterr;
    3078:	83 ec       	ldi	r24, 0xC3	; 195
    307a:	96 e0       	ldi	r25, 0x06	; 6
    307c:	90 93 5b 10 	sts	0x105B, r25
    3080:	80 93 5a 10 	sts	0x105A, r24
    stderr = &stdinouterr;
    3084:	83 ec       	ldi	r24, 0xC3	; 195
    3086:	96 e0       	ldi	r25, 0x06	; 6
    3088:	90 93 5f 10 	sts	0x105F, r25
    308c:	80 93 5e 10 	sts	0x105E, r24

	sei ();
    3090:	78 94       	sei

}
    3092:	cf 91       	pop	r28
    3094:	df 91       	pop	r29
    3096:	08 95       	ret

00003098 <_getchar>:
 * getchar() reads the next character from the console interface
 *
 * Returns: the character read in
 */
int	_getchar(FILE *stream)
{
    3098:	df 93       	push	r29
    309a:	cf 93       	push	r28
    309c:	00 d0       	rcall	.+0      	; 0x309e <_getchar+0x6>
    309e:	cd b7       	in	r28, 0x3d	; 61
    30a0:	de b7       	in	r29, 0x3e	; 62
    30a2:	9a 83       	std	Y+2, r25	; 0x02
    30a4:	89 83       	std	Y+1, r24	; 0x01
	while (full == 0);
    30a6:	80 91 f3 0c 	lds	r24, 0x0CF3
    30aa:	88 23       	and	r24, r24
    30ac:	e1 f3       	breq	.-8      	; 0x30a6 <_getchar+0xe>
	full = 0;
    30ae:	10 92 f3 0c 	sts	0x0CF3, r1
	return serBuffer;
    30b2:	80 91 f2 0c 	lds	r24, 0x0CF2
    30b6:	88 2f       	mov	r24, r24
    30b8:	90 e0       	ldi	r25, 0x00	; 0
}
    30ba:	0f 90       	pop	r0
    30bc:	0f 90       	pop	r0
    30be:	cf 91       	pop	r28
    30c0:	df 91       	pop	r29
    30c2:	08 95       	ret

000030c4 <_putchar>:
 * putchar() transmits the @c byte via the console interface
 *
 * Returns: none
 */
int	_putchar(char c, FILE *stream)
{
    30c4:	df 93       	push	r29
    30c6:	cf 93       	push	r28
    30c8:	00 d0       	rcall	.+0      	; 0x30ca <_putchar+0x6>
    30ca:	0f 92       	push	r0
    30cc:	cd b7       	in	r28, 0x3d	; 61
    30ce:	de b7       	in	r29, 0x3e	; 62
    30d0:	89 83       	std	Y+1, r24	; 0x01
    30d2:	7b 83       	std	Y+3, r23	; 0x03
    30d4:	6a 83       	std	Y+2, r22	; 0x02
	if(c == '\n')
    30d6:	89 81       	ldd	r24, Y+1	; 0x01
    30d8:	8a 30       	cpi	r24, 0x0A	; 10
    30da:	69 f4       	brne	.+26     	; 0x30f6 <_putchar+0x32>
	{
		while((AVR_UCSR1A & (1 << AVR_UDRE1)) == 0);
    30dc:	e0 ec       	ldi	r30, 0xC0	; 192
    30de:	f0 e0       	ldi	r31, 0x00	; 0
    30e0:	80 81       	ld	r24, Z
    30e2:	88 2f       	mov	r24, r24
    30e4:	90 e0       	ldi	r25, 0x00	; 0
    30e6:	80 72       	andi	r24, 0x20	; 32
    30e8:	90 70       	andi	r25, 0x00	; 0
    30ea:	00 97       	sbiw	r24, 0x00	; 0
    30ec:	b9 f3       	breq	.-18     	; 0x30dc <_putchar+0x18>
		AVR_UDR1 = '\r';
    30ee:	e6 ec       	ldi	r30, 0xC6	; 198
    30f0:	f0 e0       	ldi	r31, 0x00	; 0
    30f2:	8d e0       	ldi	r24, 0x0D	; 13
    30f4:	80 83       	st	Z, r24
	}

	while((AVR_UCSR1A & (1 << AVR_UDRE1)) == 0);
    30f6:	e0 ec       	ldi	r30, 0xC0	; 192
    30f8:	f0 e0       	ldi	r31, 0x00	; 0
    30fa:	80 81       	ld	r24, Z
    30fc:	88 2f       	mov	r24, r24
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	80 72       	andi	r24, 0x20	; 32
    3102:	90 70       	andi	r25, 0x00	; 0
    3104:	00 97       	sbiw	r24, 0x00	; 0
    3106:	b9 f3       	breq	.-18     	; 0x30f6 <_putchar+0x32>
	AVR_UDR1 = c;
    3108:	e6 ec       	ldi	r30, 0xC6	; 198
    310a:	f0 e0       	ldi	r31, 0x00	; 0
    310c:	89 81       	ldd	r24, Y+1	; 0x01
    310e:	80 83       	st	Z, r24

	return	0;
    3110:	80 e0       	ldi	r24, 0x00	; 0
    3112:	90 e0       	ldi	r25, 0x00	; 0
}
    3114:	0f 90       	pop	r0
    3116:	0f 90       	pop	r0
    3118:	0f 90       	pop	r0
    311a:	cf 91       	pop	r28
    311c:	df 91       	pop	r29
    311e:	08 95       	ret

00003120 <kbhit>:
 *
 * Returns: 1 if one or more characters are ready for input
 *          0 otherwise
 */
int		kbhit(void)
{
    3120:	df 93       	push	r29
    3122:	cf 93       	push	r28
    3124:	cd b7       	in	r28, 0x3d	; 61
    3126:	de b7       	in	r29, 0x3e	; 62
	return	full;
    3128:	80 91 f3 0c 	lds	r24, 0x0CF3
    312c:	88 2f       	mov	r24, r24
    312e:	90 e0       	ldi	r25, 0x00	; 0
}
    3130:	cf 91       	pop	r28
    3132:	df 91       	pop	r29
    3134:	08 95       	ret

00003136 <read_line>:
 *
 * Returns: buf if a complete line is read in.
 *          0 otherwise
 */
char    *read_line(char buf[])
{
    3136:	df 93       	push	r29
    3138:	cf 93       	push	r28
    313a:	00 d0       	rcall	.+0      	; 0x313c <read_line+0x6>
    313c:	00 d0       	rcall	.+0      	; 0x313e <read_line+0x8>
    313e:	0f 92       	push	r0
    3140:	cd b7       	in	r28, 0x3d	; 61
    3142:	de b7       	in	r29, 0x3e	; 62
    3144:	9b 83       	std	Y+3, r25	; 0x03
    3146:	8a 83       	std	Y+2, r24	; 0x02
    static  int     cnt = 0;
    char            c;

    if(!kbhit())
    3148:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    314c:	00 97       	sbiw	r24, 0x00	; 0
    314e:	19 f4       	brne	.+6      	; 0x3156 <read_line+0x20>
    {
        return  (char *) 0;
    3150:	1d 82       	std	Y+5, r1	; 0x05
    3152:	1c 82       	std	Y+4, r1	; 0x04
    3154:	92 c0       	rjmp	.+292    	; 0x327a <read_line+0x144>
    }
    
    c = getchar();
    3156:	80 91 5a 10 	lds	r24, 0x105A
    315a:	90 91 5b 10 	lds	r25, 0x105B
    315e:	0e 94 15 45 	call	0x8a2a	; 0x8a2a <fgetc>
    3162:	89 83       	std	Y+1, r24	; 0x01

    if(c == '\n' || c == '\r')
    3164:	89 81       	ldd	r24, Y+1	; 0x01
    3166:	8a 30       	cpi	r24, 0x0A	; 10
    3168:	19 f0       	breq	.+6      	; 0x3170 <read_line+0x3a>
    316a:	89 81       	ldd	r24, Y+1	; 0x01
    316c:	8d 30       	cpi	r24, 0x0D	; 13
    316e:	31 f5       	brne	.+76     	; 0x31bc <read_line+0x86>
    {
        putchar('\r');
    3170:	20 91 5c 10 	lds	r18, 0x105C
    3174:	30 91 5d 10 	lds	r19, 0x105D
    3178:	8d e0       	ldi	r24, 0x0D	; 13
    317a:	90 e0       	ldi	r25, 0x00	; 0
    317c:	b9 01       	movw	r22, r18
    317e:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
        putchar('\n');
    3182:	20 91 5c 10 	lds	r18, 0x105C
    3186:	30 91 5d 10 	lds	r19, 0x105D
    318a:	8a e0       	ldi	r24, 0x0A	; 10
    318c:	90 e0       	ldi	r25, 0x00	; 0
    318e:	b9 01       	movw	r22, r18
    3190:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
        buf[cnt] = 0;
    3194:	80 91 f4 0c 	lds	r24, 0x0CF4
    3198:	90 91 f5 0c 	lds	r25, 0x0CF5
    319c:	9c 01       	movw	r18, r24
    319e:	8a 81       	ldd	r24, Y+2	; 0x02
    31a0:	9b 81       	ldd	r25, Y+3	; 0x03
    31a2:	fc 01       	movw	r30, r24
    31a4:	e2 0f       	add	r30, r18
    31a6:	f3 1f       	adc	r31, r19
    31a8:	10 82       	st	Z, r1
        cnt = 0;
    31aa:	10 92 f5 0c 	sts	0x0CF5, r1
    31ae:	10 92 f4 0c 	sts	0x0CF4, r1
        return  buf;
    31b2:	8a 81       	ldd	r24, Y+2	; 0x02
    31b4:	9b 81       	ldd	r25, Y+3	; 0x03
    31b6:	9d 83       	std	Y+5, r25	; 0x05
    31b8:	8c 83       	std	Y+4, r24	; 0x04
    31ba:	5f c0       	rjmp	.+190    	; 0x327a <read_line+0x144>
    }
	else
	{
        if(c == '\b' || c == 0x7f)
    31bc:	89 81       	ldd	r24, Y+1	; 0x01
    31be:	88 30       	cpi	r24, 0x08	; 8
    31c0:	19 f0       	breq	.+6      	; 0x31c8 <read_line+0x92>
    31c2:	89 81       	ldd	r24, Y+1	; 0x01
    31c4:	8f 37       	cpi	r24, 0x7F	; 127
    31c6:	71 f5       	brne	.+92     	; 0x3224 <read_line+0xee>
		{
            if(cnt > 0)
    31c8:	80 91 f4 0c 	lds	r24, 0x0CF4
    31cc:	90 91 f5 0c 	lds	r25, 0x0CF5
    31d0:	18 16       	cp	r1, r24
    31d2:	19 06       	cpc	r1, r25
    31d4:	24 f5       	brge	.+72     	; 0x321e <read_line+0xe8>
			{
                cnt--;
    31d6:	80 91 f4 0c 	lds	r24, 0x0CF4
    31da:	90 91 f5 0c 	lds	r25, 0x0CF5
    31de:	01 97       	sbiw	r24, 0x01	; 1
    31e0:	90 93 f5 0c 	sts	0x0CF5, r25
    31e4:	80 93 f4 0c 	sts	0x0CF4, r24
                putchar('\b');
    31e8:	20 91 5c 10 	lds	r18, 0x105C
    31ec:	30 91 5d 10 	lds	r19, 0x105D
    31f0:	88 e0       	ldi	r24, 0x08	; 8
    31f2:	90 e0       	ldi	r25, 0x00	; 0
    31f4:	b9 01       	movw	r22, r18
    31f6:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
                putchar(' ');
    31fa:	20 91 5c 10 	lds	r18, 0x105C
    31fe:	30 91 5d 10 	lds	r19, 0x105D
    3202:	80 e2       	ldi	r24, 0x20	; 32
    3204:	90 e0       	ldi	r25, 0x00	; 0
    3206:	b9 01       	movw	r22, r18
    3208:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
                putchar('\b');
    320c:	20 91 5c 10 	lds	r18, 0x105C
    3210:	30 91 5d 10 	lds	r19, 0x105D
    3214:	88 e0       	ldi	r24, 0x08	; 8
    3216:	90 e0       	ldi	r25, 0x00	; 0
    3218:	b9 01       	movw	r22, r18
    321a:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
            }
            return  (char *) 0;
    321e:	1d 82       	std	Y+5, r1	; 0x05
    3220:	1c 82       	std	Y+4, r1	; 0x04
    3222:	2b c0       	rjmp	.+86     	; 0x327a <read_line+0x144>
        }

        if(cnt < CONFIG_CONSOLE_LINE_SIZE-1)
    3224:	80 91 f4 0c 	lds	r24, 0x0CF4
    3228:	90 91 f5 0c 	lds	r25, 0x0CF5
    322c:	8f 34       	cpi	r24, 0x4F	; 79
    322e:	91 05       	cpc	r25, r1
    3230:	14 f5       	brge	.+68     	; 0x3276 <read_line+0x140>
		{
            if(c >= 0x20 && c < 0x7f)
    3232:	89 81       	ldd	r24, Y+1	; 0x01
    3234:	80 32       	cpi	r24, 0x20	; 32
    3236:	f8 f0       	brcs	.+62     	; 0x3276 <read_line+0x140>
    3238:	89 81       	ldd	r24, Y+1	; 0x01
    323a:	8f 37       	cpi	r24, 0x7F	; 127
    323c:	e0 f4       	brcc	.+56     	; 0x3276 <read_line+0x140>
			{
                buf[cnt++] = c;
    323e:	40 91 f4 0c 	lds	r20, 0x0CF4
    3242:	50 91 f5 0c 	lds	r21, 0x0CF5
    3246:	9a 01       	movw	r18, r20
    3248:	8a 81       	ldd	r24, Y+2	; 0x02
    324a:	9b 81       	ldd	r25, Y+3	; 0x03
    324c:	fc 01       	movw	r30, r24
    324e:	e2 0f       	add	r30, r18
    3250:	f3 1f       	adc	r31, r19
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	80 83       	st	Z, r24
    3256:	ca 01       	movw	r24, r20
    3258:	01 96       	adiw	r24, 0x01	; 1
    325a:	90 93 f5 0c 	sts	0x0CF5, r25
    325e:	80 93 f4 0c 	sts	0x0CF4, r24
                putchar(c);
    3262:	89 81       	ldd	r24, Y+1	; 0x01
    3264:	88 2f       	mov	r24, r24
    3266:	90 e0       	ldi	r25, 0x00	; 0
    3268:	20 91 5c 10 	lds	r18, 0x105C
    326c:	30 91 5d 10 	lds	r19, 0x105D
    3270:	b9 01       	movw	r22, r18
    3272:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
            }
        }
        return  (char *) 0;
    3276:	1d 82       	std	Y+5, r1	; 0x05
    3278:	1c 82       	std	Y+4, r1	; 0x04
    327a:	8c 81       	ldd	r24, Y+4	; 0x04
    327c:	9d 81       	ldd	r25, Y+5	; 0x05
    }
}
    327e:	0f 90       	pop	r0
    3280:	0f 90       	pop	r0
    3282:	0f 90       	pop	r0
    3284:	0f 90       	pop	r0
    3286:	0f 90       	pop	r0
    3288:	cf 91       	pop	r28
    328a:	df 91       	pop	r29
    328c:	08 95       	ret

0000328e <readSfPacket>:
 *
 * Returns: An error code: 0 for OK, 1 for failure.
 *
 */
Read_sf_status    readSfPacket(Sf_packet * output_area)
{
    328e:	df 93       	push	r29
    3290:	cf 93       	push	r28
    3292:	cd b7       	in	r28, 0x3d	; 61
    3294:	de b7       	in	r29, 0x3e	; 62
    3296:	a4 97       	sbiw	r28, 0x24	; 36
    3298:	0f b6       	in	r0, 0x3f	; 63
    329a:	f8 94       	cli
    329c:	de bf       	out	0x3e, r29	; 62
    329e:	0f be       	out	0x3f, r0	; 63
    32a0:	cd bf       	out	0x3d, r28	; 61
    32a2:	9f 87       	std	Y+15, r25	; 0x0f
    32a4:	8e 87       	std	Y+14, r24	; 0x0e
    *   We would also need to uncomment a few portions of code below.
    *static crc latest_checksums [sizeof(crc)+1]; 
    */
    char c;
    Read_sf_status ret;
    unsigned long curr_time = hwclock();
    32a6:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    32aa:	dc 01       	movw	r26, r24
    32ac:	cb 01       	movw	r24, r22
    32ae:	8b 83       	std	Y+3, r24	; 0x03
    32b0:	9c 83       	std	Y+4, r25	; 0x04
    32b2:	ad 83       	std	Y+5, r26	; 0x05
    32b4:	be 83       	std	Y+6, r27	; 0x06

    if (!kbhit()) {
    32b6:	0e 94 90 18 	call	0x3120	; 0x3120 <kbhit>
    32ba:	00 97       	sbiw	r24, 0x00	; 0
    32bc:	09 f0       	breq	.+2      	; 0x32c0 <readSfPacket+0x32>
    32be:	4f c0       	rjmp	.+158    	; 0x335e <readSfPacket+0xd0>
        ret.nbytes = count;
    32c0:	80 91 fa 0c 	lds	r24, 0x0CFA
    32c4:	90 91 fb 0c 	lds	r25, 0x0CFB
    32c8:	9d 87       	std	Y+13, r25	; 0x0d
    32ca:	8c 87       	std	Y+12, r24	; 0x0c
        if (count!=0) {
    32cc:	80 91 fa 0c 	lds	r24, 0x0CFA
    32d0:	90 91 fb 0c 	lds	r25, 0x0CFB
    32d4:	00 97       	sbiw	r24, 0x00	; 0
    32d6:	09 f1       	breq	.+66     	; 0x331a <readSfPacket+0x8c>
	    if ( curr_time < (unsigned long) (time_packet_started + PACKET_RECEIVE_TIMEOUT_MSEC) ) { 
    32d8:	80 91 f6 0c 	lds	r24, 0x0CF6
    32dc:	90 91 f7 0c 	lds	r25, 0x0CF7
    32e0:	a0 91 f8 0c 	lds	r26, 0x0CF8
    32e4:	b0 91 f9 0c 	lds	r27, 0x0CF9
    32e8:	9c 01       	movw	r18, r24
    32ea:	ad 01       	movw	r20, r26
    32ec:	20 5d       	subi	r18, 0xD0	; 208
    32ee:	3a 48       	sbci	r19, 0x8A	; 138
    32f0:	4f 4f       	sbci	r20, 0xFF	; 255
    32f2:	5f 4f       	sbci	r21, 0xFF	; 255
    32f4:	8b 81       	ldd	r24, Y+3	; 0x03
    32f6:	9c 81       	ldd	r25, Y+4	; 0x04
    32f8:	ad 81       	ldd	r26, Y+5	; 0x05
    32fa:	be 81       	ldd	r27, Y+6	; 0x06
    32fc:	82 17       	cp	r24, r18
    32fe:	93 07       	cpc	r25, r19
    3300:	a4 07       	cpc	r26, r20
    3302:	b5 07       	cpc	r27, r21
    3304:	18 f4       	brcc	.+6      	; 0x330c <readSfPacket+0x7e>
               ret.state = waiting_for_rest_of_packet;
    3306:	81 e0       	ldi	r24, 0x01	; 1
    3308:	8b 87       	std	Y+11, r24	; 0x0b
    330a:	08 c0       	rjmp	.+16     	; 0x331c <readSfPacket+0x8e>
	      *   printf("timed out in kbhit check, expected %d chars but got %d\n", output_area->size, count);
	      *} else {
	      *   puts("timed out in kbhit check before receiving msg size");
              *}
	      */
	       count = 0;
    330c:	10 92 fb 0c 	sts	0x0CFB, r1
    3310:	10 92 fa 0c 	sts	0x0CFA, r1
	       ret.state = packet_timed_out;
    3314:	85 e0       	ldi	r24, 0x05	; 5
    3316:	8b 87       	std	Y+11, r24	; 0x0b
    3318:	01 c0       	rjmp	.+2      	; 0x331c <readSfPacket+0x8e>
	    }
	}
        else
            ret.state = no_packet;
    331a:	1b 86       	std	Y+11, r1	; 0x0b
        return ret;
    331c:	ce 01       	movw	r24, r28
    331e:	08 96       	adiw	r24, 0x08	; 8
    3320:	9b 8b       	std	Y+19, r25	; 0x13
    3322:	8a 8b       	std	Y+18, r24	; 0x12
    3324:	fe 01       	movw	r30, r28
    3326:	3b 96       	adiw	r30, 0x0b	; 11
    3328:	fd 8b       	std	Y+21, r31	; 0x15
    332a:	ec 8b       	std	Y+20, r30	; 0x14
    332c:	f3 e0       	ldi	r31, 0x03	; 3
    332e:	fe 8b       	std	Y+22, r31	; 0x16
    3330:	ec 89       	ldd	r30, Y+20	; 0x14
    3332:	fd 89       	ldd	r31, Y+21	; 0x15
    3334:	00 80       	ld	r0, Z
    3336:	8c 89       	ldd	r24, Y+20	; 0x14
    3338:	9d 89       	ldd	r25, Y+21	; 0x15
    333a:	01 96       	adiw	r24, 0x01	; 1
    333c:	9d 8b       	std	Y+21, r25	; 0x15
    333e:	8c 8b       	std	Y+20, r24	; 0x14
    3340:	ea 89       	ldd	r30, Y+18	; 0x12
    3342:	fb 89       	ldd	r31, Y+19	; 0x13
    3344:	00 82       	st	Z, r0
    3346:	8a 89       	ldd	r24, Y+18	; 0x12
    3348:	9b 89       	ldd	r25, Y+19	; 0x13
    334a:	01 96       	adiw	r24, 0x01	; 1
    334c:	9b 8b       	std	Y+19, r25	; 0x13
    334e:	8a 8b       	std	Y+18, r24	; 0x12
    3350:	9e 89       	ldd	r25, Y+22	; 0x16
    3352:	91 50       	subi	r25, 0x01	; 1
    3354:	9e 8b       	std	Y+22, r25	; 0x16
    3356:	ee 89       	ldd	r30, Y+22	; 0x16
    3358:	ee 23       	and	r30, r30
    335a:	51 f7       	brne	.-44     	; 0x3330 <readSfPacket+0xa2>
    335c:	4f c1       	rjmp	.+670    	; 0x35fc <readSfPacket+0x36e>
    }
    c = getchar();
    335e:	80 91 5a 10 	lds	r24, 0x105A
    3362:	90 91 5b 10 	lds	r25, 0x105B
    3366:	0e 94 15 45 	call	0x8a2a	; 0x8a2a <fgetc>
    336a:	8f 83       	std	Y+7, r24	; 0x07
    ret.nbytes = count;
    336c:	80 91 fa 0c 	lds	r24, 0x0CFA
    3370:	90 91 fb 0c 	lds	r25, 0x0CFB
    3374:	9d 87       	std	Y+13, r25	; 0x0d
    3376:	8c 87       	std	Y+12, r24	; 0x0c
    if ( (count > 0)   &&    ( curr_time > (unsigned long) (time_packet_started + PACKET_RECEIVE_TIMEOUT_MSEC)) ) {
    3378:	80 91 fa 0c 	lds	r24, 0x0CFA
    337c:	90 91 fb 0c 	lds	r25, 0x0CFB
    3380:	18 16       	cp	r1, r24
    3382:	19 06       	cpc	r1, r25
    3384:	0c f0       	brlt	.+2      	; 0x3388 <readSfPacket+0xfa>
    3386:	3e c0       	rjmp	.+124    	; 0x3404 <readSfPacket+0x176>
    3388:	80 91 f6 0c 	lds	r24, 0x0CF6
    338c:	90 91 f7 0c 	lds	r25, 0x0CF7
    3390:	a0 91 f8 0c 	lds	r26, 0x0CF8
    3394:	b0 91 f9 0c 	lds	r27, 0x0CF9
    3398:	9c 01       	movw	r18, r24
    339a:	ad 01       	movw	r20, r26
    339c:	20 5d       	subi	r18, 0xD0	; 208
    339e:	3a 48       	sbci	r19, 0x8A	; 138
    33a0:	4f 4f       	sbci	r20, 0xFF	; 255
    33a2:	5f 4f       	sbci	r21, 0xFF	; 255
    33a4:	8b 81       	ldd	r24, Y+3	; 0x03
    33a6:	9c 81       	ldd	r25, Y+4	; 0x04
    33a8:	ad 81       	ldd	r26, Y+5	; 0x05
    33aa:	be 81       	ldd	r27, Y+6	; 0x06
    33ac:	28 17       	cp	r18, r24
    33ae:	39 07       	cpc	r19, r25
    33b0:	4a 07       	cpc	r20, r26
    33b2:	5b 07       	cpc	r21, r27
    33b4:	38 f5       	brcc	.+78     	; 0x3404 <readSfPacket+0x176>
       count = 0;
    33b6:	10 92 fb 0c 	sts	0x0CFB, r1
    33ba:	10 92 fa 0c 	sts	0x0CFA, r1
       ret.state = packet_timed_out;
    33be:	85 e0       	ldi	r24, 0x05	; 5
    33c0:	8b 87       	std	Y+11, r24	; 0x0b
       return ret;
    33c2:	ce 01       	movw	r24, r28
    33c4:	08 96       	adiw	r24, 0x08	; 8
    33c6:	98 8f       	std	Y+24, r25	; 0x18
    33c8:	8f 8b       	std	Y+23, r24	; 0x17
    33ca:	fe 01       	movw	r30, r28
    33cc:	3b 96       	adiw	r30, 0x0b	; 11
    33ce:	fa 8f       	std	Y+26, r31	; 0x1a
    33d0:	e9 8f       	std	Y+25, r30	; 0x19
    33d2:	f3 e0       	ldi	r31, 0x03	; 3
    33d4:	fb 8f       	std	Y+27, r31	; 0x1b
    33d6:	e9 8d       	ldd	r30, Y+25	; 0x19
    33d8:	fa 8d       	ldd	r31, Y+26	; 0x1a
    33da:	00 80       	ld	r0, Z
    33dc:	89 8d       	ldd	r24, Y+25	; 0x19
    33de:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33e0:	01 96       	adiw	r24, 0x01	; 1
    33e2:	9a 8f       	std	Y+26, r25	; 0x1a
    33e4:	89 8f       	std	Y+25, r24	; 0x19
    33e6:	ef 89       	ldd	r30, Y+23	; 0x17
    33e8:	f8 8d       	ldd	r31, Y+24	; 0x18
    33ea:	00 82       	st	Z, r0
    33ec:	8f 89       	ldd	r24, Y+23	; 0x17
    33ee:	98 8d       	ldd	r25, Y+24	; 0x18
    33f0:	01 96       	adiw	r24, 0x01	; 1
    33f2:	98 8f       	std	Y+24, r25	; 0x18
    33f4:	8f 8b       	std	Y+23, r24	; 0x17
    33f6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    33f8:	91 50       	subi	r25, 0x01	; 1
    33fa:	9b 8f       	std	Y+27, r25	; 0x1b
    33fc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    33fe:	ee 23       	and	r30, r30
    3400:	51 f7       	brne	.-44     	; 0x33d6 <readSfPacket+0x148>
    3402:	fc c0       	rjmp	.+504    	; 0x35fc <readSfPacket+0x36e>
    }
    count++;
    3404:	80 91 fa 0c 	lds	r24, 0x0CFA
    3408:	90 91 fb 0c 	lds	r25, 0x0CFB
    340c:	01 96       	adiw	r24, 0x01	; 1
    340e:	90 93 fb 0c 	sts	0x0CFB, r25
    3412:	80 93 fa 0c 	sts	0x0CFA, r24
    *latest_checksums[0] = crcFast ((unsigned char *)&c, 1, latest_checksums[0]);
    */
    
    //PROTOCOL:  [soh][<size>][<type>][<tag>][<data>][<chksum>]  

    switch (count) {
    3416:	80 91 fa 0c 	lds	r24, 0x0CFA
    341a:	90 91 fb 0c 	lds	r25, 0x0CFB
    341e:	99 8b       	std	Y+17, r25	; 0x11
    3420:	88 8b       	std	Y+16, r24	; 0x10
    3422:	e8 89       	ldd	r30, Y+16	; 0x10
    3424:	f9 89       	ldd	r31, Y+17	; 0x11
    3426:	e2 30       	cpi	r30, 0x02	; 2
    3428:	f1 05       	cpc	r31, r1
    342a:	99 f1       	breq	.+102    	; 0x3492 <readSfPacket+0x204>
    342c:	88 89       	ldd	r24, Y+16	; 0x10
    342e:	99 89       	ldd	r25, Y+17	; 0x11
    3430:	83 30       	cpi	r24, 0x03	; 3
    3432:	91 05       	cpc	r25, r1
    3434:	34 f4       	brge	.+12     	; 0x3442 <readSfPacket+0x1b4>
    3436:	e8 89       	ldd	r30, Y+16	; 0x10
    3438:	f9 89       	ldd	r31, Y+17	; 0x11
    343a:	e1 30       	cpi	r30, 0x01	; 1
    343c:	f1 05       	cpc	r31, r1
    343e:	61 f0       	breq	.+24     	; 0x3458 <readSfPacket+0x1ca>
    3440:	47 c0       	rjmp	.+142    	; 0x34d0 <readSfPacket+0x242>
    3442:	88 89       	ldd	r24, Y+16	; 0x10
    3444:	99 89       	ldd	r25, Y+17	; 0x11
    3446:	83 30       	cpi	r24, 0x03	; 3
    3448:	91 05       	cpc	r25, r1
    344a:	a1 f1       	breq	.+104    	; 0x34b4 <readSfPacket+0x226>
    344c:	e8 89       	ldd	r30, Y+16	; 0x10
    344e:	f9 89       	ldd	r31, Y+17	; 0x11
    3450:	e4 30       	cpi	r30, 0x04	; 4
    3452:	f1 05       	cpc	r31, r1
    3454:	b1 f1       	breq	.+108    	; 0x34c2 <readSfPacket+0x234>
    3456:	3c c0       	rjmp	.+120    	; 0x34d0 <readSfPacket+0x242>
        case 1:  //first byte of packet has to be ascii's "Start of header"
	    if ( 1 == c ) {
    3458:	8f 81       	ldd	r24, Y+7	; 0x07
    345a:	81 30       	cpi	r24, 0x01	; 1
    345c:	99 f4       	brne	.+38     	; 0x3484 <readSfPacket+0x1f6>
	       time_packet_started = hwclock();
    345e:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3462:	dc 01       	movw	r26, r24
    3464:	cb 01       	movw	r24, r22
    3466:	80 93 f6 0c 	sts	0x0CF6, r24
    346a:	90 93 f7 0c 	sts	0x0CF7, r25
    346e:	a0 93 f8 0c 	sts	0x0CF8, r26
    3472:	b0 93 f9 0c 	sts	0x0CF9, r27
	       output_area->header_soh = c;
    3476:	ee 85       	ldd	r30, Y+14	; 0x0e
    3478:	ff 85       	ldd	r31, Y+15	; 0x0f
    347a:	8f 81       	ldd	r24, Y+7	; 0x07
    347c:	80 83       	st	Z, r24
               ret.state = receiving_packet;
    347e:	82 e0       	ldi	r24, 0x02	; 2
    3480:	8b 87       	std	Y+11, r24	; 0x0b
    3482:	9c c0       	rjmp	.+312    	; 0x35bc <readSfPacket+0x32e>
	    }
	    else {
	       count = 0;  //discard partial packet because it is malformed
    3484:	10 92 fb 0c 	sts	0x0CFB, r1
    3488:	10 92 fa 0c 	sts	0x0CFA, r1
	       //printf ("unxpctd %d",c);
	       ret.state = malformed_packet; 
    348c:	84 e0       	ldi	r24, 0x04	; 4
    348e:	8b 87       	std	Y+11, r24	; 0x0b
    3490:	95 c0       	rjmp	.+298    	; 0x35bc <readSfPacket+0x32e>
	    }
            break;
        case 2:
	    if (c >= Sf_packet_header_overhead + sizeof(crc)) {
    3492:	8f 81       	ldd	r24, Y+7	; 0x07
    3494:	85 30       	cpi	r24, 0x05	; 5
    3496:	38 f0       	brcs	.+14     	; 0x34a6 <readSfPacket+0x218>
	    output_area->size = c;
    3498:	ee 85       	ldd	r30, Y+14	; 0x0e
    349a:	ff 85       	ldd	r31, Y+15	; 0x0f
    349c:	8f 81       	ldd	r24, Y+7	; 0x07
    349e:	81 83       	std	Z+1, r24	; 0x01
            	ret.state = receiving_packet;
    34a0:	82 e0       	ldi	r24, 0x02	; 2
    34a2:	8b 87       	std	Y+11, r24	; 0x0b
    34a4:	8b c0       	rjmp	.+278    	; 0x35bc <readSfPacket+0x32e>
	    } else {
		count = 0;
    34a6:	10 92 fb 0c 	sts	0x0CFB, r1
    34aa:	10 92 fa 0c 	sts	0x0CFA, r1
		//puts ("malfrmd pkt: too shrt");
		ret.state = malformed_packet;
    34ae:	84 e0       	ldi	r24, 0x04	; 4
    34b0:	8b 87       	std	Y+11, r24	; 0x0b
    34b2:	84 c0       	rjmp	.+264    	; 0x35bc <readSfPacket+0x32e>
	    }
            break;
        case 3:
            output_area->type = c;
    34b4:	ee 85       	ldd	r30, Y+14	; 0x0e
    34b6:	ff 85       	ldd	r31, Y+15	; 0x0f
    34b8:	8f 81       	ldd	r24, Y+7	; 0x07
    34ba:	82 83       	std	Z+2, r24	; 0x02
            ret.state = receiving_packet;
    34bc:	82 e0       	ldi	r24, 0x02	; 2
    34be:	8b 87       	std	Y+11, r24	; 0x0b
    34c0:	7d c0       	rjmp	.+250    	; 0x35bc <readSfPacket+0x32e>
            break;
	case 4:
	    //If we didn't have a checksum footer, this case would need to handle the possibility that this was the last character of the packet.
            output_area->tag = c;
    34c2:	ee 85       	ldd	r30, Y+14	; 0x0e
    34c4:	ff 85       	ldd	r31, Y+15	; 0x0f
    34c6:	8f 81       	ldd	r24, Y+7	; 0x07
    34c8:	83 83       	std	Z+3, r24	; 0x03
            ret.state = receiving_packet;
    34ca:	82 e0       	ldi	r24, 0x02	; 2
    34cc:	8b 87       	std	Y+11, r24	; 0x0b
    34ce:	76 c0       	rjmp	.+236    	; 0x35bc <readSfPacket+0x32e>
	    break;
        default:
	    //This case needs to detect when a character is the last one of the message, and whether the checksum checks.
	    if (count > Sf_packet_header_overhead ) {  //sanity check
    34d0:	80 91 fa 0c 	lds	r24, 0x0CFA
    34d4:	90 91 fb 0c 	lds	r25, 0x0CFB
    34d8:	85 30       	cpi	r24, 0x05	; 5
    34da:	91 05       	cpc	r25, r1
    34dc:	0c f4       	brge	.+2      	; 0x34e0 <readSfPacket+0x252>
    34de:	68 c0       	rjmp	.+208    	; 0x35b0 <readSfPacket+0x322>
                output_area->params[count - Sf_packet_header_overhead - 1] = c;
    34e0:	80 91 fa 0c 	lds	r24, 0x0CFA
    34e4:	90 91 fb 0c 	lds	r25, 0x0CFB
    34e8:	9c 01       	movw	r18, r24
    34ea:	25 50       	subi	r18, 0x05	; 5
    34ec:	30 40       	sbci	r19, 0x00	; 0
    34ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    34f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    34f2:	82 0f       	add	r24, r18
    34f4:	93 1f       	adc	r25, r19
    34f6:	fc 01       	movw	r30, r24
    34f8:	34 96       	adiw	r30, 0x04	; 4
    34fa:	8f 81       	ldd	r24, Y+7	; 0x07
    34fc:	80 83       	st	Z, r24
                if (count == output_area->size) { //this is true if the current char is the last one
    34fe:	ee 85       	ldd	r30, Y+14	; 0x0e
    3500:	ff 85       	ldd	r31, Y+15	; 0x0f
    3502:	81 81       	ldd	r24, Z+1	; 0x01
    3504:	28 2f       	mov	r18, r24
    3506:	30 e0       	ldi	r19, 0x00	; 0
    3508:	80 91 fa 0c 	lds	r24, 0x0CFA
    350c:	90 91 fb 0c 	lds	r25, 0x0CFB
    3510:	28 17       	cp	r18, r24
    3512:	39 07       	cpc	r19, r25
    3514:	09 f0       	breq	.+2      	; 0x3518 <readSfPacket+0x28a>
    3516:	49 c0       	rjmp	.+146    	; 0x35aa <readSfPacket+0x31c>
		    crc transmitted_checksum = *(crc *) &output_area->params [count - Sf_packet_header_overhead - sizeof(crc)]; //potential endianness issue here
    3518:	8e 85       	ldd	r24, Y+14	; 0x0e
    351a:	9f 85       	ldd	r25, Y+15	; 0x0f
    351c:	9c 01       	movw	r18, r24
    351e:	2c 5f       	subi	r18, 0xFC	; 252
    3520:	3f 4f       	sbci	r19, 0xFF	; 255
    3522:	80 91 fa 0c 	lds	r24, 0x0CFA
    3526:	90 91 fb 0c 	lds	r25, 0x0CFB
    352a:	05 97       	sbiw	r24, 0x05	; 5
    352c:	f9 01       	movw	r30, r18
    352e:	e8 0f       	add	r30, r24
    3530:	f9 1f       	adc	r31, r25
    3532:	80 81       	ld	r24, Z
    3534:	8a 83       	std	Y+2, r24	; 0x02
		    crc computed_checksum = crcFast ( (unsigned char *) output_area, count - sizeof(crc), 0);
    3536:	4e 85       	ldd	r20, Y+14	; 0x0e
    3538:	5f 85       	ldd	r21, Y+15	; 0x0f
    353a:	80 91 fa 0c 	lds	r24, 0x0CFA
    353e:	90 91 fb 0c 	lds	r25, 0x0CFB
    3542:	01 97       	sbiw	r24, 0x01	; 1
    3544:	9c 01       	movw	r18, r24
    3546:	ca 01       	movw	r24, r20
    3548:	b9 01       	movw	r22, r18
    354a:	40 e0       	ldi	r20, 0x00	; 0
    354c:	0e 94 16 1b 	call	0x362c	; 0x362c <crcFast>
    3550:	89 83       	std	Y+1, r24	; 0x01
		    if (transmitted_checksum == computed_checksum) // we calculate the cksum once at the end rather than progressively as we get chars because otherwise we start loosing packets. Now, if we were progressively calculating a cksum as chars came in, we would use the following condition in this conditional: (latest_checksums[sizeof(crc)] == transmitted_checksum). 
    3552:	9a 81       	ldd	r25, Y+2	; 0x02
    3554:	89 81       	ldd	r24, Y+1	; 0x01
    3556:	98 17       	cp	r25, r24
    3558:	19 f4       	brne	.+6      	; 0x3560 <readSfPacket+0x2d2>
			ret.state = packet_received;
    355a:	83 e0       	ldi	r24, 0x03	; 3
    355c:	8b 87       	std	Y+11, r24	; 0x0b
    355e:	20 c0       	rjmp	.+64     	; 0x35a0 <readSfPacket+0x312>
		    else {
			printf("e%x,a%x\n",computed_checksum,transmitted_checksum);
    3560:	89 81       	ldd	r24, Y+1	; 0x01
    3562:	48 2f       	mov	r20, r24
    3564:	50 e0       	ldi	r21, 0x00	; 0
    3566:	8a 81       	ldd	r24, Y+2	; 0x02
    3568:	28 2f       	mov	r18, r24
    356a:	30 e0       	ldi	r19, 0x00	; 0
    356c:	00 d0       	rcall	.+0      	; 0x356e <readSfPacket+0x2e0>
    356e:	00 d0       	rcall	.+0      	; 0x3570 <readSfPacket+0x2e2>
    3570:	00 d0       	rcall	.+0      	; 0x3572 <readSfPacket+0x2e4>
    3572:	ed b7       	in	r30, 0x3d	; 61
    3574:	fe b7       	in	r31, 0x3e	; 62
    3576:	31 96       	adiw	r30, 0x01	; 1
    3578:	81 ed       	ldi	r24, 0xD1	; 209
    357a:	96 e0       	ldi	r25, 0x06	; 6
    357c:	91 83       	std	Z+1, r25	; 0x01
    357e:	80 83       	st	Z, r24
    3580:	53 83       	std	Z+3, r21	; 0x03
    3582:	42 83       	std	Z+2, r20	; 0x02
    3584:	35 83       	std	Z+5, r19	; 0x05
    3586:	24 83       	std	Z+4, r18	; 0x04
    3588:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    358c:	8d b7       	in	r24, 0x3d	; 61
    358e:	9e b7       	in	r25, 0x3e	; 62
    3590:	06 96       	adiw	r24, 0x06	; 6
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	f8 94       	cli
    3596:	9e bf       	out	0x3e, r25	; 62
    3598:	0f be       	out	0x3f, r0	; 63
    359a:	8d bf       	out	0x3d, r24	; 61
		        ret.state = malformed_packet;
    359c:	84 e0       	ldi	r24, 0x04	; 4
    359e:	8b 87       	std	Y+11, r24	; 0x0b
		    }
                    count = 0;
    35a0:	10 92 fb 0c 	sts	0x0CFB, r1
    35a4:	10 92 fa 0c 	sts	0x0CFA, r1
    35a8:	09 c0       	rjmp	.+18     	; 0x35bc <readSfPacket+0x32e>
                }
                else 
	           ret.state = receiving_packet;
    35aa:	82 e0       	ldi	r24, 0x02	; 2
    35ac:	8b 87       	std	Y+11, r24	; 0x0b
    35ae:	06 c0       	rjmp	.+12     	; 0x35bc <readSfPacket+0x32e>
	    }
	    else {
	        //printf ("wrong protocol version? count=%d, expected header size=%d\n", count, Sf_packet_header_overhead);
		count = 0;
    35b0:	10 92 fb 0c 	sts	0x0CFB, r1
    35b4:	10 92 fa 0c 	sts	0x0CFA, r1
		ret.state = malformed_packet;
    35b8:	84 e0       	ldi	r24, 0x04	; 4
    35ba:	8b 87       	std	Y+11, r24	; 0x0b
	    }
	    break;
    }
    return ret;
    35bc:	fe 01       	movw	r30, r28
    35be:	38 96       	adiw	r30, 0x08	; 8
    35c0:	fd 8f       	std	Y+29, r31	; 0x1d
    35c2:	ec 8f       	std	Y+28, r30	; 0x1c
    35c4:	ce 01       	movw	r24, r28
    35c6:	0b 96       	adiw	r24, 0x0b	; 11
    35c8:	9f 8f       	std	Y+31, r25	; 0x1f
    35ca:	8e 8f       	std	Y+30, r24	; 0x1e
    35cc:	93 e0       	ldi	r25, 0x03	; 3
    35ce:	98 a3       	std	Y+32, r25	; 0x20
    35d0:	ee 8d       	ldd	r30, Y+30	; 0x1e
    35d2:	ff 8d       	ldd	r31, Y+31	; 0x1f
    35d4:	00 80       	ld	r0, Z
    35d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    35d8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    35da:	01 96       	adiw	r24, 0x01	; 1
    35dc:	9f 8f       	std	Y+31, r25	; 0x1f
    35de:	8e 8f       	std	Y+30, r24	; 0x1e
    35e0:	ec 8d       	ldd	r30, Y+28	; 0x1c
    35e2:	fd 8d       	ldd	r31, Y+29	; 0x1d
    35e4:	00 82       	st	Z, r0
    35e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    35e8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    35ea:	01 96       	adiw	r24, 0x01	; 1
    35ec:	9d 8f       	std	Y+29, r25	; 0x1d
    35ee:	8c 8f       	std	Y+28, r24	; 0x1c
    35f0:	98 a1       	ldd	r25, Y+32	; 0x20
    35f2:	91 50       	subi	r25, 0x01	; 1
    35f4:	98 a3       	std	Y+32, r25	; 0x20
    35f6:	e8 a1       	ldd	r30, Y+32	; 0x20
    35f8:	ee 23       	and	r30, r30
    35fa:	51 f7       	brne	.-44     	; 0x35d0 <readSfPacket+0x342>
    35fc:	20 e0       	ldi	r18, 0x00	; 0
    35fe:	28 85       	ldd	r18, Y+8	; 0x08
    3600:	80 e0       	ldi	r24, 0x00	; 0
    3602:	89 85       	ldd	r24, Y+9	; 0x09
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	9a 85       	ldd	r25, Y+10	; 0x0a
    3608:	29 a3       	std	Y+33, r18	; 0x21
    360a:	8a a3       	std	Y+34, r24	; 0x22
    360c:	9b a3       	std	Y+35, r25	; 0x23
    360e:	89 a1       	ldd	r24, Y+33	; 0x21
    3610:	9a a1       	ldd	r25, Y+34	; 0x22
    3612:	ab a1       	ldd	r26, Y+35	; 0x23
    3614:	bc a1       	ldd	r27, Y+36	; 0x24
}
    3616:	bc 01       	movw	r22, r24
    3618:	cd 01       	movw	r24, r26
    361a:	a4 96       	adiw	r28, 0x24	; 36
    361c:	0f b6       	in	r0, 0x3f	; 63
    361e:	f8 94       	cli
    3620:	de bf       	out	0x3e, r29	; 62
    3622:	0f be       	out	0x3f, r0	; 63
    3624:	cd bf       	out	0x3d, r28	; 61
    3626:	cf 91       	pop	r28
    3628:	df 91       	pop	r29
    362a:	08 95       	ret

0000362c <crcFast>:



/* crcFast (From netrino.com) calculate the CRC checksum of a message */
crc crcFast (unsigned char message [], int message_len, crc previous_partial_cksum) {
    362c:	df 93       	push	r29
    362e:	cf 93       	push	r28
    3630:	cd b7       	in	r28, 0x3d	; 61
    3632:	de b7       	in	r29, 0x3e	; 62
    3634:	2c 97       	sbiw	r28, 0x0c	; 12
    3636:	0f b6       	in	r0, 0x3f	; 63
    3638:	f8 94       	cli
    363a:	de bf       	out	0x3e, r29	; 62
    363c:	0f be       	out	0x3f, r0	; 63
    363e:	cd bf       	out	0x3d, r28	; 61
    3640:	99 87       	std	Y+9, r25	; 0x09
    3642:	88 87       	std	Y+8, r24	; 0x08
    3644:	7b 87       	std	Y+11, r23	; 0x0b
    3646:	6a 87       	std	Y+10, r22	; 0x0a
    3648:	4c 87       	std	Y+12, r20	; 0x0c
   crc remainder;
   static char first_time = 1;
   static crc crcTable [256];
   if (first_time == 1) {
    364a:	80 91 da 06 	lds	r24, 0x06DA
    364e:	81 30       	cpi	r24, 0x01	; 1
    3650:	91 f5       	brne	.+100    	; 0x36b6 <crcFast+0x8a>
      first_time = 0;
    3652:	10 92 da 06 	sts	0x06DA, r1
      int dividend;
      //precompute the table for fast crc calculation
      for (dividend=0; dividend < 256; dividend++) {
    3656:	1b 82       	std	Y+3, r1	; 0x03
    3658:	1a 82       	std	Y+2, r1	; 0x02
    365a:	27 c0       	rjmp	.+78     	; 0x36aa <crcFast+0x7e>
         remainder = dividend << (CRC_WIDTH - 8);
    365c:	8a 81       	ldd	r24, Y+2	; 0x02
    365e:	8f 83       	std	Y+7, r24	; 0x07
	 char n;
         for (n = 8; n>0; n--) {
    3660:	88 e0       	ldi	r24, 0x08	; 8
    3662:	89 83       	std	Y+1, r24	; 0x01
    3664:	13 c0       	rjmp	.+38     	; 0x368c <crcFast+0x60>
	    if (remainder & CRC_TOPBIT)
    3666:	8f 81       	ldd	r24, Y+7	; 0x07
    3668:	88 23       	and	r24, r24
    366a:	54 f4       	brge	.+20     	; 0x3680 <crcFast+0x54>
	       remainder = (remainder << 1) ^ CRC_POLYNOMIAL;
    366c:	8f 81       	ldd	r24, Y+7	; 0x07
    366e:	88 2f       	mov	r24, r24
    3670:	90 e0       	ldi	r25, 0x00	; 0
    3672:	88 0f       	add	r24, r24
    3674:	99 1f       	adc	r25, r25
    3676:	98 2f       	mov	r25, r24
    3678:	88 ed       	ldi	r24, 0xD8	; 216
    367a:	89 27       	eor	r24, r25
    367c:	8f 83       	std	Y+7, r24	; 0x07
    367e:	03 c0       	rjmp	.+6      	; 0x3686 <crcFast+0x5a>
	    else
	       remainder = (remainder << 1);
    3680:	8f 81       	ldd	r24, Y+7	; 0x07
    3682:	88 0f       	add	r24, r24
    3684:	8f 83       	std	Y+7, r24	; 0x07
      int dividend;
      //precompute the table for fast crc calculation
      for (dividend=0; dividend < 256; dividend++) {
         remainder = dividend << (CRC_WIDTH - 8);
	 char n;
         for (n = 8; n>0; n--) {
    3686:	89 81       	ldd	r24, Y+1	; 0x01
    3688:	81 50       	subi	r24, 0x01	; 1
    368a:	89 83       	std	Y+1, r24	; 0x01
    368c:	89 81       	ldd	r24, Y+1	; 0x01
    368e:	88 23       	and	r24, r24
    3690:	51 f7       	brne	.-44     	; 0x3666 <crcFast+0x3a>
	    if (remainder & CRC_TOPBIT)
	       remainder = (remainder << 1) ^ CRC_POLYNOMIAL;
	    else
	       remainder = (remainder << 1);
	 }
	 crcTable[dividend] = remainder;
    3692:	8a 81       	ldd	r24, Y+2	; 0x02
    3694:	9b 81       	ldd	r25, Y+3	; 0x03
    3696:	fc 01       	movw	r30, r24
    3698:	e4 50       	subi	r30, 0x04	; 4
    369a:	f3 4f       	sbci	r31, 0xF3	; 243
    369c:	8f 81       	ldd	r24, Y+7	; 0x07
    369e:	80 83       	st	Z, r24
   static crc crcTable [256];
   if (first_time == 1) {
      first_time = 0;
      int dividend;
      //precompute the table for fast crc calculation
      for (dividend=0; dividend < 256; dividend++) {
    36a0:	8a 81       	ldd	r24, Y+2	; 0x02
    36a2:	9b 81       	ldd	r25, Y+3	; 0x03
    36a4:	01 96       	adiw	r24, 0x01	; 1
    36a6:	9b 83       	std	Y+3, r25	; 0x03
    36a8:	8a 83       	std	Y+2, r24	; 0x02
    36aa:	8a 81       	ldd	r24, Y+2	; 0x02
    36ac:	9b 81       	ldd	r25, Y+3	; 0x03
    36ae:	8f 3f       	cpi	r24, 0xFF	; 255
    36b0:	91 05       	cpc	r25, r1
    36b2:	a1 f2       	breq	.-88     	; 0x365c <crcFast+0x30>
    36b4:	9c f2       	brlt	.-90     	; 0x365c <crcFast+0x30>
	 crcTable[dividend] = remainder;
      }
   }

   unsigned char data;
   remainder = previous_partial_cksum;
    36b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    36b8:	8f 83       	std	Y+7, r24	; 0x07
   int i;
   for (i=0; i<message_len; i++) {
    36ba:	1d 82       	std	Y+5, r1	; 0x05
    36bc:	1c 82       	std	Y+4, r1	; 0x04
    36be:	1f c0       	rjmp	.+62     	; 0x36fe <crcFast+0xd2>
      data = message[i] ^ (remainder >> (CRC_WIDTH - 8));
    36c0:	2c 81       	ldd	r18, Y+4	; 0x04
    36c2:	3d 81       	ldd	r19, Y+5	; 0x05
    36c4:	88 85       	ldd	r24, Y+8	; 0x08
    36c6:	99 85       	ldd	r25, Y+9	; 0x09
    36c8:	fc 01       	movw	r30, r24
    36ca:	e2 0f       	add	r30, r18
    36cc:	f3 1f       	adc	r31, r19
    36ce:	90 81       	ld	r25, Z
    36d0:	8f 81       	ldd	r24, Y+7	; 0x07
    36d2:	89 27       	eor	r24, r25
    36d4:	8e 83       	std	Y+6, r24	; 0x06
      remainder = crcTable[data] ^ (remainder << 8);
    36d6:	8e 81       	ldd	r24, Y+6	; 0x06
    36d8:	88 2f       	mov	r24, r24
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	fc 01       	movw	r30, r24
    36de:	e4 50       	subi	r30, 0x04	; 4
    36e0:	f3 4f       	sbci	r31, 0xF3	; 243
    36e2:	80 81       	ld	r24, Z
    36e4:	28 2f       	mov	r18, r24
    36e6:	8f 81       	ldd	r24, Y+7	; 0x07
    36e8:	88 2f       	mov	r24, r24
    36ea:	90 e0       	ldi	r25, 0x00	; 0
    36ec:	98 2f       	mov	r25, r24
    36ee:	88 27       	eor	r24, r24
    36f0:	82 27       	eor	r24, r18
    36f2:	8f 83       	std	Y+7, r24	; 0x07
   }

   unsigned char data;
   remainder = previous_partial_cksum;
   int i;
   for (i=0; i<message_len; i++) {
    36f4:	8c 81       	ldd	r24, Y+4	; 0x04
    36f6:	9d 81       	ldd	r25, Y+5	; 0x05
    36f8:	01 96       	adiw	r24, 0x01	; 1
    36fa:	9d 83       	std	Y+5, r25	; 0x05
    36fc:	8c 83       	std	Y+4, r24	; 0x04
    36fe:	2c 81       	ldd	r18, Y+4	; 0x04
    3700:	3d 81       	ldd	r19, Y+5	; 0x05
    3702:	8a 85       	ldd	r24, Y+10	; 0x0a
    3704:	9b 85       	ldd	r25, Y+11	; 0x0b
    3706:	28 17       	cp	r18, r24
    3708:	39 07       	cpc	r19, r25
    370a:	d4 f2       	brlt	.-76     	; 0x36c0 <crcFast+0x94>
      data = message[i] ^ (remainder >> (CRC_WIDTH - 8));
      remainder = crcTable[data] ^ (remainder << 8);
   }

   return (remainder);
    370c:	8f 81       	ldd	r24, Y+7	; 0x07
}
    370e:	2c 96       	adiw	r28, 0x0c	; 12
    3710:	0f b6       	in	r0, 0x3f	; 63
    3712:	f8 94       	cli
    3714:	de bf       	out	0x3e, r29	; 62
    3716:	0f be       	out	0x3f, r0	; 63
    3718:	cd bf       	out	0x3d, r28	; 61
    371a:	cf 91       	pop	r28
    371c:	df 91       	pop	r29
    371e:	08 95       	ret

00003720 <NanoReset>:
 *
 * Returns: none
 */

void NanoReset(void)
{
    3720:	df 93       	push	r29
    3722:	cf 93       	push	r28
    3724:	cd b7       	in	r28, 0x3d	; 61
    3726:	de b7       	in	r29, 0x3e	; 62
	PONRESET_PORT &= ~PONRESET_PIN;               	/* set TRX reset high    */
    3728:	ab e2       	ldi	r26, 0x2B	; 43
    372a:	b0 e0       	ldi	r27, 0x00	; 0
    372c:	eb e2       	ldi	r30, 0x2B	; 43
    372e:	f0 e0       	ldi	r31, 0x00	; 0
    3730:	80 81       	ld	r24, Z
    3732:	87 7f       	andi	r24, 0xF7	; 247
    3734:	8c 93       	st	X, r24
	HWDelayms (1);
    3736:	81 e0       	ldi	r24, 0x01	; 1
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
	PONRESET_PORT |= PONRESET_PIN;                	/* set TRX reset high    */
    373e:	ab e2       	ldi	r26, 0x2B	; 43
    3740:	b0 e0       	ldi	r27, 0x00	; 0
    3742:	eb e2       	ldi	r30, 0x2B	; 43
    3744:	f0 e0       	ldi	r31, 0x00	; 0
    3746:	80 81       	ld	r24, Z
    3748:	88 60       	ori	r24, 0x08	; 8
    374a:	8c 93       	st	X, r24
}
    374c:	cf 91       	pop	r28
    374e:	df 91       	pop	r29
    3750:	08 95       	ret

00003752 <InitSPI>:
 *
 * Returns: none
 */

void InitSPI(void)
{
    3752:	df 93       	push	r29
    3754:	cf 93       	push	r28
    3756:	cd b7       	in	r28, 0x3d	; 61
    3758:	de b7       	in	r29, 0x3e	; 62
	cli();
    375a:	f8 94       	cli
    /*
     * SPI bus on Port B
     */
	SPI_PORT |=	 SPI_SS
    375c:	a5 e2       	ldi	r26, 0x25	; 37
    375e:	b0 e0       	ldi	r27, 0x00	; 0
    3760:	e5 e2       	ldi	r30, 0x25	; 37
    3762:	f0 e0       	ldi	r31, 0x00	; 0
    3764:	80 81       	ld	r24, Z
    3766:	80 6b       	ori	r24, 0xB0	; 176
    3768:	8c 93       	st	X, r24
			 |  SPI_CLK
			 |  SPI_MOSI;

	SPI_DIR |=  SPI_SS                           	/* SPI Slave select      */
    376a:	a4 e2       	ldi	r26, 0x24	; 36
    376c:	b0 e0       	ldi	r27, 0x00	; 0
    376e:	e4 e2       	ldi	r30, 0x24	; 36
    3770:	f0 e0       	ldi	r31, 0x00	; 0
    3772:	80 81       	ld	r24, Z
    3774:	80 6b       	ori	r24, 0xB0	; 176
    3776:	8c 93       	st	X, r24
           	| 	SPI_MOSI;                          	/* SPI Mosi              */

    /*
     * Interrupt and SPI chipselect lines
     */
	PONRESET_PORT |= PONRESET_PIN;                	/* set TRX reset high    */
    3778:	ab e2       	ldi	r26, 0x2B	; 43
    377a:	b0 e0       	ldi	r27, 0x00	; 0
    377c:	eb e2       	ldi	r30, 0x2B	; 43
    377e:	f0 e0       	ldi	r31, 0x00	; 0
    3780:	80 81       	ld	r24, Z
    3782:	88 60       	ori	r24, 0x08	; 8
    3784:	8c 93       	st	X, r24
	PONRESET_DIR  |= PONRESET_PIN;                 /* PD5 for pwrupreset    */
    3786:	aa e2       	ldi	r26, 0x2A	; 42
    3788:	b0 e0       	ldi	r27, 0x00	; 0
    378a:	ea e2       	ldi	r30, 0x2A	; 42
    378c:	f0 e0       	ldi	r31, 0x00	; 0
    378e:	80 81       	ld	r24, Z
    3790:	88 60       	ori	r24, 0x08	; 8
    3792:	8c 93       	st	X, r24


	AVR_SPCR  = ( 1 << AVR_SPE ) 							/* enable SPI master	 */
    3794:	ec e4       	ldi	r30, 0x4C	; 76
    3796:	f0 e0       	ldi	r31, 0x00	; 0
    3798:	80 e7       	ldi	r24, 0x70	; 112
    379a:	80 83       	st	Z, r24
		  | ( 1 << AVR_MSTR ) 							/* clock rate fosc/2	 */
		  | ( 1 << AVR_DORD );							/* LSB first 			 */

	AVR_SPSR |= ( 1 << AVR_SPI2X );                       	/* fosc/2 (Double speeed) */
    379c:	ad e4       	ldi	r26, 0x4D	; 77
    379e:	b0 e0       	ldi	r27, 0x00	; 0
    37a0:	ed e4       	ldi	r30, 0x4D	; 77
    37a2:	f0 e0       	ldi	r31, 0x00	; 0
    37a4:	80 81       	ld	r24, Z
    37a6:	81 60       	ori	r24, 0x01	; 1
    37a8:	8c 93       	st	X, r24

	sei ();
    37aa:	78 94       	sei
}
    37ac:	cf 91       	pop	r28
    37ae:	df 91       	pop	r29
    37b0:	08 95       	ret

000037b2 <SetupSPI>:

void SetupSPI (void)
{
    37b2:	df 93       	push	r29
    37b4:	cf 93       	push	r28
    37b6:	cd b7       	in	r28, 0x3d	; 61
    37b8:	de b7       	in	r29, 0x3e	; 62
	NTRXSPIWriteByte (0x00, 0x42);
    37ba:	80 e0       	ldi	r24, 0x00	; 0
    37bc:	62 e4       	ldi	r22, 0x42	; 66
    37be:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    37c2:	cf 91       	pop	r28
    37c4:	df 91       	pop	r29
    37c6:	08 95       	ret

000037c8 <NTRXSPIRead>:

void NTRXSPIRead(MyByte8T address, MyByte8T *buffer, MyByte8T len)
{
    37c8:	df 93       	push	r29
    37ca:	cf 93       	push	r28
    37cc:	00 d0       	rcall	.+0      	; 0x37ce <NTRXSPIRead+0x6>
    37ce:	00 d0       	rcall	.+0      	; 0x37d0 <NTRXSPIRead+0x8>
    37d0:	00 d0       	rcall	.+0      	; 0x37d2 <NTRXSPIRead+0xa>
    37d2:	cd b7       	in	r28, 0x3d	; 61
    37d4:	de b7       	in	r29, 0x3e	; 62
    37d6:	8a 83       	std	Y+2, r24	; 0x02
    37d8:	7c 83       	std	Y+4, r23	; 0x04
    37da:	6b 83       	std	Y+3, r22	; 0x03
    37dc:	4d 83       	std	Y+5, r20	; 0x05
	tb = buffer;
	tl = len;
#	endif


    if (len > 0x80 || len == 0) return;
    37de:	8d 81       	ldd	r24, Y+5	; 0x05
    37e0:	81 38       	cpi	r24, 0x81	; 129
    37e2:	08 f0       	brcs	.+2      	; 0x37e6 <NTRXSPIRead+0x1e>
    37e4:	51 c0       	rjmp	.+162    	; 0x3888 <NTRXSPIRead+0xc0>
    37e6:	8d 81       	ldd	r24, Y+5	; 0x05
    37e8:	88 23       	and	r24, r24
    37ea:	09 f4       	brne	.+2      	; 0x37ee <NTRXSPIRead+0x26>
    37ec:	4d c0       	rjmp	.+154    	; 0x3888 <NTRXSPIRead+0xc0>
	ENTER_TASK;
    37ee:	ef e5       	ldi	r30, 0x5F	; 95
    37f0:	f0 e0       	ldi	r31, 0x00	; 0
    37f2:	80 81       	ld	r24, Z
    37f4:	89 83       	std	Y+1, r24	; 0x01
    37f6:	f8 94       	cli

	SPI_PORT &=	 ~SPI_SS;
    37f8:	a5 e2       	ldi	r26, 0x25	; 37
    37fa:	b0 e0       	ldi	r27, 0x00	; 0
    37fc:	e5 e2       	ldi	r30, 0x25	; 37
    37fe:	f0 e0       	ldi	r31, 0x00	; 0
    3800:	80 81       	ld	r24, Z
    3802:	8f 7e       	andi	r24, 0xEF	; 239
    3804:	8c 93       	st	X, r24
	AVR_SPDR = (len & 0x7F);
    3806:	ee e4       	ldi	r30, 0x4E	; 78
    3808:	f0 e0       	ldi	r31, 0x00	; 0
    380a:	8d 81       	ldd	r24, Y+5	; 0x05
    380c:	8f 77       	andi	r24, 0x7F	; 127
    380e:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3810:	ed e4       	ldi	r30, 0x4D	; 77
    3812:	f0 e0       	ldi	r31, 0x00	; 0
    3814:	80 81       	ld	r24, Z
    3816:	88 23       	and	r24, r24
    3818:	dc f7       	brge	.-10     	; 0x3810 <NTRXSPIRead+0x48>

	AVR_SPDR = address;
    381a:	ee e4       	ldi	r30, 0x4E	; 78
    381c:	f0 e0       	ldi	r31, 0x00	; 0
    381e:	8a 81       	ldd	r24, Y+2	; 0x02
    3820:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3822:	ed e4       	ldi	r30, 0x4D	; 77
    3824:	f0 e0       	ldi	r31, 0x00	; 0
    3826:	80 81       	ld	r24, Z
    3828:	88 23       	and	r24, r24
    382a:	dc f7       	brge	.-10     	; 0x3822 <NTRXSPIRead+0x5a>
    382c:	14 c0       	rjmp	.+40     	; 0x3856 <NTRXSPIRead+0x8e>

    while(len-- > 0)
    {
		AVR_SPDR = 0xff;
    382e:	ee e4       	ldi	r30, 0x4E	; 78
    3830:	f0 e0       	ldi	r31, 0x00	; 0
    3832:	8f ef       	ldi	r24, 0xFF	; 255
    3834:	80 83       	st	Z, r24
		while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3836:	ed e4       	ldi	r30, 0x4D	; 77
    3838:	f0 e0       	ldi	r31, 0x00	; 0
    383a:	80 81       	ld	r24, Z
    383c:	88 23       	and	r24, r24
    383e:	dc f7       	brge	.-10     	; 0x3836 <NTRXSPIRead+0x6e>
		*buffer++ = AVR_SPDR;
    3840:	ee e4       	ldi	r30, 0x4E	; 78
    3842:	f0 e0       	ldi	r31, 0x00	; 0
    3844:	80 81       	ld	r24, Z
    3846:	eb 81       	ldd	r30, Y+3	; 0x03
    3848:	fc 81       	ldd	r31, Y+4	; 0x04
    384a:	80 83       	st	Z, r24
    384c:	8b 81       	ldd	r24, Y+3	; 0x03
    384e:	9c 81       	ldd	r25, Y+4	; 0x04
    3850:	01 96       	adiw	r24, 0x01	; 1
    3852:	9c 83       	std	Y+4, r25	; 0x04
    3854:	8b 83       	std	Y+3, r24	; 0x03
	while(!(AVR_SPSR &(1 << AVR_SPIF)));

	AVR_SPDR = address;
	while(!(AVR_SPSR &(1 << AVR_SPIF)));

    while(len-- > 0)
    3856:	8d 81       	ldd	r24, Y+5	; 0x05
    3858:	8e 83       	std	Y+6, r24	; 0x06
    385a:	8e 81       	ldd	r24, Y+6	; 0x06
    385c:	88 23       	and	r24, r24
    385e:	11 f0       	breq	.+4      	; 0x3864 <NTRXSPIRead+0x9c>
    3860:	81 e0       	ldi	r24, 0x01	; 1
    3862:	8e 83       	std	Y+6, r24	; 0x06
    3864:	8e 81       	ldd	r24, Y+6	; 0x06
    3866:	9d 81       	ldd	r25, Y+5	; 0x05
    3868:	91 50       	subi	r25, 0x01	; 1
    386a:	9d 83       	std	Y+5, r25	; 0x05
    386c:	88 23       	and	r24, r24
    386e:	f9 f6       	brne	.-66     	; 0x382e <NTRXSPIRead+0x66>
    {
		AVR_SPDR = 0xff;
		while(!(AVR_SPSR &(1 << AVR_SPIF)));
		*buffer++ = AVR_SPDR;
    }
	SPI_PORT |=	 SPI_SS;
    3870:	a5 e2       	ldi	r26, 0x25	; 37
    3872:	b0 e0       	ldi	r27, 0x00	; 0
    3874:	e5 e2       	ldi	r30, 0x25	; 37
    3876:	f0 e0       	ldi	r31, 0x00	; 0
    3878:	80 81       	ld	r24, Z
    387a:	80 61       	ori	r24, 0x10	; 16
    387c:	8c 93       	st	X, r24
	LEAVE_TASK;
    387e:	ef e5       	ldi	r30, 0x5F	; 95
    3880:	f0 e0       	ldi	r31, 0x00	; 0
    3882:	89 81       	ldd	r24, Y+1	; 0x01
    3884:	80 83       	st	Z, r24
    3886:	78 94       	sei
	{
		// traceSpi(READ_CMD, address, tb, tl);
		PrintSpi (READ_CMD, address, tb, tl);
	}
#	endif /* CONFIG_SPI_TRACE */
}
    3888:	26 96       	adiw	r28, 0x06	; 6
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	de bf       	out	0x3e, r29	; 62
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	cd bf       	out	0x3d, r28	; 61
    3894:	cf 91       	pop	r28
    3896:	df 91       	pop	r29
    3898:	08 95       	ret

0000389a <NTRXSPIWrite>:

void NTRXSPIWrite(MyByte8T address, MyByte8T *buffer, MyByte8T len)
{
    389a:	df 93       	push	r29
    389c:	cf 93       	push	r28
    389e:	00 d0       	rcall	.+0      	; 0x38a0 <NTRXSPIWrite+0x6>
    38a0:	00 d0       	rcall	.+0      	; 0x38a2 <NTRXSPIWrite+0x8>
    38a2:	00 d0       	rcall	.+0      	; 0x38a4 <NTRXSPIWrite+0xa>
    38a4:	cd b7       	in	r28, 0x3d	; 61
    38a6:	de b7       	in	r29, 0x3e	; 62
    38a8:	8a 83       	std	Y+2, r24	; 0x02
    38aa:	7c 83       	std	Y+4, r23	; 0x04
    38ac:	6b 83       	std	Y+3, r22	; 0x03
    38ae:	4d 83       	std	Y+5, r20	; 0x05
	if (traceOn == TRUE)
	{
		PrintSpi(WRITE_CMD, address, buffer, len);
	}
#	endif /* CONFIG_SPI_TRACE */
	ENTER_TASK;
    38b0:	ef e5       	ldi	r30, 0x5F	; 95
    38b2:	f0 e0       	ldi	r31, 0x00	; 0
    38b4:	80 81       	ld	r24, Z
    38b6:	89 83       	std	Y+1, r24	; 0x01
    38b8:	f8 94       	cli
	SPI_PORT &=	 ~SPI_SS;
    38ba:	a5 e2       	ldi	r26, 0x25	; 37
    38bc:	b0 e0       	ldi	r27, 0x00	; 0
    38be:	e5 e2       	ldi	r30, 0x25	; 37
    38c0:	f0 e0       	ldi	r31, 0x00	; 0
    38c2:	80 81       	ld	r24, Z
    38c4:	8f 7e       	andi	r24, 0xEF	; 239
    38c6:	8c 93       	st	X, r24

	AVR_SPDR = 0x80 | (len & 0x7F);
    38c8:	ee e4       	ldi	r30, 0x4E	; 78
    38ca:	f0 e0       	ldi	r31, 0x00	; 0
    38cc:	8d 81       	ldd	r24, Y+5	; 0x05
    38ce:	80 68       	ori	r24, 0x80	; 128
    38d0:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    38d2:	ed e4       	ldi	r30, 0x4D	; 77
    38d4:	f0 e0       	ldi	r31, 0x00	; 0
    38d6:	80 81       	ld	r24, Z
    38d8:	88 23       	and	r24, r24
    38da:	dc f7       	brge	.-10     	; 0x38d2 <NTRXSPIWrite+0x38>

	AVR_SPDR = address;
    38dc:	ee e4       	ldi	r30, 0x4E	; 78
    38de:	f0 e0       	ldi	r31, 0x00	; 0
    38e0:	8a 81       	ldd	r24, Y+2	; 0x02
    38e2:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    38e4:	ed e4       	ldi	r30, 0x4D	; 77
    38e6:	f0 e0       	ldi	r31, 0x00	; 0
    38e8:	80 81       	ld	r24, Z
    38ea:	88 23       	and	r24, r24
    38ec:	dc f7       	brge	.-10     	; 0x38e4 <NTRXSPIWrite+0x4a>
    38ee:	10 c0       	rjmp	.+32     	; 0x3910 <NTRXSPIWrite+0x76>

    while(len-- > 0)
    {
		AVR_SPDR = *buffer++;
    38f0:	ae e4       	ldi	r26, 0x4E	; 78
    38f2:	b0 e0       	ldi	r27, 0x00	; 0
    38f4:	eb 81       	ldd	r30, Y+3	; 0x03
    38f6:	fc 81       	ldd	r31, Y+4	; 0x04
    38f8:	80 81       	ld	r24, Z
    38fa:	8c 93       	st	X, r24
    38fc:	8b 81       	ldd	r24, Y+3	; 0x03
    38fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3900:	01 96       	adiw	r24, 0x01	; 1
    3902:	9c 83       	std	Y+4, r25	; 0x04
    3904:	8b 83       	std	Y+3, r24	; 0x03
		while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3906:	ed e4       	ldi	r30, 0x4D	; 77
    3908:	f0 e0       	ldi	r31, 0x00	; 0
    390a:	80 81       	ld	r24, Z
    390c:	88 23       	and	r24, r24
    390e:	dc f7       	brge	.-10     	; 0x3906 <NTRXSPIWrite+0x6c>
	while(!(AVR_SPSR &(1 << AVR_SPIF)));

	AVR_SPDR = address;
	while(!(AVR_SPSR &(1 << AVR_SPIF)));

    while(len-- > 0)
    3910:	8d 81       	ldd	r24, Y+5	; 0x05
    3912:	8e 83       	std	Y+6, r24	; 0x06
    3914:	8e 81       	ldd	r24, Y+6	; 0x06
    3916:	88 23       	and	r24, r24
    3918:	11 f0       	breq	.+4      	; 0x391e <NTRXSPIWrite+0x84>
    391a:	81 e0       	ldi	r24, 0x01	; 1
    391c:	8e 83       	std	Y+6, r24	; 0x06
    391e:	8e 81       	ldd	r24, Y+6	; 0x06
    3920:	9d 81       	ldd	r25, Y+5	; 0x05
    3922:	91 50       	subi	r25, 0x01	; 1
    3924:	9d 83       	std	Y+5, r25	; 0x05
    3926:	88 23       	and	r24, r24
    3928:	19 f7       	brne	.-58     	; 0x38f0 <NTRXSPIWrite+0x56>
    {
		AVR_SPDR = *buffer++;
		while(!(AVR_SPSR &(1 << AVR_SPIF)));
    }
	SPI_PORT |=	 SPI_SS;
    392a:	a5 e2       	ldi	r26, 0x25	; 37
    392c:	b0 e0       	ldi	r27, 0x00	; 0
    392e:	e5 e2       	ldi	r30, 0x25	; 37
    3930:	f0 e0       	ldi	r31, 0x00	; 0
    3932:	80 81       	ld	r24, Z
    3934:	80 61       	ori	r24, 0x10	; 16
    3936:	8c 93       	st	X, r24
	LEAVE_TASK;
    3938:	ef e5       	ldi	r30, 0x5F	; 95
    393a:	f0 e0       	ldi	r31, 0x00	; 0
    393c:	89 81       	ldd	r24, Y+1	; 0x01
    393e:	80 83       	st	Z, r24
    3940:	78 94       	sei
}
    3942:	26 96       	adiw	r28, 0x06	; 6
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	de bf       	out	0x3e, r29	; 62
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	cd bf       	out	0x3d, r28	; 61
    394e:	cf 91       	pop	r28
    3950:	df 91       	pop	r29
    3952:	08 95       	ret

00003954 <NTRXSPIReadByte>:

void NTRXSPIReadByte(MyByte8T address, MyByte8T *buffer)
{
    3954:	df 93       	push	r29
    3956:	cf 93       	push	r28
    3958:	00 d0       	rcall	.+0      	; 0x395a <NTRXSPIReadByte+0x6>
    395a:	00 d0       	rcall	.+0      	; 0x395c <NTRXSPIReadByte+0x8>
    395c:	cd b7       	in	r28, 0x3d	; 61
    395e:	de b7       	in	r29, 0x3e	; 62
    3960:	8a 83       	std	Y+2, r24	; 0x02
    3962:	7c 83       	std	Y+4, r23	; 0x04
    3964:	6b 83       	std	Y+3, r22	; 0x03
	ENTER_TASK;
    3966:	ef e5       	ldi	r30, 0x5F	; 95
    3968:	f0 e0       	ldi	r31, 0x00	; 0
    396a:	80 81       	ld	r24, Z
    396c:	89 83       	std	Y+1, r24	; 0x01
    396e:	f8 94       	cli
	/* chip select */
	SPI_PORT &=	 ~SPI_SS;
    3970:	a5 e2       	ldi	r26, 0x25	; 37
    3972:	b0 e0       	ldi	r27, 0x00	; 0
    3974:	e5 e2       	ldi	r30, 0x25	; 37
    3976:	f0 e0       	ldi	r31, 0x00	; 0
    3978:	80 81       	ld	r24, Z
    397a:	8f 7e       	andi	r24, 0xEF	; 239
    397c:	8c 93       	st	X, r24

	AVR_SPDR = 1;
    397e:	ee e4       	ldi	r30, 0x4E	; 78
    3980:	f0 e0       	ldi	r31, 0x00	; 0
    3982:	81 e0       	ldi	r24, 0x01	; 1
    3984:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3986:	ed e4       	ldi	r30, 0x4D	; 77
    3988:	f0 e0       	ldi	r31, 0x00	; 0
    398a:	80 81       	ld	r24, Z
    398c:	88 23       	and	r24, r24
    398e:	dc f7       	brge	.-10     	; 0x3986 <NTRXSPIReadByte+0x32>

	AVR_SPDR = address;
    3990:	ee e4       	ldi	r30, 0x4E	; 78
    3992:	f0 e0       	ldi	r31, 0x00	; 0
    3994:	8a 81       	ldd	r24, Y+2	; 0x02
    3996:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3998:	ed e4       	ldi	r30, 0x4D	; 77
    399a:	f0 e0       	ldi	r31, 0x00	; 0
    399c:	80 81       	ld	r24, Z
    399e:	88 23       	and	r24, r24
    39a0:	dc f7       	brge	.-10     	; 0x3998 <NTRXSPIReadByte+0x44>

	AVR_SPDR = 0xff;
    39a2:	ee e4       	ldi	r30, 0x4E	; 78
    39a4:	f0 e0       	ldi	r31, 0x00	; 0
    39a6:	8f ef       	ldi	r24, 0xFF	; 255
    39a8:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    39aa:	ed e4       	ldi	r30, 0x4D	; 77
    39ac:	f0 e0       	ldi	r31, 0x00	; 0
    39ae:	80 81       	ld	r24, Z
    39b0:	88 23       	and	r24, r24
    39b2:	dc f7       	brge	.-10     	; 0x39aa <NTRXSPIReadByte+0x56>
	*buffer = AVR_SPDR;
    39b4:	ee e4       	ldi	r30, 0x4E	; 78
    39b6:	f0 e0       	ldi	r31, 0x00	; 0
    39b8:	80 81       	ld	r24, Z
    39ba:	eb 81       	ldd	r30, Y+3	; 0x03
    39bc:	fc 81       	ldd	r31, Y+4	; 0x04
    39be:	80 83       	st	Z, r24

	/* chip select */
	SPI_PORT |=	 SPI_SS;
    39c0:	a5 e2       	ldi	r26, 0x25	; 37
    39c2:	b0 e0       	ldi	r27, 0x00	; 0
    39c4:	e5 e2       	ldi	r30, 0x25	; 37
    39c6:	f0 e0       	ldi	r31, 0x00	; 0
    39c8:	80 81       	ld	r24, Z
    39ca:	80 61       	ori	r24, 0x10	; 16
    39cc:	8c 93       	st	X, r24

	LEAVE_TASK;
    39ce:	ef e5       	ldi	r30, 0x5F	; 95
    39d0:	f0 e0       	ldi	r31, 0x00	; 0
    39d2:	89 81       	ldd	r24, Y+1	; 0x01
    39d4:	80 83       	st	Z, r24
    39d6:	78 94       	sei
	if (traceOn == TRUE)
	{
		PrintSpi (READ_CMD, address, buffer, 1);
	}
#	endif /* CONFIG_SPI_TRACE */
}
    39d8:	0f 90       	pop	r0
    39da:	0f 90       	pop	r0
    39dc:	0f 90       	pop	r0
    39de:	0f 90       	pop	r0
    39e0:	cf 91       	pop	r28
    39e2:	df 91       	pop	r29
    39e4:	08 95       	ret

000039e6 <NTRXSPIWriteByte>:

void NTRXSPIWriteByte(MyByte8T address, MyByte8T buffer)
{
    39e6:	df 93       	push	r29
    39e8:	cf 93       	push	r28
    39ea:	00 d0       	rcall	.+0      	; 0x39ec <NTRXSPIWriteByte+0x6>
    39ec:	0f 92       	push	r0
    39ee:	cd b7       	in	r28, 0x3d	; 61
    39f0:	de b7       	in	r29, 0x3e	; 62
    39f2:	8a 83       	std	Y+2, r24	; 0x02
    39f4:	6b 83       	std	Y+3, r22	; 0x03
	if (traceOn == TRUE)
	{
		PrintSpi(WRITE_CMD, address, &buffer, 1);
	}
#	endif /* CONFIG_SPI_TRACE */
	ENTER_TASK;
    39f6:	ef e5       	ldi	r30, 0x5F	; 95
    39f8:	f0 e0       	ldi	r31, 0x00	; 0
    39fa:	80 81       	ld	r24, Z
    39fc:	89 83       	std	Y+1, r24	; 0x01
    39fe:	f8 94       	cli
	/* chip select */
	SPI_PORT &=	 ~SPI_SS;
    3a00:	a5 e2       	ldi	r26, 0x25	; 37
    3a02:	b0 e0       	ldi	r27, 0x00	; 0
    3a04:	e5 e2       	ldi	r30, 0x25	; 37
    3a06:	f0 e0       	ldi	r31, 0x00	; 0
    3a08:	80 81       	ld	r24, Z
    3a0a:	8f 7e       	andi	r24, 0xEF	; 239
    3a0c:	8c 93       	st	X, r24

	AVR_SPDR = 0x81;
    3a0e:	ee e4       	ldi	r30, 0x4E	; 78
    3a10:	f0 e0       	ldi	r31, 0x00	; 0
    3a12:	81 e8       	ldi	r24, 0x81	; 129
    3a14:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3a16:	ed e4       	ldi	r30, 0x4D	; 77
    3a18:	f0 e0       	ldi	r31, 0x00	; 0
    3a1a:	80 81       	ld	r24, Z
    3a1c:	88 23       	and	r24, r24
    3a1e:	dc f7       	brge	.-10     	; 0x3a16 <NTRXSPIWriteByte+0x30>

	AVR_SPDR = address;
    3a20:	ee e4       	ldi	r30, 0x4E	; 78
    3a22:	f0 e0       	ldi	r31, 0x00	; 0
    3a24:	8a 81       	ldd	r24, Y+2	; 0x02
    3a26:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3a28:	ed e4       	ldi	r30, 0x4D	; 77
    3a2a:	f0 e0       	ldi	r31, 0x00	; 0
    3a2c:	80 81       	ld	r24, Z
    3a2e:	88 23       	and	r24, r24
    3a30:	dc f7       	brge	.-10     	; 0x3a28 <NTRXSPIWriteByte+0x42>

	AVR_SPDR = buffer;
    3a32:	ee e4       	ldi	r30, 0x4E	; 78
    3a34:	f0 e0       	ldi	r31, 0x00	; 0
    3a36:	8b 81       	ldd	r24, Y+3	; 0x03
    3a38:	80 83       	st	Z, r24
	while(!(AVR_SPSR &(1 << AVR_SPIF)));
    3a3a:	ed e4       	ldi	r30, 0x4D	; 77
    3a3c:	f0 e0       	ldi	r31, 0x00	; 0
    3a3e:	80 81       	ld	r24, Z
    3a40:	88 23       	and	r24, r24
    3a42:	dc f7       	brge	.-10     	; 0x3a3a <NTRXSPIWriteByte+0x54>

	/* chip select */
	SPI_PORT |=	 SPI_SS;
    3a44:	a5 e2       	ldi	r26, 0x25	; 37
    3a46:	b0 e0       	ldi	r27, 0x00	; 0
    3a48:	e5 e2       	ldi	r30, 0x25	; 37
    3a4a:	f0 e0       	ldi	r31, 0x00	; 0
    3a4c:	80 81       	ld	r24, Z
    3a4e:	80 61       	ori	r24, 0x10	; 16
    3a50:	8c 93       	st	X, r24
	LEAVE_TASK;
    3a52:	ef e5       	ldi	r30, 0x5F	; 95
    3a54:	f0 e0       	ldi	r31, 0x00	; 0
    3a56:	89 81       	ldd	r24, Y+1	; 0x01
    3a58:	80 83       	st	Z, r24
    3a5a:	78 94       	sei
}
    3a5c:	0f 90       	pop	r0
    3a5e:	0f 90       	pop	r0
    3a60:	0f 90       	pop	r0
    3a62:	cf 91       	pop	r28
    3a64:	df 91       	pop	r29
    3a66:	08 95       	ret

00003a68 <nanosetIRQ>:
 *
 * Returns: none
 */

void nanosetIRQ(MyBoolT value)
{
    3a68:	df 93       	push	r29
    3a6a:	cf 93       	push	r28
    3a6c:	0f 92       	push	r0
    3a6e:	cd b7       	in	r28, 0x3d	; 61
    3a70:	de b7       	in	r29, 0x3e	; 62
    3a72:	89 83       	std	Y+1, r24	; 0x01
    if (value == TRUE)
    3a74:	89 81       	ldd	r24, Y+1	; 0x01
    3a76:	81 30       	cpi	r24, 0x01	; 1
    3a78:	41 f4       	brne	.+16     	; 0x3a8a <nanosetIRQ+0x22>
	{
		EIMSK |= (1 << SPI_INT);
    3a7a:	ad e3       	ldi	r26, 0x3D	; 61
    3a7c:	b0 e0       	ldi	r27, 0x00	; 0
    3a7e:	ed e3       	ldi	r30, 0x3D	; 61
    3a80:	f0 e0       	ldi	r31, 0x00	; 0
    3a82:	80 81       	ld	r24, Z
    3a84:	81 60       	ori	r24, 0x01	; 1
    3a86:	8c 93       	st	X, r24
    3a88:	07 c0       	rjmp	.+14     	; 0x3a98 <nanosetIRQ+0x30>
	}
	else
	{
		EIMSK &= ~(1 << SPI_INT);
    3a8a:	ad e3       	ldi	r26, 0x3D	; 61
    3a8c:	b0 e0       	ldi	r27, 0x00	; 0
    3a8e:	ed e3       	ldi	r30, 0x3D	; 61
    3a90:	f0 e0       	ldi	r31, 0x00	; 0
    3a92:	80 81       	ld	r24, Z
    3a94:	8e 7f       	andi	r24, 0xFE	; 254
    3a96:	8c 93       	st	X, r24
	}
}
    3a98:	0f 90       	pop	r0
    3a9a:	cf 91       	pop	r28
    3a9c:	df 91       	pop	r29
    3a9e:	08 95       	ret

00003aa0 <UpdateLEDs>:
 * This define the supervisary timer to switch the traffic LEDs off automatically.
 */
/****************************************************************************/
void UpdateLEDs (void)
/****************************************************************************/
{
    3aa0:	df 93       	push	r29
    3aa2:	cf 93       	push	r28
    3aa4:	00 d0       	rcall	.+0      	; 0x3aa6 <UpdateLEDs+0x6>
    3aa6:	00 d0       	rcall	.+0      	; 0x3aa8 <UpdateLEDs+0x8>
    3aa8:	cd b7       	in	r28, 0x3d	; 61
    3aaa:	de b7       	in	r29, 0x3e	; 62
	unsigned long tiStamp;
    tiStamp = hwclock ();
    3aac:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3ab0:	dc 01       	movw	r26, r24
    3ab2:	cb 01       	movw	r24, r22
    3ab4:	89 83       	std	Y+1, r24	; 0x01
    3ab6:	9a 83       	std	Y+2, r25	; 0x02
    3ab8:	ab 83       	std	Y+3, r26	; 0x03
    3aba:	bc 83       	std	Y+4, r27	; 0x04

#	ifdef CONFIG_USE_TX_LED
    if (txLED < tiStamp)
    3abc:	20 91 01 0e 	lds	r18, 0x0E01
    3ac0:	30 91 02 0e 	lds	r19, 0x0E02
    3ac4:	40 91 03 0e 	lds	r20, 0x0E03
    3ac8:	50 91 04 0e 	lds	r21, 0x0E04
    3acc:	89 81       	ldd	r24, Y+1	; 0x01
    3ace:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad0:	ab 81       	ldd	r26, Y+3	; 0x03
    3ad2:	bc 81       	ldd	r27, Y+4	; 0x04
    3ad4:	28 17       	cp	r18, r24
    3ad6:	39 07       	cpc	r19, r25
    3ad8:	4a 07       	cpc	r20, r26
    3ada:	5b 07       	cpc	r21, r27
    3adc:	38 f4       	brcc	.+14     	; 0x3aec <UpdateLEDs+0x4c>
	{
		LED_TX(LED_OFF);
    3ade:	a2 e2       	ldi	r26, 0x22	; 34
    3ae0:	b0 e0       	ldi	r27, 0x00	; 0
    3ae2:	e2 e2       	ldi	r30, 0x22	; 34
    3ae4:	f0 e0       	ldi	r31, 0x00	; 0
    3ae6:	80 81       	ld	r24, Z
    3ae8:	80 68       	ori	r24, 0x80	; 128
    3aea:	8c 93       	st	X, r24
	}
#	endif
#	ifdef CONFIG_USE_RX_LED
    if (rxLED < tiStamp)
    3aec:	20 91 05 0e 	lds	r18, 0x0E05
    3af0:	30 91 06 0e 	lds	r19, 0x0E06
    3af4:	40 91 07 0e 	lds	r20, 0x0E07
    3af8:	50 91 08 0e 	lds	r21, 0x0E08
    3afc:	89 81       	ldd	r24, Y+1	; 0x01
    3afe:	9a 81       	ldd	r25, Y+2	; 0x02
    3b00:	ab 81       	ldd	r26, Y+3	; 0x03
    3b02:	bc 81       	ldd	r27, Y+4	; 0x04
    3b04:	28 17       	cp	r18, r24
    3b06:	39 07       	cpc	r19, r25
    3b08:	4a 07       	cpc	r20, r26
    3b0a:	5b 07       	cpc	r21, r27
    3b0c:	38 f4       	brcc	.+14     	; 0x3b1c <UpdateLEDs+0x7c>
	{
		LED_RX(LED_OFF);
    3b0e:	a8 e2       	ldi	r26, 0x28	; 40
    3b10:	b0 e0       	ldi	r27, 0x00	; 0
    3b12:	e8 e2       	ldi	r30, 0x28	; 40
    3b14:	f0 e0       	ldi	r31, 0x00	; 0
    3b16:	80 81       	ld	r24, Z
    3b18:	80 68       	ori	r24, 0x80	; 128
    3b1a:	8c 93       	st	X, r24
		LED_ERR(LED_OFF);
	}
#	endif

#	ifdef CONFIG_USE_CAL_LED
	if (calLED < tiStamp)
    3b1c:	20 91 09 0e 	lds	r18, 0x0E09
    3b20:	30 91 0a 0e 	lds	r19, 0x0E0A
    3b24:	40 91 0b 0e 	lds	r20, 0x0E0B
    3b28:	50 91 0c 0e 	lds	r21, 0x0E0C
    3b2c:	89 81       	ldd	r24, Y+1	; 0x01
    3b2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b30:	ab 81       	ldd	r26, Y+3	; 0x03
    3b32:	bc 81       	ldd	r27, Y+4	; 0x04
    3b34:	28 17       	cp	r18, r24
    3b36:	39 07       	cpc	r19, r25
    3b38:	4a 07       	cpc	r20, r26
    3b3a:	5b 07       	cpc	r21, r27
    3b3c:	38 f4       	brcc	.+14     	; 0x3b4c <UpdateLEDs+0xac>
	{
		LED_CAL(LED_OFF);
    3b3e:	a8 e2       	ldi	r26, 0x28	; 40
    3b40:	b0 e0       	ldi	r27, 0x00	; 0
    3b42:	e8 e2       	ldi	r30, 0x28	; 40
    3b44:	f0 e0       	ldi	r31, 0x00	; 0
    3b46:	80 81       	ld	r24, Z
    3b48:	80 64       	ori	r24, 0x40	; 64
    3b4a:	8c 93       	st	X, r24
	}
#	endif
}
    3b4c:	0f 90       	pop	r0
    3b4e:	0f 90       	pop	r0
    3b50:	0f 90       	pop	r0
    3b52:	0f 90       	pop	r0
    3b54:	cf 91       	pop	r28
    3b56:	df 91       	pop	r29
    3b58:	08 95       	ret

00003b5a <PHYInit>:
 *
 */
/****************************************************************************/
void PHYInit (void)
/****************************************************************************/
{
    3b5a:	df 93       	push	r29
    3b5c:	cf 93       	push	r28
    3b5e:	cd b7       	in	r28, 0x3d	; 61
    3b60:	de b7       	in	r29, 0x3e	; 62
	phyPIB.currentChannel = PHY_CHANNEL_MIN;
    3b62:	8b e0       	ldi	r24, 0x0B	; 11
    3b64:	80 93 bc 0e 	sts	0x0EBC, r24
	phyPIB.txPower		  = 0x3f;
    3b68:	8f e3       	ldi	r24, 0x3F	; 63
    3b6a:	80 93 be 0e 	sts	0x0EBE, r24
	phyPIB.pwrDownMode	  = 2;
    3b6e:	82 e0       	ldi	r24, 0x02	; 2
    3b70:	80 93 db 0e 	sts	0x0EDB, r24
	txSendMsg			  = NULL;
    3b74:	10 92 ff 0d 	sts	0x0DFF, r1
    3b78:	10 92 fe 0d 	sts	0x0DFE, r1
	phyPIB.recalInterval  = CONFIG_NTRX_RECAL_DELAY;
    3b7c:	88 eb       	ldi	r24, 0xB8	; 184
    3b7e:	9b e0       	ldi	r25, 0x0B	; 11
    3b80:	a0 e0       	ldi	r26, 0x00	; 0
    3b82:	b0 e0       	ldi	r27, 0x00	; 0
    3b84:	80 93 d3 0e 	sts	0x0ED3, r24
    3b88:	90 93 d4 0e 	sts	0x0ED4, r25
    3b8c:	a0 93 d5 0e 	sts	0x0ED5, r26
    3b90:	b0 93 d6 0e 	sts	0x0ED6, r27
	phyPIB.phyRxTimeout   = CONFIG_NTRX_PHY_RX_TIMEOUT;
    3b94:	88 e8       	ldi	r24, 0x88	; 136
    3b96:	93 e1       	ldi	r25, 0x13	; 19
    3b98:	a0 e0       	ldi	r26, 0x00	; 0
    3b9a:	b0 e0       	ldi	r27, 0x00	; 0
    3b9c:	80 93 d7 0e 	sts	0x0ED7, r24
    3ba0:	90 93 d8 0e 	sts	0x0ED8, r25
    3ba4:	a0 93 d9 0e 	sts	0x0ED9, r26
    3ba8:	b0 93 da 0e 	sts	0x0EDA, r27
	tiPhyRxTimeout 		  = hwclock() + phyPIB.phyRxTimeout;
    3bac:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3bb0:	9b 01       	movw	r18, r22
    3bb2:	ac 01       	movw	r20, r24
    3bb4:	80 91 d7 0e 	lds	r24, 0x0ED7
    3bb8:	90 91 d8 0e 	lds	r25, 0x0ED8
    3bbc:	a0 91 d9 0e 	lds	r26, 0x0ED9
    3bc0:	b0 91 da 0e 	lds	r27, 0x0EDA
    3bc4:	82 0f       	add	r24, r18
    3bc6:	93 1f       	adc	r25, r19
    3bc8:	a4 1f       	adc	r26, r20
    3bca:	b5 1f       	adc	r27, r21
    3bcc:	80 93 a9 0e 	sts	0x0EA9, r24
    3bd0:	90 93 aa 0e 	sts	0x0EAA, r25
    3bd4:	a0 93 ab 0e 	sts	0x0EAB, r26
    3bd8:	b0 93 ac 0e 	sts	0x0EAC, r27
	tiPhyRxTimeout_once	  = FALSE;
    3bdc:	10 92 ad 0e 	sts	0x0EAD, r1
	phyPIB.arqMax 		  = CONFIG_MAX_ARQ;
    3be0:	8e e0       	ldi	r24, 0x0E	; 14
    3be2:	80 93 ce 0e 	sts	0x0ECE, r24
	phyPIB.testmode		  = 0;
    3be6:	10 92 dd 0e 	sts	0x0EDD, r1
	phyPIB.fec			  = FALSE;
    3bea:	10 92 e7 0e 	sts	0x0EE7, r1
	trxPollMode = TRUE;
    3bee:	81 e0       	ldi	r24, 0x01	; 1
    3bf0:	80 93 db 06 	sts	0x06DB, r24

	/*
     * Clear and reset all interrupt flags of the nanoLOC chip
     */
	ntrxShadowReg[NA_TxIntsReset_O] = 0x3f;
    3bf4:	8f e3       	ldi	r24, 0x3F	; 63
    3bf6:	80 93 16 0f 	sts	0x0F16, r24
	ntrxShadowReg[NA_RxIntsReset_O] = 0x7f;
    3bfa:	8f e7       	ldi	r24, 0x7F	; 127
    3bfc:	80 93 17 0f 	sts	0x0F17, r24
	/*
	 * enable tx and rx interrupts
	 */
	ntrxShadowReg[NA_RxIrqEnable_O] |= ((1 << NA_RxIrqEnable_B) | (1 << NA_TxIrqEnable_B));
    3c00:	80 91 15 0f 	lds	r24, 0x0F15
    3c04:	83 60       	ori	r24, 0x03	; 3
    3c06:	80 93 15 0f 	sts	0x0F15, r24

	NTRXResetSettings ();
    3c0a:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <NTRXResetSettings>

	/*
     * enable CRC checks on received messages. This will cause corrupt frames to be droped
     * silently by the nanoLOC chip. The receiver is restarted automatically.
     */
    if ((ntrxShadowReg[NA_RxCrc2Mode_O] & (1<< NA_RxCrc2Mode_B)) !=  0)
    3c0e:	80 91 60 0f 	lds	r24, 0x0F60
    3c12:	88 2f       	mov	r24, r24
    3c14:	90 e0       	ldi	r25, 0x00	; 0
    3c16:	82 70       	andi	r24, 0x02	; 2
    3c18:	90 70       	andi	r25, 0x00	; 0
    3c1a:	00 97       	sbiw	r24, 0x00	; 0
    3c1c:	21 f0       	breq	.+8      	; 0x3c26 <PHYInit+0xcc>
	{
		ntrxShadowReg[NA_RxIntsEn_O] = (0x01 << NA_RxEnd_B);
    3c1e:	84 e0       	ldi	r24, 0x04	; 4
    3c20:	80 93 1a 0f 	sts	0x0F1A, r24
    3c24:	03 c0       	rjmp	.+6      	; 0x3c2c <PHYInit+0xd2>
	}
    else
	{
		ntrxShadowReg[NA_RxIntsEn_O] = ((0x01 << NA_RxEnd_B) | (0x01 << NA_RxOverflow_B));
    3c26:	84 e1       	ldi	r24, 0x14	; 20
    3c28:	80 93 1a 0f 	sts	0x0F1A, r24
	}
	ntrxShadowReg[NA_TxIntsEn_O] = (1 << NA_TxEnd_B);
    3c2c:	84 e0       	ldi	r24, 0x04	; 4
    3c2e:	80 93 19 0f 	sts	0x0F19, r24

	NTRXSPIWrite (NA_RxIrqEnable_O, ntrxShadowReg + 0x0f, 6);
    3c32:	25 e1       	ldi	r18, 0x15	; 21
    3c34:	3f e0       	ldi	r19, 0x0F	; 15
    3c36:	8f e0       	ldi	r24, 0x0F	; 15
    3c38:	b9 01       	movw	r22, r18
    3c3a:	46 e0       	ldi	r20, 0x06	; 6
    3c3c:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
    /*
     * initialize layer global variables
     */
    txIrqStatus = 0;
    3c40:	10 92 03 0f 	sts	0x0F03, r1
    rxIrqStatus = 0;
    3c44:	10 92 04 0f 	sts	0x0F04, r1
    txIrq = 0;
    3c48:	10 92 ae 0e 	sts	0x0EAE, r1
    rxIrq = 0;
    3c4c:	10 92 af 0e 	sts	0x0EAF, r1
    bbIrq = 0;
    3c50:	10 92 bb 0e 	sts	0x0EBB, r1
	lState = RANGING_READY;
    3c54:	10 92 b1 0e 	sts	0x0EB1, r1
	rState = RANGING_READY;
    3c58:	10 92 b2 0e 	sts	0x0EB2, r1
	ntrxShadowReg[NA_TxIntsReset_O] = 0;
    3c5c:	10 92 16 0f 	sts	0x0F16, r1
	ntrxShadowReg[NA_RxIntsReset_O] = 0;
    3c60:	10 92 17 0f 	sts	0x0F17, r1

    /*
     * start the receiver of the TRX chip
     */
	if (phyPIB.rxState == PHY_RX_ON)
    3c64:	80 91 bf 0e 	lds	r24, 0x0EBF
    3c68:	86 30       	cpi	r24, 0x06	; 6
    3c6a:	41 f4       	brne	.+16     	; 0x3c7c <PHYInit+0x122>
	{
    	NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    3c6c:	80 91 5c 0f 	lds	r24, 0x0F5C
    3c70:	98 2f       	mov	r25, r24
    3c72:	9e 60       	ori	r25, 0x0E	; 14
    3c74:	86 e5       	ldi	r24, 0x56	; 86
    3c76:	69 2f       	mov	r22, r25
    3c78:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
									| (1 << NA_RxCmdStart_B)
									| (0x03 << NA_RxBufferCmd_LSB));
	}

    ntrxState    = TxIDLE;
    3c7c:	10 92 05 0f 	sts	0x0F05, r1
}
    3c80:	cf 91       	pop	r28
    3c82:	df 91       	pop	r29
    3c84:	08 95       	ret

00003c86 <PDSap>:
 *
 */
/****************************************************************************/
void PDSap (MyMsgT *msg)
/****************************************************************************/
{
    3c86:	df 93       	push	r29
    3c88:	cf 93       	push	r28
    3c8a:	cd b7       	in	r28, 0x3d	; 61
    3c8c:	de b7       	in	r29, 0x3e	; 62
    3c8e:	2b 97       	sbiw	r28, 0x0b	; 11
    3c90:	0f b6       	in	r0, 0x3f	; 63
    3c92:	f8 94       	cli
    3c94:	de bf       	out	0x3e, r29	; 62
    3c96:	0f be       	out	0x3f, r0	; 63
    3c98:	cd bf       	out	0x3d, r28	; 61
    3c9a:	9c 83       	std	Y+4, r25	; 0x04
    3c9c:	8b 83       	std	Y+3, r24	; 0x03

	/*
	 * check the message length. If the message length is bigger than
	 * the allowed buffer size the packet will be rejected.
	 */
	if (msg->len > PHY_PACKET_SIZE)
    3c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca2:	87 81       	ldd	r24, Z+7	; 0x07
    3ca4:	81 38       	cpi	r24, 0x81	; 129
    3ca6:	80 f0       	brcs	.+32     	; 0x3cc8 <PDSap+0x42>
	{
		msg->prim = PD_DATA_CONFIRM;
    3ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    3caa:	fc 81       	ldd	r31, Y+4	; 0x04
    3cac:	82 e0       	ldi	r24, 0x02	; 2
    3cae:	80 83       	st	Z, r24
		msg->status = PHY_BUSY_TX;
    3cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	e8 57       	subi	r30, 0x78	; 120
    3cb8:	ff 4f       	sbci	r31, 0xFF	; 255
    3cba:	82 e0       	ldi	r24, 0x02	; 2
    3cbc:	80 83       	st	Z, r24
		SendMsgUp (msg);
    3cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc2:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    3cc6:	cf c1       	rjmp	.+926    	; 0x4066 <PDSap+0x3e0>
		return;
	}

	switch(msg->prim)
    3cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    3cca:	fc 81       	ldd	r31, Y+4	; 0x04
    3ccc:	80 81       	ld	r24, Z
    3cce:	28 2f       	mov	r18, r24
    3cd0:	30 e0       	ldi	r19, 0x00	; 0
    3cd2:	3b 87       	std	Y+11, r19	; 0x0b
    3cd4:	2a 87       	std	Y+10, r18	; 0x0a
    3cd6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cd8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cda:	82 31       	cpi	r24, 0x12	; 18
    3cdc:	91 05       	cpc	r25, r1
    3cde:	8c f4       	brge	.+34     	; 0x3d02 <PDSap+0x7c>
    3ce0:	2a 85       	ldd	r18, Y+10	; 0x0a
    3ce2:	3b 85       	ldd	r19, Y+11	; 0x0b
    3ce4:	2f 30       	cpi	r18, 0x0F	; 15
    3ce6:	31 05       	cpc	r19, r1
    3ce8:	ac f5       	brge	.+106    	; 0x3d54 <PDSap+0xce>
    3cea:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cec:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cee:	81 30       	cpi	r24, 0x01	; 1
    3cf0:	91 05       	cpc	r25, r1
    3cf2:	d1 f0       	breq	.+52     	; 0x3d28 <PDSap+0xa2>
    3cf4:	2a 85       	ldd	r18, Y+10	; 0x0a
    3cf6:	3b 85       	ldd	r19, Y+11	; 0x0b
    3cf8:	2e 30       	cpi	r18, 0x0E	; 14
    3cfa:	31 05       	cpc	r19, r1
    3cfc:	09 f4       	brne	.+2      	; 0x3d00 <PDSap+0x7a>
    3cfe:	2d c1       	rjmp	.+602    	; 0x3f5a <PDSap+0x2d4>
    3d00:	b2 c1       	rjmp	.+868    	; 0x4066 <PDSap+0x3e0>
    3d02:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d04:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d06:	84 31       	cpi	r24, 0x14	; 20
    3d08:	91 05       	cpc	r25, r1
    3d0a:	09 f4       	brne	.+2      	; 0x3d0e <PDSap+0x88>
    3d0c:	26 c1       	rjmp	.+588    	; 0x3f5a <PDSap+0x2d4>
    3d0e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3d10:	3b 85       	ldd	r19, Y+11	; 0x0b
    3d12:	24 31       	cpi	r18, 0x14	; 20
    3d14:	31 05       	cpc	r19, r1
    3d16:	0c f4       	brge	.+2      	; 0x3d1a <PDSap+0x94>
    3d18:	a6 c1       	rjmp	.+844    	; 0x4066 <PDSap+0x3e0>
    3d1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d1e:	87 31       	cpi	r24, 0x17	; 23
    3d20:	91 05       	cpc	r25, r1
    3d22:	0c f0       	brlt	.+2      	; 0x3d26 <PDSap+0xa0>
    3d24:	a0 c1       	rjmp	.+832    	; 0x4066 <PDSap+0x3e0>
    3d26:	16 c0       	rjmp	.+44     	; 0x3d54 <PDSap+0xce>
	{
		case PD_DATA_REQUEST :
			/* transmitter still busy */
			if (txSendMsg != NULL)
    3d28:	80 91 fe 0d 	lds	r24, 0x0DFE
    3d2c:	90 91 ff 0d 	lds	r25, 0x0DFF
    3d30:	00 97       	sbiw	r24, 0x00	; 0
    3d32:	81 f0       	breq	.+32     	; 0x3d54 <PDSap+0xce>
			{

				msg->prim = PD_DATA_CONFIRM;
    3d34:	eb 81       	ldd	r30, Y+3	; 0x03
    3d36:	fc 81       	ldd	r31, Y+4	; 0x04
    3d38:	82 e0       	ldi	r24, 0x02	; 2
    3d3a:	80 83       	st	Z, r24
				msg->status = PHY_BUSY_TX;
    3d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d40:	fc 01       	movw	r30, r24
    3d42:	e8 57       	subi	r30, 0x78	; 120
    3d44:	ff 4f       	sbci	r31, 0xFF	; 255
    3d46:	82 e0       	ldi	r24, 0x02	; 2
    3d48:	80 83       	st	Z, r24
				SendMsgUp (msg);
    3d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4e:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    3d52:	89 c1       	rjmp	.+786    	; 0x4066 <PDSap+0x3e0>
		case PD_RANGING_FAST_REQUEST_EXECUTE :
		case PD_RANGING_FAST_ANSWER1_EXECUTE :


#	   		ifdef CONFIG_NTRX_AUTO_RECALIB
			if (phyPIB.recalInterval != 0)
    3d54:	80 91 d3 0e 	lds	r24, 0x0ED3
    3d58:	90 91 d4 0e 	lds	r25, 0x0ED4
    3d5c:	a0 91 d5 0e 	lds	r26, 0x0ED5
    3d60:	b0 91 d6 0e 	lds	r27, 0x0ED6
    3d64:	00 97       	sbiw	r24, 0x00	; 0
    3d66:	a1 05       	cpc	r26, r1
    3d68:	b1 05       	cpc	r27, r1
    3d6a:	09 f4       	brne	.+2      	; 0x3d6e <PDSap+0xe8>
    3d6c:	4b c0       	rjmp	.+150    	; 0x3e04 <PDSap+0x17e>
			{
				if( tiRecal < hwclock() )
    3d6e:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3d72:	9b 01       	movw	r18, r22
    3d74:	ac 01       	movw	r20, r24
    3d76:	80 91 a5 0e 	lds	r24, 0x0EA5
    3d7a:	90 91 a6 0e 	lds	r25, 0x0EA6
    3d7e:	a0 91 a7 0e 	lds	r26, 0x0EA7
    3d82:	b0 91 a8 0e 	lds	r27, 0x0EA8
    3d86:	82 17       	cp	r24, r18
    3d88:	93 07       	cpc	r25, r19
    3d8a:	a4 07       	cpc	r26, r20
    3d8c:	b5 07       	cpc	r27, r21
    3d8e:	d0 f5       	brcc	.+116    	; 0x3e04 <PDSap+0x17e>
				{
					/* INFO: If the TRX sends a packet, calibration failes!
					 * In this case rcwd is not reset, but tiRecal is.
					 */
					/* normal operation mode */
					if (phyPIB.testmode == 0)
    3d90:	80 91 dd 0e 	lds	r24, 0x0EDD
    3d94:	88 23       	and	r24, r24
    3d96:	b1 f5       	brne	.+108    	; 0x3e04 <PDSap+0x17e>
					{
						if (NTRXAllCalibration ())
    3d98:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
    3d9c:	88 23       	and	r24, r24
    3d9e:	91 f1       	breq	.+100    	; 0x3e04 <PDSap+0x17e>
						{
							tiRecal = hwclock() + phyPIB.recalInterval;
    3da0:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3da4:	9b 01       	movw	r18, r22
    3da6:	ac 01       	movw	r20, r24
    3da8:	80 91 d3 0e 	lds	r24, 0x0ED3
    3dac:	90 91 d4 0e 	lds	r25, 0x0ED4
    3db0:	a0 91 d5 0e 	lds	r26, 0x0ED5
    3db4:	b0 91 d6 0e 	lds	r27, 0x0ED6
    3db8:	82 0f       	add	r24, r18
    3dba:	93 1f       	adc	r25, r19
    3dbc:	a4 1f       	adc	r26, r20
    3dbe:	b5 1f       	adc	r27, r21
    3dc0:	80 93 a5 0e 	sts	0x0EA5, r24
    3dc4:	90 93 a6 0e 	sts	0x0EA6, r25
    3dc8:	a0 93 a7 0e 	sts	0x0EA7, r26
    3dcc:	b0 93 a8 0e 	sts	0x0EA8, r27
							rcwd = 0;
    3dd0:	10 92 fd 0d 	sts	0x0DFD, r1
    3dd4:	10 92 fc 0d 	sts	0x0DFC, r1
							TRIGGER_LED_CAL();
    3dd8:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3ddc:	dc 01       	movw	r26, r24
    3dde:	cb 01       	movw	r24, r22
    3de0:	c2 96       	adiw	r24, 0x32	; 50
    3de2:	a1 1d       	adc	r26, r1
    3de4:	b1 1d       	adc	r27, r1
    3de6:	80 93 09 0e 	sts	0x0E09, r24
    3dea:	90 93 0a 0e 	sts	0x0E0A, r25
    3dee:	a0 93 0b 0e 	sts	0x0E0B, r26
    3df2:	b0 93 0c 0e 	sts	0x0E0C, r27
    3df6:	a8 e2       	ldi	r26, 0x28	; 40
    3df8:	b0 e0       	ldi	r27, 0x00	; 0
    3dfa:	e8 e2       	ldi	r30, 0x28	; 40
    3dfc:	f0 e0       	ldi	r31, 0x00	; 0
    3dfe:	80 81       	ld	r24, Z
    3e00:	8f 7b       	andi	r24, 0xBF	; 191
    3e02:	8c 93       	st	X, r24
					}
				}
			}
#	   		endif /* CONFIG_NTRX_AUTO_RECALIB */
			/* check which buffer is free to transmit data */
			if (buffSwapped ==TRUE)
    3e04:	80 91 00 0e 	lds	r24, 0x0E00
    3e08:	81 30       	cpi	r24, 0x01	; 1
    3e0a:	89 f4       	brne	.+34     	; 0x3e2e <PDSap+0x1a8>
			{
				/* write user data to transmit buffer in ntrx chip */
				NTRXSetIndexReg (2);
    3e0c:	82 e0       	ldi	r24, 0x02	; 2
    3e0e:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
				NTRXSPIWrite ((MyByte8T)(NA_RamTxBuffer_O & 0xff), msg->data, (MyByte8T)(msg->len & 0xff));
    3e12:	8b 81       	ldd	r24, Y+3	; 0x03
    3e14:	9c 81       	ldd	r25, Y+4	; 0x04
    3e16:	9c 01       	movw	r18, r24
    3e18:	28 5f       	subi	r18, 0xF8	; 248
    3e1a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e20:	97 81       	ldd	r25, Z+7	; 0x07
    3e22:	80 e8       	ldi	r24, 0x80	; 128
    3e24:	b9 01       	movw	r22, r18
    3e26:	49 2f       	mov	r20, r25
    3e28:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
    3e2c:	10 c0       	rjmp	.+32     	; 0x3e4e <PDSap+0x1c8>

			}else
			{
				/* write user data to transmit buffer in ntrx chip */
				NTRXSetIndexReg (3);
    3e2e:	83 e0       	ldi	r24, 0x03	; 3
    3e30:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
				NTRXSPIWrite ((MyByte8T)(NA_RamTxBuffer_O & 0xff), msg->data, (MyByte8T)(msg->len & 0xff));
    3e34:	8b 81       	ldd	r24, Y+3	; 0x03
    3e36:	9c 81       	ldd	r25, Y+4	; 0x04
    3e38:	9c 01       	movw	r18, r24
    3e3a:	28 5f       	subi	r18, 0xF8	; 248
    3e3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    3e40:	fc 81       	ldd	r31, Y+4	; 0x04
    3e42:	97 81       	ldd	r25, Z+7	; 0x07
    3e44:	80 e8       	ldi	r24, 0x80	; 128
    3e46:	b9 01       	movw	r22, r18
    3e48:	49 2f       	mov	r20, r25
    3e4a:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
			}

			NTRXSetIndexReg (0);
    3e4e:	80 e0       	ldi	r24, 0x00	; 0
    3e50:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>

			/* copy the destination address to temp buffer */
			if (memcmp (cacheAddr, msg->addr, 6) != 0)
    3e54:	8b 81       	ldd	r24, Y+3	; 0x03
    3e56:	9c 81       	ldd	r25, Y+4	; 0x04
    3e58:	9c 01       	movw	r18, r24
    3e5a:	2f 5f       	subi	r18, 0xFF	; 255
    3e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3e5e:	88 ee       	ldi	r24, 0xE8	; 232
    3e60:	9e e0       	ldi	r25, 0x0E	; 14
    3e62:	b9 01       	movw	r22, r18
    3e64:	46 e0       	ldi	r20, 0x06	; 6
    3e66:	50 e0       	ldi	r21, 0x00	; 0
    3e68:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    3e6c:	00 97       	sbiw	r24, 0x00	; 0
    3e6e:	99 f0       	breq	.+38     	; 0x3e96 <PDSap+0x210>
			{
				memcpy (cacheAddr, msg->addr, 6);
    3e70:	8b 81       	ldd	r24, Y+3	; 0x03
    3e72:	9c 81       	ldd	r25, Y+4	; 0x04
    3e74:	9c 01       	movw	r18, r24
    3e76:	2f 5f       	subi	r18, 0xFF	; 255
    3e78:	3f 4f       	sbci	r19, 0xFF	; 255
    3e7a:	88 ee       	ldi	r24, 0xE8	; 232
    3e7c:	9e e0       	ldi	r25, 0x0E	; 14
    3e7e:	b9 01       	movw	r22, r18
    3e80:	46 e0       	ldi	r20, 0x06	; 6
    3e82:	50 e0       	ldi	r21, 0x00	; 0
    3e84:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				NTRXSPIWrite (NA_RamTxDstAddr_O, cacheAddr, 6);
    3e88:	28 ee       	ldi	r18, 0xE8	; 232
    3e8a:	3e e0       	ldi	r19, 0x0E	; 14
    3e8c:	80 e9       	ldi	r24, 0x90	; 144
    3e8e:	b9 01       	movw	r22, r18
    3e90:	46 e0       	ldi	r20, 0x06	; 6
    3e92:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
			}

			/* merge the three bits into the temp buffer */
			txLen[0] = msg->len;
    3e96:	eb 81       	ldd	r30, Y+3	; 0x03
    3e98:	fc 81       	ldd	r31, Y+4	; 0x04
    3e9a:	87 81       	ldd	r24, Z+7	; 0x07
    3e9c:	89 83       	std	Y+1, r24	; 0x01
			// txLen[1] = (len & 0x1F00) >> 8;
			txLen[1]  = (lState & 0x01) ? 0x20 : 0;
    3e9e:	80 91 b1 0e 	lds	r24, 0x0EB1
    3ea2:	88 2f       	mov	r24, r24
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	81 70       	andi	r24, 0x01	; 1
    3ea8:	90 70       	andi	r25, 0x00	; 0
    3eaa:	88 23       	and	r24, r24
    3eac:	19 f0       	breq	.+6      	; 0x3eb4 <PDSap+0x22e>
    3eae:	90 e2       	ldi	r25, 0x20	; 32
    3eb0:	99 87       	std	Y+9, r25	; 0x09
    3eb2:	01 c0       	rjmp	.+2      	; 0x3eb6 <PDSap+0x230>
    3eb4:	19 86       	std	Y+9, r1	; 0x09
    3eb6:	29 85       	ldd	r18, Y+9	; 0x09
    3eb8:	2a 83       	std	Y+2, r18	; 0x02
			txLen[1] |= (lState & 0x02) ? 0x40 : 0;
    3eba:	8a 81       	ldd	r24, Y+2	; 0x02
    3ebc:	88 87       	std	Y+8, r24	; 0x08
    3ebe:	80 91 b1 0e 	lds	r24, 0x0EB1
    3ec2:	88 2f       	mov	r24, r24
    3ec4:	90 e0       	ldi	r25, 0x00	; 0
    3ec6:	82 70       	andi	r24, 0x02	; 2
    3ec8:	90 70       	andi	r25, 0x00	; 0
    3eca:	00 97       	sbiw	r24, 0x00	; 0
    3ecc:	19 f0       	breq	.+6      	; 0x3ed4 <PDSap+0x24e>
    3ece:	30 e4       	ldi	r19, 0x40	; 64
    3ed0:	3f 83       	std	Y+7, r19	; 0x07
    3ed2:	01 c0       	rjmp	.+2      	; 0x3ed6 <PDSap+0x250>
    3ed4:	1f 82       	std	Y+7, r1	; 0x07
    3ed6:	88 85       	ldd	r24, Y+8	; 0x08
    3ed8:	9f 81       	ldd	r25, Y+7	; 0x07
    3eda:	89 2b       	or	r24, r25
    3edc:	8a 83       	std	Y+2, r24	; 0x02
			txLen[1] |= (lState & 0x04) ? 0x80 : 0;
    3ede:	8a 81       	ldd	r24, Y+2	; 0x02
    3ee0:	8e 83       	std	Y+6, r24	; 0x06
    3ee2:	80 91 b1 0e 	lds	r24, 0x0EB1
    3ee6:	88 2f       	mov	r24, r24
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	84 70       	andi	r24, 0x04	; 4
    3eec:	90 70       	andi	r25, 0x00	; 0
    3eee:	00 97       	sbiw	r24, 0x00	; 0
    3ef0:	19 f0       	breq	.+6      	; 0x3ef8 <PDSap+0x272>
    3ef2:	20 e8       	ldi	r18, 0x80	; 128
    3ef4:	2d 83       	std	Y+5, r18	; 0x05
    3ef6:	01 c0       	rjmp	.+2      	; 0x3efa <PDSap+0x274>
    3ef8:	1d 82       	std	Y+5, r1	; 0x05
    3efa:	8e 81       	ldd	r24, Y+6	; 0x06
    3efc:	3d 81       	ldd	r19, Y+5	; 0x05
    3efe:	83 2b       	or	r24, r19
    3f00:	8a 83       	std	Y+2, r24	; 0x02

			NTRXSPIWrite (NA_RamTxLength_O, txLen, 2);
    3f02:	88 e9       	ldi	r24, 0x98	; 152
    3f04:	9e 01       	movw	r18, r28
    3f06:	2f 5f       	subi	r18, 0xFF	; 255
    3f08:	3f 4f       	sbci	r19, 0xFF	; 255
    3f0a:	b9 01       	movw	r22, r18
    3f0c:	42 e0       	ldi	r20, 0x02	; 2
    3f0e:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
			ntrxState = TxSEND;
    3f12:	81 e0       	ldi	r24, 0x01	; 1
    3f14:	80 93 05 0f 	sts	0x0F05, r24

			/* mark buffers as valid and start transmission */
			NTRXSPIWriteByte (NA_TxBufferCmd_O, (1 << NA_TxCmdStart_B) | (0x03 << NA_TxBufferCmd_LSB));
    3f18:	85 e5       	ldi	r24, 0x55	; 85
    3f1a:	6e e0       	ldi	r22, 0x0E	; 14
    3f1c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
			TRIGGER_LED_TX();
    3f20:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    3f24:	dc 01       	movw	r26, r24
    3f26:	cb 01       	movw	r24, r22
    3f28:	c2 96       	adiw	r24, 0x32	; 50
    3f2a:	a1 1d       	adc	r26, r1
    3f2c:	b1 1d       	adc	r27, r1
    3f2e:	80 93 01 0e 	sts	0x0E01, r24
    3f32:	90 93 02 0e 	sts	0x0E02, r25
    3f36:	a0 93 03 0e 	sts	0x0E03, r26
    3f3a:	b0 93 04 0e 	sts	0x0E04, r27
    3f3e:	a2 e2       	ldi	r26, 0x22	; 34
    3f40:	b0 e0       	ldi	r27, 0x00	; 0
    3f42:	e2 e2       	ldi	r30, 0x22	; 34
    3f44:	f0 e0       	ldi	r31, 0x00	; 0
    3f46:	80 81       	ld	r24, Z
    3f48:	8f 77       	andi	r24, 0x7F	; 127
    3f4a:	8c 93       	st	X, r24

			txSendMsg = msg;
    3f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f50:	90 93 ff 0d 	sts	0x0DFF, r25
    3f54:	80 93 fe 0d 	sts	0x0DFE, r24
    3f58:	86 c0       	rjmp	.+268    	; 0x4066 <PDSap+0x3e0>
			break;

		case PD_RANGING_REQUEST :
		case PD_RANGING_FAST_REQUEST :
			/* transmitter still busy */
			rangingPIB.distance = -1.0;
    3f5a:	80 e0       	ldi	r24, 0x00	; 0
    3f5c:	90 e0       	ldi	r25, 0x00	; 0
    3f5e:	a0 e8       	ldi	r26, 0x80	; 128
    3f60:	bf eb       	ldi	r27, 0xBF	; 191
    3f62:	80 93 8e 0f 	sts	0x0F8E, r24
    3f66:	90 93 8f 0f 	sts	0x0F8F, r25
    3f6a:	a0 93 90 0f 	sts	0x0F90, r26
    3f6e:	b0 93 91 0f 	sts	0x0F91, r27
			rangingPIB.error = STAT_NO_ERROR;
    3f72:	10 92 8c 0f 	sts	0x0F8C, r1

			if (txSendMsg != NULL)
    3f76:	80 91 fe 0d 	lds	r24, 0x0DFE
    3f7a:	90 91 ff 0d 	lds	r25, 0x0DFF
    3f7e:	00 97       	sbiw	r24, 0x00	; 0
    3f80:	f1 f0       	breq	.+60     	; 0x3fbe <PDSap+0x338>
			{

				msg->prim = PD_RANGING_CONFIRM;
    3f82:	eb 81       	ldd	r30, Y+3	; 0x03
    3f84:	fc 81       	ldd	r31, Y+4	; 0x04
    3f86:	82 e1       	ldi	r24, 0x12	; 18
    3f88:	80 83       	st	Z, r24
				msg->status = PHY_BUSY_TX;
    3f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f8e:	fc 01       	movw	r30, r24
    3f90:	e8 57       	subi	r30, 0x78	; 120
    3f92:	ff 4f       	sbci	r31, 0xFF	; 255
    3f94:	82 e0       	ldi	r24, 0x02	; 2
    3f96:	80 83       	st	Z, r24
				memcpy(msg->data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    3f98:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9c:	08 96       	adiw	r24, 0x08	; 8
    3f9e:	2c e8       	ldi	r18, 0x8C	; 140
    3fa0:	3f e0       	ldi	r19, 0x0F	; 15
    3fa2:	b9 01       	movw	r22, r18
    3fa4:	46 e0       	ldi	r20, 0x06	; 6
    3fa6:	50 e0       	ldi	r21, 0x00	; 0
    3fa8:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				msg->len = sizeof(RangingPIB);
    3fac:	eb 81       	ldd	r30, Y+3	; 0x03
    3fae:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb0:	86 e0       	ldi	r24, 0x06	; 6
    3fb2:	87 83       	std	Z+7, r24	; 0x07
				SendMsgUp (msg);
    3fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fb8:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    3fbc:	54 c0       	rjmp	.+168    	; 0x4066 <PDSap+0x3e0>
				return;
			}

			if (lState != RANGING_READY)
    3fbe:	80 91 b1 0e 	lds	r24, 0x0EB1
    3fc2:	88 23       	and	r24, r24
    3fc4:	09 f1       	breq	.+66     	; 0x4008 <PDSap+0x382>
			{
				txSendMsg = NULL;
    3fc6:	10 92 ff 0d 	sts	0x0DFF, r1
    3fca:	10 92 fe 0d 	sts	0x0DFE, r1

				msg->prim = PD_RANGING_CONFIRM;
    3fce:	eb 81       	ldd	r30, Y+3	; 0x03
    3fd0:	fc 81       	ldd	r31, Y+4	; 0x04
    3fd2:	82 e1       	ldi	r24, 0x12	; 18
    3fd4:	80 83       	st	Z, r24
				msg->status = PHY_BUSY;
    3fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fda:	fc 01       	movw	r30, r24
    3fdc:	e8 57       	subi	r30, 0x78	; 120
    3fde:	ff 4f       	sbci	r31, 0xFF	; 255
    3fe0:	10 82       	st	Z, r1
				memcpy(msg->data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    3fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fe4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fe6:	08 96       	adiw	r24, 0x08	; 8
    3fe8:	2c e8       	ldi	r18, 0x8C	; 140
    3fea:	3f e0       	ldi	r19, 0x0F	; 15
    3fec:	b9 01       	movw	r22, r18
    3fee:	46 e0       	ldi	r20, 0x06	; 6
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				msg->len = sizeof(RangingPIB);
    3ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    3ffa:	86 e0       	ldi	r24, 0x06	; 6
    3ffc:	87 83       	std	Z+7, r24	; 0x07
				SendMsgUp (msg);
    3ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    4000:	9c 81       	ldd	r25, Y+4	; 0x04
    4002:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    4006:	2f c0       	rjmp	.+94     	; 0x4066 <PDSap+0x3e0>
				return;
			}

			memcpy(rDest, msg->addr, 6);
    4008:	8b 81       	ldd	r24, Y+3	; 0x03
    400a:	9c 81       	ldd	r25, Y+4	; 0x04
    400c:	9c 01       	movw	r18, r24
    400e:	2f 5f       	subi	r18, 0xFF	; 255
    4010:	3f 4f       	sbci	r19, 0xFF	; 255
    4012:	84 eb       	ldi	r24, 0xB4	; 180
    4014:	9e e0       	ldi	r25, 0x0E	; 14
    4016:	b9 01       	movw	r22, r18
    4018:	46 e0       	ldi	r20, 0x06	; 6
    401a:	50 e0       	ldi	r21, 0x00	; 0
    401c:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>

			if (msg->prim == PD_RANGING_REQUEST)
    4020:	eb 81       	ldd	r30, Y+3	; 0x03
    4022:	fc 81       	ldd	r31, Y+4	; 0x04
    4024:	80 81       	ld	r24, Z
    4026:	8e 30       	cpi	r24, 0x0E	; 14
    4028:	69 f4       	brne	.+26     	; 0x4044 <PDSap+0x3be>
			{
				lState = RANGING_START;
    402a:	81 e0       	ldi	r24, 0x01	; 1
    402c:	80 93 b1 0e 	sts	0x0EB1, r24
				RangingMode(RANGING_START, msg->addr);
    4030:	8b 81       	ldd	r24, Y+3	; 0x03
    4032:	9c 81       	ldd	r25, Y+4	; 0x04
    4034:	9c 01       	movw	r18, r24
    4036:	2f 5f       	subi	r18, 0xFF	; 255
    4038:	3f 4f       	sbci	r19, 0xFF	; 255
    403a:	81 e0       	ldi	r24, 0x01	; 1
    403c:	b9 01       	movw	r22, r18
    403e:	0e 94 ae 39 	call	0x735c	; 0x735c <RangingMode>
    4042:	11 c0       	rjmp	.+34     	; 0x4066 <PDSap+0x3e0>
			}
			else if (msg->prim == PD_RANGING_FAST_REQUEST)
    4044:	eb 81       	ldd	r30, Y+3	; 0x03
    4046:	fc 81       	ldd	r31, Y+4	; 0x04
    4048:	80 81       	ld	r24, Z
    404a:	84 31       	cpi	r24, 0x14	; 20
    404c:	61 f4       	brne	.+24     	; 0x4066 <PDSap+0x3e0>
			{
				lState = RANGING_FAST_START;
    404e:	84 e0       	ldi	r24, 0x04	; 4
    4050:	80 93 b1 0e 	sts	0x0EB1, r24
				RangingMode(RANGING_FAST_START, msg->addr);
    4054:	8b 81       	ldd	r24, Y+3	; 0x03
    4056:	9c 81       	ldd	r25, Y+4	; 0x04
    4058:	9c 01       	movw	r18, r24
    405a:	2f 5f       	subi	r18, 0xFF	; 255
    405c:	3f 4f       	sbci	r19, 0xFF	; 255
    405e:	84 e0       	ldi	r24, 0x04	; 4
    4060:	b9 01       	movw	r22, r18
    4062:	0e 94 ae 39 	call	0x735c	; 0x735c <RangingMode>
			break;

		default:
			break;
	}
}
    4066:	2b 96       	adiw	r28, 0x0b	; 11
    4068:	0f b6       	in	r0, 0x3f	; 63
    406a:	f8 94       	cli
    406c:	de bf       	out	0x3e, r29	; 62
    406e:	0f be       	out	0x3f, r0	; 63
    4070:	cd bf       	out	0x3d, r28	; 61
    4072:	cf 91       	pop	r28
    4074:	df 91       	pop	r29
    4076:	08 95       	ret

00004078 <TestmodeOff>:
 * Note: Only one test mode at a time can be enabled.
 */
/****************************************************************************/
void TestmodeOff (void )
/****************************************************************************/
{
    4078:	df 93       	push	r29
    407a:	cf 93       	push	r28
    407c:	00 d0       	rcall	.+0      	; 0x407e <TestmodeOff+0x6>
    407e:	cd b7       	in	r28, 0x3d	; 61
    4080:	de b7       	in	r29, 0x3e	; 62
	switch (phyPIB.testmode)
    4082:	80 91 dd 0e 	lds	r24, 0x0EDD
    4086:	28 2f       	mov	r18, r24
    4088:	30 e0       	ldi	r19, 0x00	; 0
    408a:	3a 83       	std	Y+2, r19	; 0x02
    408c:	29 83       	std	Y+1, r18	; 0x01
    408e:	89 81       	ldd	r24, Y+1	; 0x01
    4090:	9a 81       	ldd	r25, Y+2	; 0x02
    4092:	81 30       	cpi	r24, 0x01	; 1
    4094:	91 05       	cpc	r25, r1
    4096:	31 f0       	breq	.+12     	; 0x40a4 <TestmodeOff+0x2c>
    4098:	29 81       	ldd	r18, Y+1	; 0x01
    409a:	3a 81       	ldd	r19, Y+2	; 0x02
    409c:	22 30       	cpi	r18, 0x02	; 2
    409e:	31 05       	cpc	r19, r1
    40a0:	29 f0       	breq	.+10     	; 0x40ac <TestmodeOff+0x34>
    40a2:	07 c0       	rjmp	.+14     	; 0x40b2 <TestmodeOff+0x3a>
	{
		case PHY_CONTINUOUS_MODE: 	NTRXSetTestChirpMode (FALSE);
    40a4:	80 e0       	ldi	r24, 0x00	; 0
    40a6:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
    40aa:	03 c0       	rjmp	.+6      	; 0x40b2 <TestmodeOff+0x3a>
									break;

		case PHY_CARRIER_MODE: 		NTRXSetTestCarrierMode (FALSE);
    40ac:	80 e0       	ldi	r24, 0x00	; 0
    40ae:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
									break;

		default:					break;
	}
}
    40b2:	0f 90       	pop	r0
    40b4:	0f 90       	pop	r0
    40b6:	cf 91       	pop	r28
    40b8:	df 91       	pop	r29
    40ba:	08 95       	ret

000040bc <PLMESap>:
 * @ref PHY_FRAME_TYPE : set frame types that will be handled by the nanoLOC chip
 */
/****************************************************************************/
void PLMESap (MyMsgT *msg)
/****************************************************************************/
{
    40bc:	df 93       	push	r29
    40be:	cf 93       	push	r28
    40c0:	cd b7       	in	r28, 0x3d	; 61
    40c2:	de b7       	in	r29, 0x3e	; 62
    40c4:	6d 97       	sbiw	r28, 0x1d	; 29
    40c6:	0f b6       	in	r0, 0x3f	; 63
    40c8:	f8 94       	cli
    40ca:	de bf       	out	0x3e, r29	; 62
    40cc:	0f be       	out	0x3f, r0	; 63
    40ce:	cd bf       	out	0x3d, r28	; 61
    40d0:	9e 83       	std	Y+6, r25	; 0x06
    40d2:	8d 83       	std	Y+5, r24	; 0x05
	MyByte8T bw = 0, sd = 0, br = 0, cf = 0;
    40d4:	1c 82       	std	Y+4, r1	; 0x04
    40d6:	1b 82       	std	Y+3, r1	; 0x03
    40d8:	1a 82       	std	Y+2, r1	; 0x02
    40da:	19 82       	std	Y+1, r1	; 0x01


	switch (msg->prim)
    40dc:	ed 81       	ldd	r30, Y+5	; 0x05
    40de:	fe 81       	ldd	r31, Y+6	; 0x06
    40e0:	80 81       	ld	r24, Z
    40e2:	28 2f       	mov	r18, r24
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	3d 8f       	std	Y+29, r19	; 0x1d
    40e8:	2c 8f       	std	Y+28, r18	; 0x1c
    40ea:	4c 8d       	ldd	r20, Y+28	; 0x1c
    40ec:	5d 8d       	ldd	r21, Y+29	; 0x1d
    40ee:	49 30       	cpi	r20, 0x09	; 9
    40f0:	51 05       	cpc	r21, r1
    40f2:	41 f0       	breq	.+16     	; 0x4104 <PLMESap+0x48>
    40f4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    40f6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    40f8:	8b 30       	cpi	r24, 0x0B	; 11
    40fa:	91 05       	cpc	r25, r1
    40fc:	09 f4       	brne	.+2      	; 0x4100 <PLMESap+0x44>
    40fe:	59 c1       	rjmp	.+690    	; 0x43b2 <PLMESap+0x2f6>
    4100:	0c 94 43 28 	jmp	0x5086	; 0x5086 <PLMESap+0xfca>
	{
		case PLME_GET_REQUEST:  msg->prim = PLME_GET_CONFIRM;
    4104:	ed 81       	ldd	r30, Y+5	; 0x05
    4106:	fe 81       	ldd	r31, Y+6	; 0x06
    4108:	8a e0       	ldi	r24, 0x0A	; 10
    410a:	80 83       	st	Z, r24
								msg->status = PHY_SUCCESS;
    410c:	8d 81       	ldd	r24, Y+5	; 0x05
    410e:	9e 81       	ldd	r25, Y+6	; 0x06
    4110:	fc 01       	movw	r30, r24
    4112:	e8 57       	subi	r30, 0x78	; 120
    4114:	ff 4f       	sbci	r31, 0xFF	; 255
    4116:	87 e0       	ldi	r24, 0x07	; 7
    4118:	80 83       	st	Z, r24
								switch (msg->attribute)
    411a:	8d 81       	ldd	r24, Y+5	; 0x05
    411c:	9e 81       	ldd	r25, Y+6	; 0x06
    411e:	fc 01       	movw	r30, r24
    4120:	e5 57       	subi	r30, 0x75	; 117
    4122:	ff 4f       	sbci	r31, 0xFF	; 255
    4124:	80 81       	ld	r24, Z
    4126:	28 2f       	mov	r18, r24
    4128:	30 e0       	ldi	r19, 0x00	; 0
    412a:	3b 8f       	std	Y+27, r19	; 0x1b
    412c:	2a 8f       	std	Y+26, r18	; 0x1a
    412e:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4130:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4132:	45 37       	cpi	r20, 0x75	; 117
    4134:	51 05       	cpc	r21, r1
    4136:	09 f4       	brne	.+2      	; 0x413a <PLMESap+0x7e>
    4138:	d1 c0       	rjmp	.+418    	; 0x42dc <PLMESap+0x220>
    413a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    413c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    413e:	86 37       	cpi	r24, 0x76	; 118
    4140:	91 05       	cpc	r25, r1
    4142:	5c f5       	brge	.+86     	; 0x419a <PLMESap+0xde>
    4144:	2a 8d       	ldd	r18, Y+26	; 0x1a
    4146:	3b 8d       	ldd	r19, Y+27	; 0x1b
    4148:	21 37       	cpi	r18, 0x71	; 113
    414a:	31 05       	cpc	r19, r1
    414c:	09 f4       	brne	.+2      	; 0x4150 <PLMESap+0x94>
    414e:	98 c0       	rjmp	.+304    	; 0x4280 <PLMESap+0x1c4>
    4150:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4152:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4154:	42 37       	cpi	r20, 0x72	; 114
    4156:	51 05       	cpc	r21, r1
    4158:	9c f4       	brge	.+38     	; 0x4180 <PLMESap+0xc4>
    415a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    415c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    415e:	82 30       	cpi	r24, 0x02	; 2
    4160:	91 05       	cpc	r25, r1
    4162:	09 f4       	brne	.+2      	; 0x4166 <PLMESap+0xaa>
    4164:	75 c0       	rjmp	.+234    	; 0x4250 <PLMESap+0x194>
    4166:	2a 8d       	ldd	r18, Y+26	; 0x1a
    4168:	3b 8d       	ldd	r19, Y+27	; 0x1b
    416a:	20 37       	cpi	r18, 0x70	; 112
    416c:	31 05       	cpc	r19, r1
    416e:	09 f4       	brne	.+2      	; 0x4172 <PLMESap+0xb6>
    4170:	7b c0       	rjmp	.+246    	; 0x4268 <PLMESap+0x1ac>
    4172:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4174:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4176:	41 15       	cp	r20, r1
    4178:	51 05       	cpc	r21, r1
    417a:	09 f4       	brne	.+2      	; 0x417e <PLMESap+0xc2>
    417c:	43 c0       	rjmp	.+134    	; 0x4204 <PLMESap+0x148>
    417e:	11 c1       	rjmp	.+546    	; 0x43a2 <PLMESap+0x2e6>
    4180:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4182:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4184:	83 37       	cpi	r24, 0x73	; 115
    4186:	91 05       	cpc	r25, r1
    4188:	09 f4       	brne	.+2      	; 0x418c <PLMESap+0xd0>
    418a:	92 c0       	rjmp	.+292    	; 0x42b0 <PLMESap+0x1f4>
    418c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    418e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    4190:	24 37       	cpi	r18, 0x74	; 116
    4192:	31 05       	cpc	r19, r1
    4194:	0c f0       	brlt	.+2      	; 0x4198 <PLMESap+0xdc>
    4196:	97 c0       	rjmp	.+302    	; 0x42c6 <PLMESap+0x20a>
    4198:	7f c0       	rjmp	.+254    	; 0x4298 <PLMESap+0x1dc>
    419a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    419c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    419e:	4a 37       	cpi	r20, 0x7A	; 122
    41a0:	51 05       	cpc	r21, r1
    41a2:	09 f4       	brne	.+2      	; 0x41a6 <PLMESap+0xea>
    41a4:	b3 c0       	rjmp	.+358    	; 0x430c <PLMESap+0x250>
    41a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    41a8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    41aa:	8b 37       	cpi	r24, 0x7B	; 123
    41ac:	91 05       	cpc	r25, r1
    41ae:	94 f4       	brge	.+36     	; 0x41d4 <PLMESap+0x118>
    41b0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    41b2:	3b 8d       	ldd	r19, Y+27	; 0x1b
    41b4:	28 37       	cpi	r18, 0x78	; 120
    41b6:	31 05       	cpc	r19, r1
    41b8:	09 f4       	brne	.+2      	; 0x41bc <PLMESap+0x100>
    41ba:	b4 c0       	rjmp	.+360    	; 0x4324 <PLMESap+0x268>
    41bc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    41be:	5b 8d       	ldd	r21, Y+27	; 0x1b
    41c0:	49 37       	cpi	r20, 0x79	; 121
    41c2:	51 05       	cpc	r21, r1
    41c4:	64 f5       	brge	.+88     	; 0x421e <PLMESap+0x162>
    41c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    41c8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    41ca:	86 37       	cpi	r24, 0x76	; 118
    41cc:	91 05       	cpc	r25, r1
    41ce:	09 f4       	brne	.+2      	; 0x41d2 <PLMESap+0x116>
    41d0:	91 c0       	rjmp	.+290    	; 0x42f4 <PLMESap+0x238>
    41d2:	e7 c0       	rjmp	.+462    	; 0x43a2 <PLMESap+0x2e6>
    41d4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    41d6:	3b 8d       	ldd	r19, Y+27	; 0x1b
    41d8:	2c 37       	cpi	r18, 0x7C	; 124
    41da:	31 05       	cpc	r19, r1
    41dc:	09 f4       	brne	.+2      	; 0x41e0 <PLMESap+0x124>
    41de:	c9 c0       	rjmp	.+402    	; 0x4372 <PLMESap+0x2b6>
    41e0:	4a 8d       	ldd	r20, Y+26	; 0x1a
    41e2:	5b 8d       	ldd	r21, Y+27	; 0x1b
    41e4:	4c 37       	cpi	r20, 0x7C	; 124
    41e6:	51 05       	cpc	r21, r1
    41e8:	0c f4       	brge	.+2      	; 0x41ec <PLMESap+0x130>
    41ea:	b7 c0       	rjmp	.+366    	; 0x435a <PLMESap+0x29e>
    41ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    41ee:	9b 8d       	ldd	r25, Y+27	; 0x1b
    41f0:	8d 37       	cpi	r24, 0x7D	; 125
    41f2:	91 05       	cpc	r25, r1
    41f4:	09 f4       	brne	.+2      	; 0x41f8 <PLMESap+0x13c>
    41f6:	c9 c0       	rjmp	.+402    	; 0x438a <PLMESap+0x2ce>
    41f8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    41fa:	3b 8d       	ldd	r19, Y+27	; 0x1b
    41fc:	2f 37       	cpi	r18, 0x7F	; 127
    41fe:	31 05       	cpc	r19, r1
    4200:	d9 f0       	breq	.+54     	; 0x4238 <PLMESap+0x17c>
    4202:	cf c0       	rjmp	.+414    	; 0x43a2 <PLMESap+0x2e6>
								{
									case PHY_CURRENT_CHANNEL: 		msg->value = phyPIB.currentChannel;
    4204:	80 91 bc 0e 	lds	r24, 0x0EBC
    4208:	28 2f       	mov	r18, r24
    420a:	30 e0       	ldi	r19, 0x00	; 0
    420c:	8d 81       	ldd	r24, Y+5	; 0x05
    420e:	9e 81       	ldd	r25, Y+6	; 0x06
    4210:	fc 01       	movw	r30, r24
    4212:	e7 57       	subi	r30, 0x77	; 119
    4214:	ff 4f       	sbci	r31, 0xFF	; 255
    4216:	31 83       	std	Z+1, r19	; 0x01
    4218:	20 83       	st	Z, r18
    421a:	0c 94 43 28 	jmp	0x5086	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_TRX_MODE:				msg->value = phyPIB.trxMode;
    421e:	80 91 d2 0e 	lds	r24, 0x0ED2
    4222:	28 2f       	mov	r18, r24
    4224:	30 e0       	ldi	r19, 0x00	; 0
    4226:	8d 81       	ldd	r24, Y+5	; 0x05
    4228:	9e 81       	ldd	r25, Y+6	; 0x06
    422a:	fc 01       	movw	r30, r24
    422c:	e7 57       	subi	r30, 0x77	; 119
    422e:	ff 4f       	sbci	r31, 0xFF	; 255
    4230:	31 83       	std	Z+1, r19	; 0x01
    4232:	20 83       	st	Z, r18
    4234:	0c 94 43 28 	jmp	0x5086	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_LOG_CHANNEL:			msg->value = phyPIB.logChannel;
    4238:	80 91 bd 0e 	lds	r24, 0x0EBD
    423c:	28 2f       	mov	r18, r24
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	8d 81       	ldd	r24, Y+5	; 0x05
    4242:	9e 81       	ldd	r25, Y+6	; 0x06
    4244:	fc 01       	movw	r30, r24
    4246:	e7 57       	subi	r30, 0x77	; 119
    4248:	ff 4f       	sbci	r31, 0xFF	; 255
    424a:	31 83       	std	Z+1, r19	; 0x01
    424c:	20 83       	st	Z, r18
    424e:	1b c7       	rjmp	.+3638   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_TX_POWER: 				msg->value = phyPIB.txPower;
    4250:	80 91 be 0e 	lds	r24, 0x0EBE
    4254:	28 2f       	mov	r18, r24
    4256:	30 e0       	ldi	r19, 0x00	; 0
    4258:	8d 81       	ldd	r24, Y+5	; 0x05
    425a:	9e 81       	ldd	r25, Y+6	; 0x06
    425c:	fc 01       	movw	r30, r24
    425e:	e7 57       	subi	r30, 0x77	; 119
    4260:	ff 4f       	sbci	r31, 0xFF	; 255
    4262:	31 83       	std	Z+1, r19	; 0x01
    4264:	20 83       	st	Z, r18
    4266:	0f c7       	rjmp	.+3614   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_ARQ:					msg->value = phyPIB.arqMode;
    4268:	80 91 cf 0e 	lds	r24, 0x0ECF
    426c:	28 2f       	mov	r18, r24
    426e:	30 e0       	ldi	r19, 0x00	; 0
    4270:	8d 81       	ldd	r24, Y+5	; 0x05
    4272:	9e 81       	ldd	r25, Y+6	; 0x06
    4274:	fc 01       	movw	r30, r24
    4276:	e7 57       	subi	r30, 0x77	; 119
    4278:	ff 4f       	sbci	r31, 0xFF	; 255
    427a:	31 83       	std	Z+1, r19	; 0x01
    427c:	20 83       	st	Z, r18
    427e:	03 c7       	rjmp	.+3590   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_ARQ_MAX:				msg->value = phyPIB.arqMax;
    4280:	80 91 ce 0e 	lds	r24, 0x0ECE
    4284:	28 2f       	mov	r18, r24
    4286:	30 e0       	ldi	r19, 0x00	; 0
    4288:	8d 81       	ldd	r24, Y+5	; 0x05
    428a:	9e 81       	ldd	r25, Y+6	; 0x06
    428c:	fc 01       	movw	r30, r24
    428e:	e7 57       	subi	r30, 0x77	; 119
    4290:	ff 4f       	sbci	r31, 0xFF	; 255
    4292:	31 83       	std	Z+1, r19	; 0x01
    4294:	20 83       	st	Z, r18
    4296:	f7 c6       	rjmp	.+3566   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_FEC:					msg->value = phyPIB.fec;
    4298:	80 91 e7 0e 	lds	r24, 0x0EE7
    429c:	28 2f       	mov	r18, r24
    429e:	30 e0       	ldi	r19, 0x00	; 0
    42a0:	8d 81       	ldd	r24, Y+5	; 0x05
    42a2:	9e 81       	ldd	r25, Y+6	; 0x06
    42a4:	fc 01       	movw	r30, r24
    42a6:	e7 57       	subi	r30, 0x77	; 119
    42a8:	ff 4f       	sbci	r31, 0xFF	; 255
    42aa:	31 83       	std	Z+1, r19	; 0x01
    42ac:	20 83       	st	Z, r18
    42ae:	eb c6       	rjmp	.+3542   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_MAC_ADDRESS1:			memcpy (msg->data, phyPIB.macAddr0, 6);
    42b0:	8d 81       	ldd	r24, Y+5	; 0x05
    42b2:	9e 81       	ldd	r25, Y+6	; 0x06
    42b4:	08 96       	adiw	r24, 0x08	; 8
    42b6:	21 ec       	ldi	r18, 0xC1	; 193
    42b8:	3e e0       	ldi	r19, 0x0E	; 14
    42ba:	b9 01       	movw	r22, r18
    42bc:	46 e0       	ldi	r20, 0x06	; 6
    42be:	50 e0       	ldi	r21, 0x00	; 0
    42c0:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
    42c4:	e0 c6       	rjmp	.+3520   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_MAC_ADDRESS2:			memcpy (msg->data, phyPIB.macAddr0, 6);
    42c6:	8d 81       	ldd	r24, Y+5	; 0x05
    42c8:	9e 81       	ldd	r25, Y+6	; 0x06
    42ca:	08 96       	adiw	r24, 0x08	; 8
    42cc:	21 ec       	ldi	r18, 0xC1	; 193
    42ce:	3e e0       	ldi	r19, 0x0E	; 14
    42d0:	b9 01       	movw	r22, r18
    42d2:	46 e0       	ldi	r20, 0x06	; 6
    42d4:	50 e0       	ldi	r21, 0x00	; 0
    42d6:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
    42da:	d5 c6       	rjmp	.+3498   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_TX_ADDR_SELECT:		msg->value = phyPIB.txAddrSel;
    42dc:	80 91 cd 0e 	lds	r24, 0x0ECD
    42e0:	28 2f       	mov	r18, r24
    42e2:	30 e0       	ldi	r19, 0x00	; 0
    42e4:	8d 81       	ldd	r24, Y+5	; 0x05
    42e6:	9e 81       	ldd	r25, Y+6	; 0x06
    42e8:	fc 01       	movw	r30, r24
    42ea:	e7 57       	subi	r30, 0x77	; 119
    42ec:	ff 4f       	sbci	r31, 0xFF	; 255
    42ee:	31 83       	std	Z+1, r19	; 0x01
    42f0:	20 83       	st	Z, r18
    42f2:	c9 c6       	rjmp	.+3474   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_ADDR_MATCHING:			msg->value = phyPIB.addrMatch;
    42f4:	80 91 d0 0e 	lds	r24, 0x0ED0
    42f8:	28 2f       	mov	r18, r24
    42fa:	30 e0       	ldi	r19, 0x00	; 0
    42fc:	8d 81       	ldd	r24, Y+5	; 0x05
    42fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4300:	fc 01       	movw	r30, r24
    4302:	e7 57       	subi	r30, 0x77	; 119
    4304:	ff 4f       	sbci	r31, 0xFF	; 255
    4306:	31 83       	std	Z+1, r19	; 0x01
    4308:	20 83       	st	Z, r18
    430a:	bd c6       	rjmp	.+3450   	; 0x5086 <PLMESap+0xfca>
																	break;


									case PHY_PWR_DOWN_MODE:			msg->value = phyPIB.pwrDownMode;
    430c:	80 91 db 0e 	lds	r24, 0x0EDB
    4310:	28 2f       	mov	r18, r24
    4312:	30 e0       	ldi	r19, 0x00	; 0
    4314:	8d 81       	ldd	r24, Y+5	; 0x05
    4316:	9e 81       	ldd	r25, Y+6	; 0x06
    4318:	fc 01       	movw	r30, r24
    431a:	e7 57       	subi	r30, 0x77	; 119
    431c:	ff 4f       	sbci	r31, 0xFF	; 255
    431e:	31 83       	std	Z+1, r19	; 0x01
    4320:	20 83       	st	Z, r18
    4322:	b1 c6       	rjmp	.+3426   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_RECALIBRATION:			msg->value = phyPIB.recalInterval / 1000;
    4324:	80 91 d3 0e 	lds	r24, 0x0ED3
    4328:	90 91 d4 0e 	lds	r25, 0x0ED4
    432c:	a0 91 d5 0e 	lds	r26, 0x0ED5
    4330:	b0 91 d6 0e 	lds	r27, 0x0ED6
    4334:	28 ee       	ldi	r18, 0xE8	; 232
    4336:	33 e0       	ldi	r19, 0x03	; 3
    4338:	40 e0       	ldi	r20, 0x00	; 0
    433a:	50 e0       	ldi	r21, 0x00	; 0
    433c:	bc 01       	movw	r22, r24
    433e:	cd 01       	movw	r24, r26
    4340:	0e 94 6b 43 	call	0x86d6	; 0x86d6 <__udivmodsi4>
    4344:	da 01       	movw	r26, r20
    4346:	c9 01       	movw	r24, r18
    4348:	9c 01       	movw	r18, r24
    434a:	8d 81       	ldd	r24, Y+5	; 0x05
    434c:	9e 81       	ldd	r25, Y+6	; 0x06
    434e:	fc 01       	movw	r30, r24
    4350:	e7 57       	subi	r30, 0x77	; 119
    4352:	ff 4f       	sbci	r31, 0xFF	; 255
    4354:	31 83       	std	Z+1, r19	; 0x01
    4356:	20 83       	st	Z, r18
    4358:	96 c6       	rjmp	.+3372   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_FRAME_TYPE:			msg->value = phyPIB.frameType;
    435a:	80 91 dc 0e 	lds	r24, 0x0EDC
    435e:	28 2f       	mov	r18, r24
    4360:	30 e0       	ldi	r19, 0x00	; 0
    4362:	8d 81       	ldd	r24, Y+5	; 0x05
    4364:	9e 81       	ldd	r25, Y+6	; 0x06
    4366:	fc 01       	movw	r30, r24
    4368:	e7 57       	subi	r30, 0x77	; 119
    436a:	ff 4f       	sbci	r31, 0xFF	; 255
    436c:	31 83       	std	Z+1, r19	; 0x01
    436e:	20 83       	st	Z, r18
    4370:	8a c6       	rjmp	.+3348   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_TESTMODE:				msg->value = phyPIB.testmode;
    4372:	80 91 dd 0e 	lds	r24, 0x0EDD
    4376:	28 2f       	mov	r18, r24
    4378:	30 e0       	ldi	r19, 0x00	; 0
    437a:	8d 81       	ldd	r24, Y+5	; 0x05
    437c:	9e 81       	ldd	r25, Y+6	; 0x06
    437e:	fc 01       	movw	r30, r24
    4380:	e7 57       	subi	r30, 0x77	; 119
    4382:	ff 4f       	sbci	r31, 0xFF	; 255
    4384:	31 83       	std	Z+1, r19	; 0x01
    4386:	20 83       	st	Z, r18
    4388:	7e c6       	rjmp	.+3324   	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_RX_STATE:				msg->value = phyPIB.rxState;
    438a:	80 91 bf 0e 	lds	r24, 0x0EBF
    438e:	28 2f       	mov	r18, r24
    4390:	30 e0       	ldi	r19, 0x00	; 0
    4392:	8d 81       	ldd	r24, Y+5	; 0x05
    4394:	9e 81       	ldd	r25, Y+6	; 0x06
    4396:	fc 01       	movw	r30, r24
    4398:	e7 57       	subi	r30, 0x77	; 119
    439a:	ff 4f       	sbci	r31, 0xFF	; 255
    439c:	31 83       	std	Z+1, r19	; 0x01
    439e:	20 83       	st	Z, r18
    43a0:	72 c6       	rjmp	.+3300   	; 0x5086 <PLMESap+0xfca>
																	break;

									default: 						msg->status = PHY_UNSUPPORTED_ATTRIBUTE;
    43a2:	8d 81       	ldd	r24, Y+5	; 0x05
    43a4:	9e 81       	ldd	r25, Y+6	; 0x06
    43a6:	fc 01       	movw	r30, r24
    43a8:	e8 57       	subi	r30, 0x78	; 120
    43aa:	ff 4f       	sbci	r31, 0xFF	; 255
    43ac:	8a e0       	ldi	r24, 0x0A	; 10
    43ae:	80 83       	st	Z, r24
    43b0:	6a c6       	rjmp	.+3284   	; 0x5086 <PLMESap+0xfca>
																	break;
								}
								SendCfgUp (msg);
								break;

		case PLME_SET_REQUEST:  msg->prim = PLME_SET_CONFIRM;
    43b2:	ed 81       	ldd	r30, Y+5	; 0x05
    43b4:	fe 81       	ldd	r31, Y+6	; 0x06
    43b6:	8c e0       	ldi	r24, 0x0C	; 12
    43b8:	80 83       	st	Z, r24
								msg->status = PHY_SUCCESS;
    43ba:	8d 81       	ldd	r24, Y+5	; 0x05
    43bc:	9e 81       	ldd	r25, Y+6	; 0x06
    43be:	fc 01       	movw	r30, r24
    43c0:	e8 57       	subi	r30, 0x78	; 120
    43c2:	ff 4f       	sbci	r31, 0xFF	; 255
    43c4:	87 e0       	ldi	r24, 0x07	; 7
    43c6:	80 83       	st	Z, r24
								switch (msg->attribute)
    43c8:	8d 81       	ldd	r24, Y+5	; 0x05
    43ca:	9e 81       	ldd	r25, Y+6	; 0x06
    43cc:	fc 01       	movw	r30, r24
    43ce:	e5 57       	subi	r30, 0x75	; 117
    43d0:	ff 4f       	sbci	r31, 0xFF	; 255
    43d2:	80 81       	ld	r24, Z
    43d4:	48 2f       	mov	r20, r24
    43d6:	50 e0       	ldi	r21, 0x00	; 0
    43d8:	59 8f       	std	Y+25, r21	; 0x19
    43da:	48 8f       	std	Y+24, r20	; 0x18
    43dc:	88 8d       	ldd	r24, Y+24	; 0x18
    43de:	99 8d       	ldd	r25, Y+25	; 0x19
    43e0:	86 37       	cpi	r24, 0x76	; 118
    43e2:	91 05       	cpc	r25, r1
    43e4:	09 f4       	brne	.+2      	; 0x43e8 <PLMESap+0x32c>
    43e6:	b1 c4       	rjmp	.+2402   	; 0x4d4a <PLMESap+0xc8e>
    43e8:	28 8d       	ldd	r18, Y+24	; 0x18
    43ea:	39 8d       	ldd	r19, Y+25	; 0x19
    43ec:	27 37       	cpi	r18, 0x77	; 119
    43ee:	31 05       	cpc	r19, r1
    43f0:	b4 f5       	brge	.+108    	; 0x445e <PLMESap+0x3a2>
    43f2:	48 8d       	ldd	r20, Y+24	; 0x18
    43f4:	59 8d       	ldd	r21, Y+25	; 0x19
    43f6:	41 37       	cpi	r20, 0x71	; 113
    43f8:	51 05       	cpc	r21, r1
    43fa:	09 f4       	brne	.+2      	; 0x43fe <PLMESap+0x342>
    43fc:	78 c3       	rjmp	.+1776   	; 0x4aee <PLMESap+0xa32>
    43fe:	88 8d       	ldd	r24, Y+24	; 0x18
    4400:	99 8d       	ldd	r25, Y+25	; 0x19
    4402:	82 37       	cpi	r24, 0x72	; 114
    4404:	91 05       	cpc	r25, r1
    4406:	94 f4       	brge	.+36     	; 0x442c <PLMESap+0x370>
    4408:	28 8d       	ldd	r18, Y+24	; 0x18
    440a:	39 8d       	ldd	r19, Y+25	; 0x19
    440c:	22 30       	cpi	r18, 0x02	; 2
    440e:	31 05       	cpc	r19, r1
    4410:	09 f4       	brne	.+2      	; 0x4414 <PLMESap+0x358>
    4412:	d5 c2       	rjmp	.+1450   	; 0x49be <PLMESap+0x902>
    4414:	48 8d       	ldd	r20, Y+24	; 0x18
    4416:	59 8d       	ldd	r21, Y+25	; 0x19
    4418:	40 37       	cpi	r20, 0x70	; 112
    441a:	51 05       	cpc	r21, r1
    441c:	09 f4       	brne	.+2      	; 0x4420 <PLMESap+0x364>
    441e:	22 c3       	rjmp	.+1604   	; 0x4a64 <PLMESap+0x9a8>
    4420:	88 8d       	ldd	r24, Y+24	; 0x18
    4422:	99 8d       	ldd	r25, Y+25	; 0x19
    4424:	00 97       	sbiw	r24, 0x00	; 0
    4426:	09 f4       	brne	.+2      	; 0x442a <PLMESap+0x36e>
    4428:	63 c0       	rjmp	.+198    	; 0x44f0 <PLMESap+0x434>
    442a:	26 c6       	rjmp	.+3148   	; 0x5078 <PLMESap+0xfbc>
    442c:	28 8d       	ldd	r18, Y+24	; 0x18
    442e:	39 8d       	ldd	r19, Y+25	; 0x19
    4430:	23 37       	cpi	r18, 0x73	; 115
    4432:	31 05       	cpc	r19, r1
    4434:	09 f4       	brne	.+2      	; 0x4438 <PLMESap+0x37c>
    4436:	f2 c3       	rjmp	.+2020   	; 0x4c1c <PLMESap+0xb60>
    4438:	48 8d       	ldd	r20, Y+24	; 0x18
    443a:	59 8d       	ldd	r21, Y+25	; 0x19
    443c:	43 37       	cpi	r20, 0x73	; 115
    443e:	51 05       	cpc	r21, r1
    4440:	0c f4       	brge	.+2      	; 0x4444 <PLMESap+0x388>
    4442:	a9 c3       	rjmp	.+1874   	; 0x4b96 <PLMESap+0xada>
    4444:	88 8d       	ldd	r24, Y+24	; 0x18
    4446:	99 8d       	ldd	r25, Y+25	; 0x19
    4448:	84 37       	cpi	r24, 0x74	; 116
    444a:	91 05       	cpc	r25, r1
    444c:	09 f4       	brne	.+2      	; 0x4450 <PLMESap+0x394>
    444e:	15 c4       	rjmp	.+2090   	; 0x4c7a <PLMESap+0xbbe>
    4450:	28 8d       	ldd	r18, Y+24	; 0x18
    4452:	39 8d       	ldd	r19, Y+25	; 0x19
    4454:	25 37       	cpi	r18, 0x75	; 117
    4456:	31 05       	cpc	r19, r1
    4458:	09 f4       	brne	.+2      	; 0x445c <PLMESap+0x3a0>
    445a:	3e c4       	rjmp	.+2172   	; 0x4cd8 <PLMESap+0xc1c>
    445c:	0d c6       	rjmp	.+3098   	; 0x5078 <PLMESap+0xfbc>
    445e:	48 8d       	ldd	r20, Y+24	; 0x18
    4460:	59 8d       	ldd	r21, Y+25	; 0x19
    4462:	4c 37       	cpi	r20, 0x7C	; 124
    4464:	51 05       	cpc	r21, r1
    4466:	09 f4       	brne	.+2      	; 0x446a <PLMESap+0x3ae>
    4468:	26 c5       	rjmp	.+2636   	; 0x4eb6 <PLMESap+0xdfa>
    446a:	88 8d       	ldd	r24, Y+24	; 0x18
    446c:	99 8d       	ldd	r25, Y+25	; 0x19
    446e:	8d 37       	cpi	r24, 0x7D	; 125
    4470:	91 05       	cpc	r25, r1
    4472:	fc f4       	brge	.+62     	; 0x44b2 <PLMESap+0x3f6>
    4474:	28 8d       	ldd	r18, Y+24	; 0x18
    4476:	39 8d       	ldd	r19, Y+25	; 0x19
    4478:	29 37       	cpi	r18, 0x79	; 121
    447a:	31 05       	cpc	r19, r1
    447c:	09 f4       	brne	.+2      	; 0x4480 <PLMESap+0x3c4>
    447e:	e3 c0       	rjmp	.+454    	; 0x4646 <PLMESap+0x58a>
    4480:	48 8d       	ldd	r20, Y+24	; 0x18
    4482:	59 8d       	ldd	r21, Y+25	; 0x19
    4484:	4a 37       	cpi	r20, 0x7A	; 122
    4486:	51 05       	cpc	r21, r1
    4488:	3c f4       	brge	.+14     	; 0x4498 <PLMESap+0x3dc>
    448a:	88 8d       	ldd	r24, Y+24	; 0x18
    448c:	99 8d       	ldd	r25, Y+25	; 0x19
    448e:	88 37       	cpi	r24, 0x78	; 120
    4490:	91 05       	cpc	r25, r1
    4492:	09 f4       	brne	.+2      	; 0x4496 <PLMESap+0x3da>
    4494:	93 c4       	rjmp	.+2342   	; 0x4dbc <PLMESap+0xd00>
    4496:	f0 c5       	rjmp	.+3040   	; 0x5078 <PLMESap+0xfbc>
    4498:	28 8d       	ldd	r18, Y+24	; 0x18
    449a:	39 8d       	ldd	r19, Y+25	; 0x19
    449c:	2a 37       	cpi	r18, 0x7A	; 122
    449e:	31 05       	cpc	r19, r1
    44a0:	09 f4       	brne	.+2      	; 0x44a4 <PLMESap+0x3e8>
    44a2:	a9 c4       	rjmp	.+2386   	; 0x4df6 <PLMESap+0xd3a>
    44a4:	48 8d       	ldd	r20, Y+24	; 0x18
    44a6:	59 8d       	ldd	r21, Y+25	; 0x19
    44a8:	4b 37       	cpi	r20, 0x7B	; 123
    44aa:	51 05       	cpc	r21, r1
    44ac:	09 f4       	brne	.+2      	; 0x44b0 <PLMESap+0x3f4>
    44ae:	e8 c4       	rjmp	.+2512   	; 0x4e80 <PLMESap+0xdc4>
    44b0:	e3 c5       	rjmp	.+3014   	; 0x5078 <PLMESap+0xfbc>
    44b2:	88 8d       	ldd	r24, Y+24	; 0x18
    44b4:	99 8d       	ldd	r25, Y+25	; 0x19
    44b6:	8f 37       	cpi	r24, 0x7F	; 127
    44b8:	91 05       	cpc	r25, r1
    44ba:	09 f4       	brne	.+2      	; 0x44be <PLMESap+0x402>
    44bc:	50 c0       	rjmp	.+160    	; 0x455e <PLMESap+0x4a2>
    44be:	28 8d       	ldd	r18, Y+24	; 0x18
    44c0:	39 8d       	ldd	r19, Y+25	; 0x19
    44c2:	20 38       	cpi	r18, 0x80	; 128
    44c4:	31 05       	cpc	r19, r1
    44c6:	3c f4       	brge	.+14     	; 0x44d6 <PLMESap+0x41a>
    44c8:	48 8d       	ldd	r20, Y+24	; 0x18
    44ca:	59 8d       	ldd	r21, Y+25	; 0x19
    44cc:	4d 37       	cpi	r20, 0x7D	; 125
    44ce:	51 05       	cpc	r21, r1
    44d0:	09 f4       	brne	.+2      	; 0x44d4 <PLMESap+0x418>
    44d2:	85 c5       	rjmp	.+2826   	; 0x4fde <PLMESap+0xf22>
    44d4:	d1 c5       	rjmp	.+2978   	; 0x5078 <PLMESap+0xfbc>
    44d6:	88 8d       	ldd	r24, Y+24	; 0x18
    44d8:	99 8d       	ldd	r25, Y+25	; 0x19
    44da:	80 39       	cpi	r24, 0x90	; 144
    44dc:	91 05       	cpc	r25, r1
    44de:	09 f4       	brne	.+2      	; 0x44e2 <PLMESap+0x426>
    44e0:	a3 c5       	rjmp	.+2886   	; 0x5028 <PLMESap+0xf6c>
    44e2:	28 8d       	ldd	r18, Y+24	; 0x18
    44e4:	39 8d       	ldd	r19, Y+25	; 0x19
    44e6:	21 39       	cpi	r18, 0x91	; 145
    44e8:	31 05       	cpc	r19, r1
    44ea:	09 f4       	brne	.+2      	; 0x44ee <PLMESap+0x432>
    44ec:	32 c5       	rjmp	.+2660   	; 0x4f52 <PLMESap+0xe96>
    44ee:	c4 c5       	rjmp	.+2952   	; 0x5078 <PLMESap+0xfbc>
								{
									case PHY_CURRENT_CHANNEL: 		if (msg->value > 16)
    44f0:	8d 81       	ldd	r24, Y+5	; 0x05
    44f2:	9e 81       	ldd	r25, Y+6	; 0x06
    44f4:	fc 01       	movw	r30, r24
    44f6:	e7 57       	subi	r30, 0x77	; 119
    44f8:	ff 4f       	sbci	r31, 0xFF	; 255
    44fa:	80 81       	ld	r24, Z
    44fc:	91 81       	ldd	r25, Z+1	; 0x01
    44fe:	81 31       	cpi	r24, 0x11	; 17
    4500:	91 05       	cpc	r25, r1
    4502:	40 f0       	brcs	.+16     	; 0x4514 <PLMESap+0x458>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    4504:	8d 81       	ldd	r24, Y+5	; 0x05
    4506:	9e 81       	ldd	r25, Y+6	; 0x06
    4508:	fc 01       	movw	r30, r24
    450a:	e8 57       	subi	r30, 0x78	; 120
    450c:	ff 4f       	sbci	r31, 0xFF	; 255
    450e:	85 e0       	ldi	r24, 0x05	; 5
    4510:	80 83       	st	Z, r24
    4512:	b9 c5       	rjmp	.+2930   	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		phyPIB.currentChannel = msg->value;
    4514:	8d 81       	ldd	r24, Y+5	; 0x05
    4516:	9e 81       	ldd	r25, Y+6	; 0x06
    4518:	fc 01       	movw	r30, r24
    451a:	e7 57       	subi	r30, 0x77	; 119
    451c:	ff 4f       	sbci	r31, 0xFF	; 255
    451e:	80 81       	ld	r24, Z
    4520:	91 81       	ldd	r25, Z+1	; 0x01
    4522:	80 93 bc 0e 	sts	0x0EBC, r24
																		switch (phyPIB.currentChannel)
    4526:	80 91 bc 0e 	lds	r24, 0x0EBC
    452a:	88 2f       	mov	r24, r24
    452c:	90 e0       	ldi	r25, 0x00	; 0
    452e:	00 97       	sbiw	r24, 0x00	; 0
    4530:	31 f4       	brne	.+12     	; 0x453e <PLMESap+0x482>
																		{
																			case 0:	bw = NA_80MHz; sd = NA_1us; br = NA_1M_S;
    4532:	1c 82       	std	Y+4, r1	; 0x04
    4534:	81 e0       	ldi	r24, 0x01	; 1
    4536:	8b 83       	std	Y+3, r24	; 0x03
    4538:	81 e0       	ldi	r24, 0x01	; 1
    453a:	8a 83       	std	Y+2, r24	; 0x02
    453c:	06 c0       	rjmp	.+12     	; 0x454a <PLMESap+0x48e>
																					break;
																			default:bw = NA_22MHz; sd = NA_4us; br = NA_250k_S;
    453e:	81 e0       	ldi	r24, 0x01	; 1
    4540:	8c 83       	std	Y+4, r24	; 0x04
    4542:	83 e0       	ldi	r24, 0x03	; 3
    4544:	8b 83       	std	Y+3, r24	; 0x03
    4546:	87 e0       	ldi	r24, 0x07	; 7
    4548:	8a 83       	std	Y+2, r24	; 0x02
																					break;
																		}
																		NTRXSetChannel (phyPIB.currentChannel);
    454a:	80 91 bc 0e 	lds	r24, 0x0EBC
    454e:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <NTRXSetChannel>
																		NTRXSetupTrxMode (bw, sd, br);
    4552:	8c 81       	ldd	r24, Y+4	; 0x04
    4554:	6b 81       	ldd	r22, Y+3	; 0x03
    4556:	4a 81       	ldd	r20, Y+2	; 0x02
    4558:	0e 94 29 30 	call	0x6052	; 0x6052 <NTRXSetupTrxMode>
    455c:	94 c5       	rjmp	.+2856   	; 0x5086 <PLMESap+0xfca>
																	}
																	break;

									case PHY_LOG_CHANNEL:			if (msg->value > CONFIG_MAX_LOG_CHANNEL - 1)
    455e:	8d 81       	ldd	r24, Y+5	; 0x05
    4560:	9e 81       	ldd	r25, Y+6	; 0x06
    4562:	fc 01       	movw	r30, r24
    4564:	e7 57       	subi	r30, 0x77	; 119
    4566:	ff 4f       	sbci	r31, 0xFF	; 255
    4568:	80 81       	ld	r24, Z
    456a:	91 81       	ldd	r25, Z+1	; 0x01
    456c:	84 30       	cpi	r24, 0x04	; 4
    456e:	91 05       	cpc	r25, r1
    4570:	40 f0       	brcs	.+16     	; 0x4582 <PLMESap+0x4c6>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    4572:	8d 81       	ldd	r24, Y+5	; 0x05
    4574:	9e 81       	ldd	r25, Y+6	; 0x06
    4576:	fc 01       	movw	r30, r24
    4578:	e8 57       	subi	r30, 0x78	; 120
    457a:	ff 4f       	sbci	r31, 0xFF	; 255
    457c:	85 e0       	ldi	r24, 0x05	; 5
    457e:	80 83       	st	Z, r24
    4580:	82 c5       	rjmp	.+2820   	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		phyPIB.logChannel = msg->value;
    4582:	8d 81       	ldd	r24, Y+5	; 0x05
    4584:	9e 81       	ldd	r25, Y+6	; 0x06
    4586:	fc 01       	movw	r30, r24
    4588:	e7 57       	subi	r30, 0x77	; 119
    458a:	ff 4f       	sbci	r31, 0xFF	; 255
    458c:	80 81       	ld	r24, Z
    458e:	91 81       	ldd	r25, Z+1	; 0x01
    4590:	80 93 bd 0e 	sts	0x0EBD, r24
																		switch (phyPIB.logChannel)
    4594:	80 91 bd 0e 	lds	r24, 0x0EBD
    4598:	48 2f       	mov	r20, r24
    459a:	50 e0       	ldi	r21, 0x00	; 0
    459c:	5f 8b       	std	Y+23, r21	; 0x17
    459e:	4e 8b       	std	Y+22, r20	; 0x16
    45a0:	8e 89       	ldd	r24, Y+22	; 0x16
    45a2:	9f 89       	ldd	r25, Y+23	; 0x17
    45a4:	82 30       	cpi	r24, 0x02	; 2
    45a6:	91 05       	cpc	r25, r1
    45a8:	c1 f0       	breq	.+48     	; 0x45da <PLMESap+0x51e>
    45aa:	2e 89       	ldd	r18, Y+22	; 0x16
    45ac:	3f 89       	ldd	r19, Y+23	; 0x17
    45ae:	23 30       	cpi	r18, 0x03	; 3
    45b0:	31 05       	cpc	r19, r1
    45b2:	09 f1       	breq	.+66     	; 0x45f6 <PLMESap+0x53a>
    45b4:	4e 89       	ldd	r20, Y+22	; 0x16
    45b6:	5f 89       	ldd	r21, Y+23	; 0x17
    45b8:	41 30       	cpi	r20, 0x01	; 1
    45ba:	51 05       	cpc	r21, r1
    45bc:	51 f5       	brne	.+84     	; 0x4612 <PLMESap+0x556>
																		{
																			case 1:  bw = NA_22MHz; sd = NA_4us; br = NA_250k_S;
    45be:	81 e0       	ldi	r24, 0x01	; 1
    45c0:	8c 83       	std	Y+4, r24	; 0x04
    45c2:	83 e0       	ldi	r24, 0x03	; 3
    45c4:	8b 83       	std	Y+3, r24	; 0x03
    45c6:	87 e0       	ldi	r24, 0x07	; 7
    45c8:	8a 83       	std	Y+2, r24	; 0x02
																					 cf = 1;
    45ca:	81 e0       	ldi	r24, 0x01	; 1
    45cc:	89 83       	std	Y+1, r24	; 0x01
																					 ntrxShadowReg[NA_UseFec_O] &= ~(1 << NA_UseFec_B);
    45ce:	80 91 4f 0f 	lds	r24, 0x0F4F
    45d2:	8b 7f       	andi	r24, 0xFB	; 251
    45d4:	80 93 4f 0f 	sts	0x0F4F, r24
    45d8:	27 c0       	rjmp	.+78     	; 0x4628 <PLMESap+0x56c>
																					 break;

																			case 2:  bw = NA_22MHz; sd = NA_4us; br = NA_250k_S;
    45da:	81 e0       	ldi	r24, 0x01	; 1
    45dc:	8c 83       	std	Y+4, r24	; 0x04
    45de:	83 e0       	ldi	r24, 0x03	; 3
    45e0:	8b 83       	std	Y+3, r24	; 0x03
    45e2:	87 e0       	ldi	r24, 0x07	; 7
    45e4:	8a 83       	std	Y+2, r24	; 0x02
																					 cf = 7;
    45e6:	87 e0       	ldi	r24, 0x07	; 7
    45e8:	89 83       	std	Y+1, r24	; 0x01
																					 ntrxShadowReg[NA_UseFec_O] &= ~(1 << NA_UseFec_B);
    45ea:	80 91 4f 0f 	lds	r24, 0x0F4F
    45ee:	8b 7f       	andi	r24, 0xFB	; 251
    45f0:	80 93 4f 0f 	sts	0x0F4F, r24
    45f4:	19 c0       	rjmp	.+50     	; 0x4628 <PLMESap+0x56c>
																					 break;

																			case 3:  bw = NA_22MHz; sd = NA_4us; br = NA_250k_S;
    45f6:	81 e0       	ldi	r24, 0x01	; 1
    45f8:	8c 83       	std	Y+4, r24	; 0x04
    45fa:	83 e0       	ldi	r24, 0x03	; 3
    45fc:	8b 83       	std	Y+3, r24	; 0x03
    45fe:	87 e0       	ldi	r24, 0x07	; 7
    4600:	8a 83       	std	Y+2, r24	; 0x02
																					 cf = 13;
    4602:	8d e0       	ldi	r24, 0x0D	; 13
    4604:	89 83       	std	Y+1, r24	; 0x01
																					 ntrxShadowReg[NA_UseFec_O] &= ~(1 << NA_UseFec_B);
    4606:	80 91 4f 0f 	lds	r24, 0x0F4F
    460a:	8b 7f       	andi	r24, 0xFB	; 251
    460c:	80 93 4f 0f 	sts	0x0F4F, r24
    4610:	0b c0       	rjmp	.+22     	; 0x4628 <PLMESap+0x56c>
																					 break;

																			default: bw = NA_80MHz; sd = NA_1us; br = NA_1M_S;
    4612:	1c 82       	std	Y+4, r1	; 0x04
    4614:	81 e0       	ldi	r24, 0x01	; 1
    4616:	8b 83       	std	Y+3, r24	; 0x03
    4618:	81 e0       	ldi	r24, 0x01	; 1
    461a:	8a 83       	std	Y+2, r24	; 0x02
																					 cf = 0;
    461c:	19 82       	std	Y+1, r1	; 0x01
																					 ntrxShadowReg[NA_UseFec_O] &= ~(1 << NA_UseFec_B);
    461e:	80 91 4f 0f 	lds	r24, 0x0F4F
    4622:	8b 7f       	andi	r24, 0xFB	; 251
    4624:	80 93 4f 0f 	sts	0x0F4F, r24
																					 break;
																		}
																		NTRXSPIWriteByte (NA_UseFec_O, ntrxShadowReg[NA_UseFec_O]);
    4628:	90 91 4f 0f 	lds	r25, 0x0F4F
    462c:	89 e4       	ldi	r24, 0x49	; 73
    462e:	69 2f       	mov	r22, r25
    4630:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																		NTRXSetChannel (cf);
    4634:	89 81       	ldd	r24, Y+1	; 0x01
    4636:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <NTRXSetChannel>
																		NTRXSetupTrxMode (bw, sd, br);
    463a:	8c 81       	ldd	r24, Y+4	; 0x04
    463c:	6b 81       	ldd	r22, Y+3	; 0x03
    463e:	4a 81       	ldd	r20, Y+2	; 0x02
    4640:	0e 94 29 30 	call	0x6052	; 0x6052 <NTRXSetupTrxMode>
    4644:	20 c5       	rjmp	.+2624   	; 0x5086 <PLMESap+0xfca>
																	}
																	break;

									case PHY_TRX_MODE:
																	phyPIB.trxMode = msg->value;
    4646:	8d 81       	ldd	r24, Y+5	; 0x05
    4648:	9e 81       	ldd	r25, Y+6	; 0x06
    464a:	fc 01       	movw	r30, r24
    464c:	e7 57       	subi	r30, 0x77	; 119
    464e:	ff 4f       	sbci	r31, 0xFF	; 255
    4650:	80 81       	ld	r24, Z
    4652:	91 81       	ldd	r25, Z+1	; 0x01
    4654:	80 93 d2 0e 	sts	0x0ED2, r24
																	switch (msg->value)
    4658:	8d 81       	ldd	r24, Y+5	; 0x05
    465a:	9e 81       	ldd	r25, Y+6	; 0x06
    465c:	fc 01       	movw	r30, r24
    465e:	e7 57       	subi	r30, 0x77	; 119
    4660:	ff 4f       	sbci	r31, 0xFF	; 255
    4662:	80 81       	ld	r24, Z
    4664:	91 81       	ldd	r25, Z+1	; 0x01
    4666:	9d 8b       	std	Y+21, r25	; 0x15
    4668:	8c 8b       	std	Y+20, r24	; 0x14
    466a:	2c 89       	ldd	r18, Y+20	; 0x14
    466c:	3d 89       	ldd	r19, Y+21	; 0x15
    466e:	20 32       	cpi	r18, 0x20	; 32
    4670:	31 05       	cpc	r19, r1
    4672:	09 f4       	brne	.+2      	; 0x4676 <PLMESap+0x5ba>
    4674:	93 c0       	rjmp	.+294    	; 0x479c <PLMESap+0x6e0>
    4676:	4c 89       	ldd	r20, Y+20	; 0x14
    4678:	5d 89       	ldd	r21, Y+21	; 0x15
    467a:	41 32       	cpi	r20, 0x21	; 33
    467c:	51 05       	cpc	r21, r1
    467e:	88 f5       	brcc	.+98     	; 0x46e2 <PLMESap+0x626>
    4680:	8c 89       	ldd	r24, Y+20	; 0x14
    4682:	9d 89       	ldd	r25, Y+21	; 0x15
    4684:	84 31       	cpi	r24, 0x14	; 20
    4686:	91 05       	cpc	r25, r1
    4688:	09 f4       	brne	.+2      	; 0x468c <PLMESap+0x5d0>
    468a:	71 c0       	rjmp	.+226    	; 0x476e <PLMESap+0x6b2>
    468c:	2c 89       	ldd	r18, Y+20	; 0x14
    468e:	3d 89       	ldd	r19, Y+21	; 0x15
    4690:	25 31       	cpi	r18, 0x15	; 21
    4692:	31 05       	cpc	r19, r1
    4694:	98 f4       	brcc	.+38     	; 0x46bc <PLMESap+0x600>
    4696:	4c 89       	ldd	r20, Y+20	; 0x14
    4698:	5d 89       	ldd	r21, Y+21	; 0x15
    469a:	4b 30       	cpi	r20, 0x0B	; 11
    469c:	51 05       	cpc	r21, r1
    469e:	09 f4       	brne	.+2      	; 0x46a2 <PLMESap+0x5e6>
    46a0:	5c c0       	rjmp	.+184    	; 0x475a <PLMESap+0x69e>
    46a2:	8c 89       	ldd	r24, Y+20	; 0x14
    46a4:	9d 89       	ldd	r25, Y+21	; 0x15
    46a6:	8c 30       	cpi	r24, 0x0C	; 12
    46a8:	91 05       	cpc	r25, r1
    46aa:	09 f4       	brne	.+2      	; 0x46ae <PLMESap+0x5f2>
    46ac:	5b c0       	rjmp	.+182    	; 0x4764 <PLMESap+0x6a8>
    46ae:	2c 89       	ldd	r18, Y+20	; 0x14
    46b0:	3d 89       	ldd	r19, Y+21	; 0x15
    46b2:	2a 30       	cpi	r18, 0x0A	; 10
    46b4:	31 05       	cpc	r19, r1
    46b6:	09 f4       	brne	.+2      	; 0x46ba <PLMESap+0x5fe>
    46b8:	4b c0       	rjmp	.+150    	; 0x4750 <PLMESap+0x694>
    46ba:	aa c0       	rjmp	.+340    	; 0x4810 <PLMESap+0x754>
    46bc:	4c 89       	ldd	r20, Y+20	; 0x14
    46be:	5d 89       	ldd	r21, Y+21	; 0x15
    46c0:	4e 31       	cpi	r20, 0x1E	; 30
    46c2:	51 05       	cpc	r21, r1
    46c4:	09 f4       	brne	.+2      	; 0x46c8 <PLMESap+0x60c>
    46c6:	5e c0       	rjmp	.+188    	; 0x4784 <PLMESap+0x6c8>
    46c8:	8c 89       	ldd	r24, Y+20	; 0x14
    46ca:	9d 89       	ldd	r25, Y+21	; 0x15
    46cc:	8f 31       	cpi	r24, 0x1F	; 31
    46ce:	91 05       	cpc	r25, r1
    46d0:	08 f0       	brcs	.+2      	; 0x46d4 <PLMESap+0x618>
    46d2:	5e c0       	rjmp	.+188    	; 0x4790 <PLMESap+0x6d4>
    46d4:	2c 89       	ldd	r18, Y+20	; 0x14
    46d6:	3d 89       	ldd	r19, Y+21	; 0x15
    46d8:	25 31       	cpi	r18, 0x15	; 21
    46da:	31 05       	cpc	r19, r1
    46dc:	09 f4       	brne	.+2      	; 0x46e0 <PLMESap+0x624>
    46de:	4c c0       	rjmp	.+152    	; 0x4778 <PLMESap+0x6bc>
    46e0:	97 c0       	rjmp	.+302    	; 0x4810 <PLMESap+0x754>
    46e2:	4c 89       	ldd	r20, Y+20	; 0x14
    46e4:	5d 89       	ldd	r21, Y+21	; 0x15
    46e6:	4c 33       	cpi	r20, 0x3C	; 60
    46e8:	51 05       	cpc	r21, r1
    46ea:	09 f4       	brne	.+2      	; 0x46ee <PLMESap+0x632>
    46ec:	6f c0       	rjmp	.+222    	; 0x47cc <PLMESap+0x710>
    46ee:	8c 89       	ldd	r24, Y+20	; 0x14
    46f0:	9d 89       	ldd	r25, Y+21	; 0x15
    46f2:	8d 33       	cpi	r24, 0x3D	; 61
    46f4:	91 05       	cpc	r25, r1
    46f6:	98 f4       	brcc	.+38     	; 0x471e <PLMESap+0x662>
    46f8:	2c 89       	ldd	r18, Y+20	; 0x14
    46fa:	3d 89       	ldd	r19, Y+21	; 0x15
    46fc:	29 32       	cpi	r18, 0x29	; 41
    46fe:	31 05       	cpc	r19, r1
    4700:	09 f4       	brne	.+2      	; 0x4704 <PLMESap+0x648>
    4702:	57 c0       	rjmp	.+174    	; 0x47b2 <PLMESap+0x6f6>
    4704:	4c 89       	ldd	r20, Y+20	; 0x14
    4706:	5d 89       	ldd	r21, Y+21	; 0x15
    4708:	42 33       	cpi	r20, 0x32	; 50
    470a:	51 05       	cpc	r21, r1
    470c:	09 f4       	brne	.+2      	; 0x4710 <PLMESap+0x654>
    470e:	57 c0       	rjmp	.+174    	; 0x47be <PLMESap+0x702>
    4710:	8c 89       	ldd	r24, Y+20	; 0x14
    4712:	9d 89       	ldd	r25, Y+21	; 0x15
    4714:	88 32       	cpi	r24, 0x28	; 40
    4716:	91 05       	cpc	r25, r1
    4718:	09 f4       	brne	.+2      	; 0x471c <PLMESap+0x660>
    471a:	45 c0       	rjmp	.+138    	; 0x47a6 <PLMESap+0x6ea>
    471c:	79 c0       	rjmp	.+242    	; 0x4810 <PLMESap+0x754>
    471e:	2c 89       	ldd	r18, Y+20	; 0x14
    4720:	3d 89       	ldd	r19, Y+21	; 0x15
    4722:	2e 33       	cpi	r18, 0x3E	; 62
    4724:	31 05       	cpc	r19, r1
    4726:	09 f4       	brne	.+2      	; 0x472a <PLMESap+0x66e>
    4728:	5f c0       	rjmp	.+190    	; 0x47e8 <PLMESap+0x72c>
    472a:	4c 89       	ldd	r20, Y+20	; 0x14
    472c:	5d 89       	ldd	r21, Y+21	; 0x15
    472e:	4e 33       	cpi	r20, 0x3E	; 62
    4730:	51 05       	cpc	r21, r1
    4732:	08 f4       	brcc	.+2      	; 0x4736 <PLMESap+0x67a>
    4734:	52 c0       	rjmp	.+164    	; 0x47da <PLMESap+0x71e>
    4736:	8c 89       	ldd	r24, Y+20	; 0x14
    4738:	9d 89       	ldd	r25, Y+21	; 0x15
    473a:	86 34       	cpi	r24, 0x46	; 70
    473c:	91 05       	cpc	r25, r1
    473e:	09 f4       	brne	.+2      	; 0x4742 <PLMESap+0x686>
    4740:	59 c0       	rjmp	.+178    	; 0x47f4 <PLMESap+0x738>
    4742:	2c 89       	ldd	r18, Y+20	; 0x14
    4744:	3d 89       	ldd	r19, Y+21	; 0x15
    4746:	27 34       	cpi	r18, 0x47	; 71
    4748:	31 05       	cpc	r19, r1
    474a:	09 f4       	brne	.+2      	; 0x474e <PLMESap+0x692>
    474c:	5a c0       	rjmp	.+180    	; 0x4802 <PLMESap+0x746>
    474e:	60 c0       	rjmp	.+192    	; 0x4810 <PLMESap+0x754>
																	{
#																		ifdef CONFIG_NTRX_80MHZ_500NS
																		case 10: 	bw = NA_80MHz; sd = NA_500ns; br = NA_125k_S; break;
    4750:	1c 82       	std	Y+4, r1	; 0x04
    4752:	1b 82       	std	Y+3, r1	; 0x03
    4754:	86 e0       	ldi	r24, 0x06	; 6
    4756:	8a 83       	std	Y+2, r24	; 0x02
    4758:	67 c0       	rjmp	.+206    	; 0x4828 <PLMESap+0x76c>
																		case 11: 	bw = NA_80MHz; sd = NA_500ns; br = NA_1M_S; break;
    475a:	1c 82       	std	Y+4, r1	; 0x04
    475c:	1b 82       	std	Y+3, r1	; 0x03
    475e:	81 e0       	ldi	r24, 0x01	; 1
    4760:	8a 83       	std	Y+2, r24	; 0x02
    4762:	62 c0       	rjmp	.+196    	; 0x4828 <PLMESap+0x76c>
																		case 12: 	bw = NA_80MHz; sd = NA_500ns; br = NA_2M_S; break;
    4764:	1c 82       	std	Y+4, r1	; 0x04
    4766:	1b 82       	std	Y+3, r1	; 0x03
    4768:	82 e0       	ldi	r24, 0x02	; 2
    476a:	8a 83       	std	Y+2, r24	; 0x02
    476c:	5d c0       	rjmp	.+186    	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_80MHZ_500NS */

#																		ifdef CONFIG_NTRX_80MHZ_1000NS
																		case 20: 	bw = NA_80MHz; sd = NA_1us; br = NA_500k_S; break;
    476e:	1c 82       	std	Y+4, r1	; 0x04
    4770:	81 e0       	ldi	r24, 0x01	; 1
    4772:	8b 83       	std	Y+3, r24	; 0x03
    4774:	1a 82       	std	Y+2, r1	; 0x02
    4776:	58 c0       	rjmp	.+176    	; 0x4828 <PLMESap+0x76c>
																		case 21: 	bw = NA_80MHz; sd = NA_1us; br = NA_1M_S; break;
    4778:	1c 82       	std	Y+4, r1	; 0x04
    477a:	81 e0       	ldi	r24, 0x01	; 1
    477c:	8b 83       	std	Y+3, r24	; 0x03
    477e:	81 e0       	ldi	r24, 0x01	; 1
    4780:	8a 83       	std	Y+2, r24	; 0x02
    4782:	52 c0       	rjmp	.+164    	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_80MHZ_1000NS */

#																		ifdef CONFIG_NTRX_80MHZ_2000NS
																		case 30: 	bw = NA_80MHz; sd = NA_2us; br = NA_125k_S; break;
    4784:	1c 82       	std	Y+4, r1	; 0x04
    4786:	82 e0       	ldi	r24, 0x02	; 2
    4788:	8b 83       	std	Y+3, r24	; 0x03
    478a:	86 e0       	ldi	r24, 0x06	; 6
    478c:	8a 83       	std	Y+2, r24	; 0x02
    478e:	4c c0       	rjmp	.+152    	; 0x4828 <PLMESap+0x76c>
																		case 31: 	bw = NA_80MHz; sd = NA_2us; br = NA_250k_S; break;
    4790:	1c 82       	std	Y+4, r1	; 0x04
    4792:	82 e0       	ldi	r24, 0x02	; 2
    4794:	8b 83       	std	Y+3, r24	; 0x03
    4796:	87 e0       	ldi	r24, 0x07	; 7
    4798:	8a 83       	std	Y+2, r24	; 0x02
    479a:	46 c0       	rjmp	.+140    	; 0x4828 <PLMESap+0x76c>
																		case 32: 	bw = NA_80MHz; sd = NA_2us; br = NA_500k_S; break;
    479c:	1c 82       	std	Y+4, r1	; 0x04
    479e:	82 e0       	ldi	r24, 0x02	; 2
    47a0:	8b 83       	std	Y+3, r24	; 0x03
    47a2:	1a 82       	std	Y+2, r1	; 0x02
    47a4:	41 c0       	rjmp	.+130    	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_80MHZ_2000NS */

#																		ifdef CONFIG_NTRX_80MHZ_4000NS
																		case 40: 	bw = NA_80MHz; sd = NA_4us; br = NA_125k_S; break;
    47a6:	1c 82       	std	Y+4, r1	; 0x04
    47a8:	83 e0       	ldi	r24, 0x03	; 3
    47aa:	8b 83       	std	Y+3, r24	; 0x03
    47ac:	86 e0       	ldi	r24, 0x06	; 6
    47ae:	8a 83       	std	Y+2, r24	; 0x02
    47b0:	3b c0       	rjmp	.+118    	; 0x4828 <PLMESap+0x76c>
																		case 41: 	bw = NA_80MHz; sd = NA_4us; br = NA_250k_S; break;
    47b2:	1c 82       	std	Y+4, r1	; 0x04
    47b4:	83 e0       	ldi	r24, 0x03	; 3
    47b6:	8b 83       	std	Y+3, r24	; 0x03
    47b8:	87 e0       	ldi	r24, 0x07	; 7
    47ba:	8a 83       	std	Y+2, r24	; 0x02
    47bc:	35 c0       	rjmp	.+106    	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_80MHZ_4000NS */

#																		ifdef CONFIG_NTRX_22MHZ_1000NS
																		case 50:	bw = NA_22MHz; sd = NA_1us; br = NA_1M_S; break;
    47be:	81 e0       	ldi	r24, 0x01	; 1
    47c0:	8c 83       	std	Y+4, r24	; 0x04
    47c2:	81 e0       	ldi	r24, 0x01	; 1
    47c4:	8b 83       	std	Y+3, r24	; 0x03
    47c6:	81 e0       	ldi	r24, 0x01	; 1
    47c8:	8a 83       	std	Y+2, r24	; 0x02
    47ca:	2e c0       	rjmp	.+92     	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_22MHZ_1000NS */

#																		ifdef CONFIG_NTRX_22MHZ_2000NS
																		case 60:	bw = NA_22MHz; sd = NA_2us; br = NA_125k_S; break;
    47cc:	81 e0       	ldi	r24, 0x01	; 1
    47ce:	8c 83       	std	Y+4, r24	; 0x04
    47d0:	82 e0       	ldi	r24, 0x02	; 2
    47d2:	8b 83       	std	Y+3, r24	; 0x03
    47d4:	86 e0       	ldi	r24, 0x06	; 6
    47d6:	8a 83       	std	Y+2, r24	; 0x02
    47d8:	27 c0       	rjmp	.+78     	; 0x4828 <PLMESap+0x76c>
																		case 61:	bw = NA_22MHz; sd = NA_2us; br = NA_250k_S; break;
    47da:	81 e0       	ldi	r24, 0x01	; 1
    47dc:	8c 83       	std	Y+4, r24	; 0x04
    47de:	82 e0       	ldi	r24, 0x02	; 2
    47e0:	8b 83       	std	Y+3, r24	; 0x03
    47e2:	87 e0       	ldi	r24, 0x07	; 7
    47e4:	8a 83       	std	Y+2, r24	; 0x02
    47e6:	20 c0       	rjmp	.+64     	; 0x4828 <PLMESap+0x76c>
																		case 62:	bw = NA_22MHz; sd = NA_2us; br = NA_500k_S; break;
    47e8:	81 e0       	ldi	r24, 0x01	; 1
    47ea:	8c 83       	std	Y+4, r24	; 0x04
    47ec:	82 e0       	ldi	r24, 0x02	; 2
    47ee:	8b 83       	std	Y+3, r24	; 0x03
    47f0:	1a 82       	std	Y+2, r1	; 0x02
    47f2:	1a c0       	rjmp	.+52     	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_22MHZ_2000NS */

#																		ifdef CONFIG_NTRX_22MHZ_4000NS
																		case 70:	bw = NA_22MHz; sd = NA_4us; br = NA_125k_S; break;
    47f4:	81 e0       	ldi	r24, 0x01	; 1
    47f6:	8c 83       	std	Y+4, r24	; 0x04
    47f8:	83 e0       	ldi	r24, 0x03	; 3
    47fa:	8b 83       	std	Y+3, r24	; 0x03
    47fc:	86 e0       	ldi	r24, 0x06	; 6
    47fe:	8a 83       	std	Y+2, r24	; 0x02
    4800:	13 c0       	rjmp	.+38     	; 0x4828 <PLMESap+0x76c>
																		case 71:	bw = NA_22MHz; sd = NA_4us; br = NA_250k_S; break;
    4802:	81 e0       	ldi	r24, 0x01	; 1
    4804:	8c 83       	std	Y+4, r24	; 0x04
    4806:	83 e0       	ldi	r24, 0x03	; 3
    4808:	8b 83       	std	Y+3, r24	; 0x03
    480a:	87 e0       	ldi	r24, 0x07	; 7
    480c:	8a 83       	std	Y+2, r24	; 0x02
    480e:	0c c0       	rjmp	.+24     	; 0x4828 <PLMESap+0x76c>
#																		endif /* CONFIG_NTRX_22MHZ_4000NS */
																		default: 	printf ("Valid modes: 10-43 (80Mhz) 50-84 (22Mhz) 90-93 (22HR)\n");
    4810:	8c ed       	ldi	r24, 0xDC	; 220
    4812:	96 e0       	ldi	r25, 0x06	; 6
    4814:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
																		msg->status = PHY_INVALID_PARAMETER;
    4818:	8d 81       	ldd	r24, Y+5	; 0x05
    481a:	9e 81       	ldd	r25, Y+6	; 0x06
    481c:	fc 01       	movw	r30, r24
    481e:	e8 57       	subi	r30, 0x78	; 120
    4820:	ff 4f       	sbci	r31, 0xFF	; 255
    4822:	85 e0       	ldi	r24, 0x05	; 5
    4824:	80 83       	st	Z, r24
    4826:	2f c4       	rjmp	.+2142   	; 0x5086 <PLMESap+0xfca>
																		SendCfgUp (msg);
																		return;
																	}
																	NTRXSetupTrxMode (bw, sd, br);
    4828:	8c 81       	ldd	r24, Y+4	; 0x04
    482a:	6b 81       	ldd	r22, Y+3	; 0x03
    482c:	4a 81       	ldd	r20, Y+2	; 0x02
    482e:	0e 94 29 30 	call	0x6052	; 0x6052 <NTRXSetupTrxMode>

																	switch (bw)
    4832:	8c 81       	ldd	r24, Y+4	; 0x04
    4834:	48 2f       	mov	r20, r24
    4836:	50 e0       	ldi	r21, 0x00	; 0
    4838:	5b 8b       	std	Y+19, r21	; 0x13
    483a:	4a 8b       	std	Y+18, r20	; 0x12
    483c:	8a 89       	ldd	r24, Y+18	; 0x12
    483e:	9b 89       	ldd	r25, Y+19	; 0x13
    4840:	00 97       	sbiw	r24, 0x00	; 0
    4842:	31 f0       	breq	.+12     	; 0x4850 <PLMESap+0x794>
    4844:	2a 89       	ldd	r18, Y+18	; 0x12
    4846:	3b 89       	ldd	r19, Y+19	; 0x13
    4848:	21 30       	cpi	r18, 0x01	; 1
    484a:	31 05       	cpc	r19, r1
    484c:	71 f0       	breq	.+28     	; 0x486a <PLMESap+0x7ae>
    484e:	1a c0       	rjmp	.+52     	; 0x4884 <PLMESap+0x7c8>
																	{
																		case NA_80MHz: printf ("New Mode 80 Mhz "); break;
    4850:	00 d0       	rcall	.+0      	; 0x4852 <PLMESap+0x796>
    4852:	ed b7       	in	r30, 0x3d	; 61
    4854:	fe b7       	in	r31, 0x3e	; 62
    4856:	31 96       	adiw	r30, 0x01	; 1
    4858:	82 e1       	ldi	r24, 0x12	; 18
    485a:	97 e0       	ldi	r25, 0x07	; 7
    485c:	91 83       	std	Z+1, r25	; 0x01
    485e:	80 83       	st	Z, r24
    4860:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    4864:	0f 90       	pop	r0
    4866:	0f 90       	pop	r0
    4868:	19 c0       	rjmp	.+50     	; 0x489c <PLMESap+0x7e0>
																		case NA_22MHz: printf ("New Mode 22 Mhz "); break;
    486a:	00 d0       	rcall	.+0      	; 0x486c <PLMESap+0x7b0>
    486c:	ed b7       	in	r30, 0x3d	; 61
    486e:	fe b7       	in	r31, 0x3e	; 62
    4870:	31 96       	adiw	r30, 0x01	; 1
    4872:	83 e2       	ldi	r24, 0x23	; 35
    4874:	97 e0       	ldi	r25, 0x07	; 7
    4876:	91 83       	std	Z+1, r25	; 0x01
    4878:	80 83       	st	Z, r24
    487a:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    487e:	0f 90       	pop	r0
    4880:	0f 90       	pop	r0
    4882:	0c c0       	rjmp	.+24     	; 0x489c <PLMESap+0x7e0>
																		default: printf ("Unknown mode ??? ");
    4884:	00 d0       	rcall	.+0      	; 0x4886 <PLMESap+0x7ca>
    4886:	ed b7       	in	r30, 0x3d	; 61
    4888:	fe b7       	in	r31, 0x3e	; 62
    488a:	31 96       	adiw	r30, 0x01	; 1
    488c:	84 e3       	ldi	r24, 0x34	; 52
    488e:	97 e0       	ldi	r25, 0x07	; 7
    4890:	91 83       	std	Z+1, r25	; 0x01
    4892:	80 83       	st	Z, r24
    4894:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    4898:	0f 90       	pop	r0
    489a:	0f 90       	pop	r0
																	}
																	switch (sd)
    489c:	8b 81       	ldd	r24, Y+3	; 0x03
    489e:	48 2f       	mov	r20, r24
    48a0:	50 e0       	ldi	r21, 0x00	; 0
    48a2:	59 8b       	std	Y+17, r21	; 0x11
    48a4:	48 8b       	std	Y+16, r20	; 0x10
    48a6:	88 89       	ldd	r24, Y+16	; 0x10
    48a8:	99 89       	ldd	r25, Y+17	; 0x11
    48aa:	81 30       	cpi	r24, 0x01	; 1
    48ac:	91 05       	cpc	r25, r1
    48ae:	19 f1       	breq	.+70     	; 0x48f6 <PLMESap+0x83a>
    48b0:	28 89       	ldd	r18, Y+16	; 0x10
    48b2:	39 89       	ldd	r19, Y+17	; 0x11
    48b4:	22 30       	cpi	r18, 0x02	; 2
    48b6:	31 05       	cpc	r19, r1
    48b8:	34 f4       	brge	.+12     	; 0x48c6 <PLMESap+0x80a>
    48ba:	48 89       	ldd	r20, Y+16	; 0x10
    48bc:	59 89       	ldd	r21, Y+17	; 0x11
    48be:	41 15       	cp	r20, r1
    48c0:	51 05       	cpc	r21, r1
    48c2:	61 f0       	breq	.+24     	; 0x48dc <PLMESap+0x820>
    48c4:	3e c0       	rjmp	.+124    	; 0x4942 <PLMESap+0x886>
    48c6:	88 89       	ldd	r24, Y+16	; 0x10
    48c8:	99 89       	ldd	r25, Y+17	; 0x11
    48ca:	82 30       	cpi	r24, 0x02	; 2
    48cc:	91 05       	cpc	r25, r1
    48ce:	01 f1       	breq	.+64     	; 0x4910 <PLMESap+0x854>
    48d0:	28 89       	ldd	r18, Y+16	; 0x10
    48d2:	39 89       	ldd	r19, Y+17	; 0x11
    48d4:	23 30       	cpi	r18, 0x03	; 3
    48d6:	31 05       	cpc	r19, r1
    48d8:	41 f1       	breq	.+80     	; 0x492a <PLMESap+0x86e>
    48da:	33 c0       	rjmp	.+102    	; 0x4942 <PLMESap+0x886>
																	{
																		case NA_500ns: printf ("500 ns, "); break;
    48dc:	00 d0       	rcall	.+0      	; 0x48de <PLMESap+0x822>
    48de:	ed b7       	in	r30, 0x3d	; 61
    48e0:	fe b7       	in	r31, 0x3e	; 62
    48e2:	31 96       	adiw	r30, 0x01	; 1
    48e4:	86 e4       	ldi	r24, 0x46	; 70
    48e6:	97 e0       	ldi	r25, 0x07	; 7
    48e8:	91 83       	std	Z+1, r25	; 0x01
    48ea:	80 83       	st	Z, r24
    48ec:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    48f0:	0f 90       	pop	r0
    48f2:	0f 90       	pop	r0
    48f4:	26 c0       	rjmp	.+76     	; 0x4942 <PLMESap+0x886>
																		case NA_1us:   printf ("1 us, "); break;
    48f6:	00 d0       	rcall	.+0      	; 0x48f8 <PLMESap+0x83c>
    48f8:	ed b7       	in	r30, 0x3d	; 61
    48fa:	fe b7       	in	r31, 0x3e	; 62
    48fc:	31 96       	adiw	r30, 0x01	; 1
    48fe:	8f e4       	ldi	r24, 0x4F	; 79
    4900:	97 e0       	ldi	r25, 0x07	; 7
    4902:	91 83       	std	Z+1, r25	; 0x01
    4904:	80 83       	st	Z, r24
    4906:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    490a:	0f 90       	pop	r0
    490c:	0f 90       	pop	r0
    490e:	19 c0       	rjmp	.+50     	; 0x4942 <PLMESap+0x886>
																		case NA_2us:   printf ("2 us, "); break;
    4910:	00 d0       	rcall	.+0      	; 0x4912 <PLMESap+0x856>
    4912:	ed b7       	in	r30, 0x3d	; 61
    4914:	fe b7       	in	r31, 0x3e	; 62
    4916:	31 96       	adiw	r30, 0x01	; 1
    4918:	86 e5       	ldi	r24, 0x56	; 86
    491a:	97 e0       	ldi	r25, 0x07	; 7
    491c:	91 83       	std	Z+1, r25	; 0x01
    491e:	80 83       	st	Z, r24
    4920:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    4924:	0f 90       	pop	r0
    4926:	0f 90       	pop	r0
    4928:	0c c0       	rjmp	.+24     	; 0x4942 <PLMESap+0x886>
																		case NA_4us:   printf ("4 us, "); break;
    492a:	00 d0       	rcall	.+0      	; 0x492c <PLMESap+0x870>
    492c:	ed b7       	in	r30, 0x3d	; 61
    492e:	fe b7       	in	r31, 0x3e	; 62
    4930:	31 96       	adiw	r30, 0x01	; 1
    4932:	8d e5       	ldi	r24, 0x5D	; 93
    4934:	97 e0       	ldi	r25, 0x07	; 7
    4936:	91 83       	std	Z+1, r25	; 0x01
    4938:	80 83       	st	Z, r24
    493a:	0e 94 b8 45 	call	0x8b70	; 0x8b70 <printf>
    493e:	0f 90       	pop	r0
    4940:	0f 90       	pop	r0
																		default: break;
																	}
																	switch (br)
    4942:	8a 81       	ldd	r24, Y+2	; 0x02
    4944:	48 2f       	mov	r20, r24
    4946:	50 e0       	ldi	r21, 0x00	; 0
    4948:	5f 87       	std	Y+15, r21	; 0x0f
    494a:	4e 87       	std	Y+14, r20	; 0x0e
    494c:	8e 85       	ldd	r24, Y+14	; 0x0e
    494e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4950:	82 30       	cpi	r24, 0x02	; 2
    4952:	91 05       	cpc	r25, r1
    4954:	79 f1       	breq	.+94     	; 0x49b4 <PLMESap+0x8f8>
    4956:	2e 85       	ldd	r18, Y+14	; 0x0e
    4958:	3f 85       	ldd	r19, Y+15	; 0x0f
    495a:	23 30       	cpi	r18, 0x03	; 3
    495c:	31 05       	cpc	r19, r1
    495e:	5c f4       	brge	.+22     	; 0x4976 <PLMESap+0x8ba>
    4960:	4e 85       	ldd	r20, Y+14	; 0x0e
    4962:	5f 85       	ldd	r21, Y+15	; 0x0f
    4964:	41 15       	cp	r20, r1
    4966:	51 05       	cpc	r21, r1
    4968:	d9 f0       	breq	.+54     	; 0x49a0 <PLMESap+0x8e4>
    496a:	8e 85       	ldd	r24, Y+14	; 0x0e
    496c:	9f 85       	ldd	r25, Y+15	; 0x0f
    496e:	81 30       	cpi	r24, 0x01	; 1
    4970:	91 05       	cpc	r25, r1
    4972:	d9 f0       	breq	.+54     	; 0x49aa <PLMESap+0x8ee>
    4974:	88 c3       	rjmp	.+1808   	; 0x5086 <PLMESap+0xfca>
    4976:	2e 85       	ldd	r18, Y+14	; 0x0e
    4978:	3f 85       	ldd	r19, Y+15	; 0x0f
    497a:	26 30       	cpi	r18, 0x06	; 6
    497c:	31 05       	cpc	r19, r1
    497e:	31 f0       	breq	.+12     	; 0x498c <PLMESap+0x8d0>
    4980:	4e 85       	ldd	r20, Y+14	; 0x0e
    4982:	5f 85       	ldd	r21, Y+15	; 0x0f
    4984:	47 30       	cpi	r20, 0x07	; 7
    4986:	51 05       	cpc	r21, r1
    4988:	31 f0       	breq	.+12     	; 0x4996 <PLMESap+0x8da>
    498a:	7d c3       	rjmp	.+1786   	; 0x5086 <PLMESap+0xfca>
																	{
																		case NA_125k_S: printf ("125 kSym\n"); break;
    498c:	84 e6       	ldi	r24, 0x64	; 100
    498e:	97 e0       	ldi	r25, 0x07	; 7
    4990:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    4994:	78 c3       	rjmp	.+1776   	; 0x5086 <PLMESap+0xfca>
																		case NA_250k_S: printf ("250 kSym\n"); break;
    4996:	8d e6       	ldi	r24, 0x6D	; 109
    4998:	97 e0       	ldi	r25, 0x07	; 7
    499a:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    499e:	73 c3       	rjmp	.+1766   	; 0x5086 <PLMESap+0xfca>
																		case NA_500k_S: printf ("500 kSym\n"); break;
    49a0:	86 e7       	ldi	r24, 0x76	; 118
    49a2:	97 e0       	ldi	r25, 0x07	; 7
    49a4:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    49a8:	6e c3       	rjmp	.+1756   	; 0x5086 <PLMESap+0xfca>
																		case NA_1M_S: printf ("1 MSym\n"); break;
    49aa:	8f e7       	ldi	r24, 0x7F	; 127
    49ac:	97 e0       	ldi	r25, 0x07	; 7
    49ae:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    49b2:	69 c3       	rjmp	.+1746   	; 0x5086 <PLMESap+0xfca>
																		case NA_2M_S: printf ("2 MSym\n"); break;
    49b4:	86 e8       	ldi	r24, 0x86	; 134
    49b6:	97 e0       	ldi	r25, 0x07	; 7
    49b8:	0e 94 d4 45 	call	0x8ba8	; 0x8ba8 <puts>
    49bc:	64 c3       	rjmp	.+1736   	; 0x5086 <PLMESap+0xfca>
																		default: break;
																	}
																	break;

									case PHY_TX_POWER:		 		if (msg->value > 63)
    49be:	8d 81       	ldd	r24, Y+5	; 0x05
    49c0:	9e 81       	ldd	r25, Y+6	; 0x06
    49c2:	fc 01       	movw	r30, r24
    49c4:	e7 57       	subi	r30, 0x77	; 119
    49c6:	ff 4f       	sbci	r31, 0xFF	; 255
    49c8:	80 81       	ld	r24, Z
    49ca:	91 81       	ldd	r25, Z+1	; 0x01
    49cc:	80 34       	cpi	r24, 0x40	; 64
    49ce:	91 05       	cpc	r25, r1
    49d0:	40 f0       	brcs	.+16     	; 0x49e2 <PLMESap+0x926>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    49d2:	8d 81       	ldd	r24, Y+5	; 0x05
    49d4:	9e 81       	ldd	r25, Y+6	; 0x06
    49d6:	fc 01       	movw	r30, r24
    49d8:	e8 57       	subi	r30, 0x78	; 120
    49da:	ff 4f       	sbci	r31, 0xFF	; 255
    49dc:	85 e0       	ldi	r24, 0x05	; 5
    49de:	80 83       	st	Z, r24
    49e0:	52 c3       	rjmp	.+1700   	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		phyPIB.txPower = ((MyByte8T)(msg->value) & 0x3f);
    49e2:	8d 81       	ldd	r24, Y+5	; 0x05
    49e4:	9e 81       	ldd	r25, Y+6	; 0x06
    49e6:	fc 01       	movw	r30, r24
    49e8:	e7 57       	subi	r30, 0x77	; 119
    49ea:	ff 4f       	sbci	r31, 0xFF	; 255
    49ec:	80 81       	ld	r24, Z
    49ee:	91 81       	ldd	r25, Z+1	; 0x01
    49f0:	8f 73       	andi	r24, 0x3F	; 63
    49f2:	80 93 be 0e 	sts	0x0EBE, r24
																		ntrxShadowReg[NA_TxOutputPower0_O] &= ~(0x3f << NA_TxOutputPower0_LSB);
    49f6:	80 91 4a 0f 	lds	r24, 0x0F4A
    49fa:	80 7c       	andi	r24, 0xC0	; 192
    49fc:	80 93 4a 0f 	sts	0x0F4A, r24
																		ntrxShadowReg[NA_TxOutputPower0_O] |= (phyPIB.txPower << NA_TxOutputPower0_LSB);
    4a00:	90 91 4a 0f 	lds	r25, 0x0F4A
    4a04:	80 91 be 0e 	lds	r24, 0x0EBE
    4a08:	89 2b       	or	r24, r25
    4a0a:	80 93 4a 0f 	sts	0x0F4A, r24
																		if (phyPIB.txPower != 0x3f)
    4a0e:	80 91 be 0e 	lds	r24, 0x0EBE
    4a12:	8f 33       	cpi	r24, 0x3F	; 63
    4a14:	29 f0       	breq	.+10     	; 0x4a20 <PLMESap+0x964>
																		{	/* This way no table for the transmission output power is necessary */
																			ntrxShadowReg[NA_TxOutputPower0_O] &= ~(1 << NA_TxOutputPower0_LSB);
    4a16:	80 91 4a 0f 	lds	r24, 0x0F4A
    4a1a:	8e 7f       	andi	r24, 0xFE	; 254
    4a1c:	80 93 4a 0f 	sts	0x0F4A, r24
																		}
																		NTRXSPIWriteByte (NA_TxOutputPower0_O, ntrxShadowReg[NA_TxOutputPower0_O]);
    4a20:	90 91 4a 0f 	lds	r25, 0x0F4A
    4a24:	84 e4       	ldi	r24, 0x44	; 68
    4a26:	69 2f       	mov	r22, r25
    4a28:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

																		ntrxShadowReg[NA_TxOutputPower1_O] &= ~(0x3f << NA_TxOutputPower1_LSB);
    4a2c:	80 91 4b 0f 	lds	r24, 0x0F4B
    4a30:	80 7c       	andi	r24, 0xC0	; 192
    4a32:	80 93 4b 0f 	sts	0x0F4B, r24
																		ntrxShadowReg[NA_TxOutputPower1_O] |= (phyPIB.txPower << NA_TxOutputPower1_LSB);
    4a36:	90 91 4b 0f 	lds	r25, 0x0F4B
    4a3a:	80 91 be 0e 	lds	r24, 0x0EBE
    4a3e:	89 2b       	or	r24, r25
    4a40:	80 93 4b 0f 	sts	0x0F4B, r24
																		if (phyPIB.txPower != 0x3f)
    4a44:	80 91 be 0e 	lds	r24, 0x0EBE
    4a48:	8f 33       	cpi	r24, 0x3F	; 63
    4a4a:	29 f0       	breq	.+10     	; 0x4a56 <PLMESap+0x99a>
																		{	/* This way no table for the transmission output power is necessary */
																			ntrxShadowReg[NA_TxOutputPower1_O] &= ~(1 << NA_TxOutputPower1_LSB);
    4a4c:	80 91 4b 0f 	lds	r24, 0x0F4B
    4a50:	8e 7f       	andi	r24, 0xFE	; 254
    4a52:	80 93 4b 0f 	sts	0x0F4B, r24
																		}
																		NTRXSPIWriteByte (NA_TxOutputPower1_O, ntrxShadowReg[NA_TxOutputPower1_O]);
    4a56:	90 91 4b 0f 	lds	r25, 0x0F4B
    4a5a:	85 e4       	ldi	r24, 0x45	; 69
    4a5c:	69 2f       	mov	r22, r25
    4a5e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4a62:	11 c3       	rjmp	.+1570   	; 0x5086 <PLMESap+0xfca>
																	}
																	break;

									case PHY_ARQ:					phyPIB.rxOn = FALSE;
    4a64:	10 92 e6 0e 	sts	0x0EE6, r1
																	NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4a68:	80 91 5c 0f 	lds	r24, 0x0F5C
    4a6c:	98 2f       	mov	r25, r24
    4a6e:	91 60       	ori	r25, 0x01	; 1
    4a70:	86 e5       	ldi	r24, 0x56	; 86
    4a72:	69 2f       	mov	r22, r25
    4a74:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	if( msg->value == 0 )
    4a78:	8d 81       	ldd	r24, Y+5	; 0x05
    4a7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4a7c:	fc 01       	movw	r30, r24
    4a7e:	e7 57       	subi	r30, 0x77	; 119
    4a80:	ff 4f       	sbci	r31, 0xFF	; 255
    4a82:	80 81       	ld	r24, Z
    4a84:	91 81       	ldd	r25, Z+1	; 0x01
    4a86:	00 97       	sbiw	r24, 0x00	; 0
    4a88:	59 f4       	brne	.+22     	; 0x4aa0 <PLMESap+0x9e4>
																	{
																		ntrxShadowReg[NA_TxArq_O] &= ~(1 << NA_TxArq_B);
    4a8a:	80 91 54 0f 	lds	r24, 0x0F54
    4a8e:	8f 7e       	andi	r24, 0xEF	; 239
    4a90:	80 93 54 0f 	sts	0x0F54, r24
																		ntrxShadowReg[NA_RxArqMode_O] &= ~((0x03 << NA_RxArqMode_LSB)
    4a94:	80 91 60 0f 	lds	r24, 0x0F60
    4a98:	81 7f       	andi	r24, 0xF1	; 241
    4a9a:	80 93 60 0f 	sts	0x0F60, r24
    4a9e:	0a c0       	rjmp	.+20     	; 0x4ab4 <PLMESap+0x9f8>
																										| (1 << NA_RxCrc2Mode_B));
																	}
																	else
																	{
																		ntrxShadowReg[NA_TxArq_O] |= (1 << NA_TxArq_B);
    4aa0:	80 91 54 0f 	lds	r24, 0x0F54
    4aa4:	80 61       	ori	r24, 0x10	; 16
    4aa6:	80 93 54 0f 	sts	0x0F54, r24
																		ntrxShadowReg[NA_RxArqMode_O] |= ((NA_RxArqModeCrc2_VC_C << NA_RxArqMode_LSB)
    4aaa:	80 91 60 0f 	lds	r24, 0x0F60
    4aae:	8a 60       	ori	r24, 0x0A	; 10
    4ab0:	80 93 60 0f 	sts	0x0F60, r24
																										| (NA_RxCrc2ModeTrigOn_BC_C << NA_RxCrc2Mode_B));
																	}
																	NTRXSPIWriteByte (NA_TxArq_O, ntrxShadowReg[NA_TxArq_O]);
    4ab4:	90 91 54 0f 	lds	r25, 0x0F54
    4ab8:	8e e4       	ldi	r24, 0x4E	; 78
    4aba:	69 2f       	mov	r22, r25
    4abc:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	NTRXSPIWriteByte (NA_RxArqMode_O, ntrxShadowReg[NA_RxArqMode_O]);
    4ac0:	90 91 60 0f 	lds	r25, 0x0F60
    4ac4:	8a e5       	ldi	r24, 0x5A	; 90
    4ac6:	69 2f       	mov	r22, r25
    4ac8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	if (phyPIB.rxState == PHY_RX_ON)
    4acc:	80 91 bf 0e 	lds	r24, 0x0EBF
    4ad0:	86 30       	cpi	r24, 0x06	; 6
    4ad2:	09 f0       	breq	.+2      	; 0x4ad6 <PLMESap+0xa1a>
    4ad4:	d8 c2       	rjmp	.+1456   	; 0x5086 <PLMESap+0xfca>
																	{
																		phyPIB.rxOn = TRUE;
    4ad6:	81 e0       	ldi	r24, 0x01	; 1
    4ad8:	80 93 e6 0e 	sts	0x0EE6, r24
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4adc:	80 91 5c 0f 	lds	r24, 0x0F5C
    4ae0:	98 2f       	mov	r25, r24
    4ae2:	9e 60       	ori	r25, 0x0E	; 14
    4ae4:	86 e5       	ldi	r24, 0x56	; 86
    4ae6:	69 2f       	mov	r22, r25
    4ae8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4aec:	cc c2       	rjmp	.+1432   	; 0x5086 <PLMESap+0xfca>
																												| (1 << NA_RxCmdStart_B)
																												| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_ARQ_MAX:				if (msg->value > 14)
    4aee:	8d 81       	ldd	r24, Y+5	; 0x05
    4af0:	9e 81       	ldd	r25, Y+6	; 0x06
    4af2:	fc 01       	movw	r30, r24
    4af4:	e7 57       	subi	r30, 0x77	; 119
    4af6:	ff 4f       	sbci	r31, 0xFF	; 255
    4af8:	80 81       	ld	r24, Z
    4afa:	91 81       	ldd	r25, Z+1	; 0x01
    4afc:	8f 30       	cpi	r24, 0x0F	; 15
    4afe:	91 05       	cpc	r25, r1
    4b00:	40 f0       	brcs	.+16     	; 0x4b12 <PLMESap+0xa56>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    4b02:	8d 81       	ldd	r24, Y+5	; 0x05
    4b04:	9e 81       	ldd	r25, Y+6	; 0x06
    4b06:	fc 01       	movw	r30, r24
    4b08:	e8 57       	subi	r30, 0x78	; 120
    4b0a:	ff 4f       	sbci	r31, 0xFF	; 255
    4b0c:	85 e0       	ldi	r24, 0x05	; 5
    4b0e:	80 83       	st	Z, r24
    4b10:	ba c2       	rjmp	.+1396   	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4b12:	80 91 5c 0f 	lds	r24, 0x0F5C
    4b16:	98 2f       	mov	r25, r24
    4b18:	91 60       	ori	r25, 0x01	; 1
    4b1a:	86 e5       	ldi	r24, 0x56	; 86
    4b1c:	69 2f       	mov	r22, r25
    4b1e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																		phyPIB.arqMax = (MyByte8T)(msg->value);
    4b22:	8d 81       	ldd	r24, Y+5	; 0x05
    4b24:	9e 81       	ldd	r25, Y+6	; 0x06
    4b26:	fc 01       	movw	r30, r24
    4b28:	e7 57       	subi	r30, 0x77	; 119
    4b2a:	ff 4f       	sbci	r31, 0xFF	; 255
    4b2c:	80 81       	ld	r24, Z
    4b2e:	91 81       	ldd	r25, Z+1	; 0x01
    4b30:	80 93 ce 0e 	sts	0x0ECE, r24
																		if (phyPIB.arqMax == 0)
    4b34:	80 91 ce 0e 	lds	r24, 0x0ECE
    4b38:	88 23       	and	r24, r24
    4b3a:	31 f4       	brne	.+12     	; 0x4b48 <PLMESap+0xa8c>
																		{
																			ntrxShadowReg[NA_TxArqMax_O] &= ~(0x0f << NA_TxArqMax_LSB);
    4b3c:	80 91 42 0f 	lds	r24, 0x0F42
    4b40:	8f 70       	andi	r24, 0x0F	; 15
    4b42:	80 93 42 0f 	sts	0x0F42, r24
    4b46:	13 c0       	rjmp	.+38     	; 0x4b6e <PLMESap+0xab2>
																		}
																		else
																		{
																			ntrxShadowReg[NA_TxArqMax_O] &= ~(0x0f << NA_TxArqMax_LSB);
    4b48:	80 91 42 0f 	lds	r24, 0x0F42
    4b4c:	8f 70       	andi	r24, 0x0F	; 15
    4b4e:	80 93 42 0f 	sts	0x0F42, r24
																			ntrxShadowReg[NA_TxArqMax_O] |= ((MyByte8T)(msg->value << NA_TxArqMax_LSB));
    4b52:	20 91 42 0f 	lds	r18, 0x0F42
    4b56:	8d 81       	ldd	r24, Y+5	; 0x05
    4b58:	9e 81       	ldd	r25, Y+6	; 0x06
    4b5a:	fc 01       	movw	r30, r24
    4b5c:	e7 57       	subi	r30, 0x77	; 119
    4b5e:	ff 4f       	sbci	r31, 0xFF	; 255
    4b60:	80 81       	ld	r24, Z
    4b62:	91 81       	ldd	r25, Z+1	; 0x01
    4b64:	82 95       	swap	r24
    4b66:	80 7f       	andi	r24, 0xF0	; 240
    4b68:	82 2b       	or	r24, r18
    4b6a:	80 93 42 0f 	sts	0x0F42, r24
																		}
																		NTRXSPIWriteByte (NA_TxArqMax_O, ntrxShadowReg[NA_TxArqMax_O]);
    4b6e:	90 91 42 0f 	lds	r25, 0x0F42
    4b72:	8c e3       	ldi	r24, 0x3C	; 60
    4b74:	69 2f       	mov	r22, r25
    4b76:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																		if (phyPIB.rxState == PHY_RX_ON)
    4b7a:	80 91 bf 0e 	lds	r24, 0x0EBF
    4b7e:	86 30       	cpi	r24, 0x06	; 6
    4b80:	09 f0       	breq	.+2      	; 0x4b84 <PLMESap+0xac8>
    4b82:	81 c2       	rjmp	.+1282   	; 0x5086 <PLMESap+0xfca>
																		{
																			NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4b84:	80 91 5c 0f 	lds	r24, 0x0F5C
    4b88:	98 2f       	mov	r25, r24
    4b8a:	9e 60       	ori	r25, 0x0E	; 14
    4b8c:	86 e5       	ldi	r24, 0x56	; 86
    4b8e:	69 2f       	mov	r22, r25
    4b90:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4b94:	78 c2       	rjmp	.+1264   	; 0x5086 <PLMESap+0xfca>
																													| (0x03 << NA_RxBufferCmd_LSB));
																		}
																	}
																	break;

									case PHY_FEC:					NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4b96:	80 91 5c 0f 	lds	r24, 0x0F5C
    4b9a:	98 2f       	mov	r25, r24
    4b9c:	91 60       	ori	r25, 0x01	; 1
    4b9e:	86 e5       	ldi	r24, 0x56	; 86
    4ba0:	69 2f       	mov	r22, r25
    4ba2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	if (msg->value == TRUE)
    4ba6:	8d 81       	ldd	r24, Y+5	; 0x05
    4ba8:	9e 81       	ldd	r25, Y+6	; 0x06
    4baa:	fc 01       	movw	r30, r24
    4bac:	e7 57       	subi	r30, 0x77	; 119
    4bae:	ff 4f       	sbci	r31, 0xFF	; 255
    4bb0:	80 81       	ld	r24, Z
    4bb2:	91 81       	ldd	r25, Z+1	; 0x01
    4bb4:	81 30       	cpi	r24, 0x01	; 1
    4bb6:	91 05       	cpc	r25, r1
    4bb8:	31 f4       	brne	.+12     	; 0x4bc6 <PLMESap+0xb0a>
																	{
																		ntrxShadowReg[NA_UseFec_O] |= (1 << NA_UseFec_B);
    4bba:	80 91 4f 0f 	lds	r24, 0x0F4F
    4bbe:	84 60       	ori	r24, 0x04	; 4
    4bc0:	80 93 4f 0f 	sts	0x0F4F, r24
    4bc4:	05 c0       	rjmp	.+10     	; 0x4bd0 <PLMESap+0xb14>
																	}
																	else
																	{
																		ntrxShadowReg[NA_UseFec_O] &= ~(1 << NA_UseFec_B);
    4bc6:	80 91 4f 0f 	lds	r24, 0x0F4F
    4bca:	8b 7f       	andi	r24, 0xFB	; 251
    4bcc:	80 93 4f 0f 	sts	0x0F4F, r24
																	}
																	NTRXSPIWriteByte (NA_UseFec_O, ntrxShadowReg[NA_UseFec_O]);
    4bd0:	90 91 4f 0f 	lds	r25, 0x0F4F
    4bd4:	89 e4       	ldi	r24, 0x49	; 73
    4bd6:	69 2f       	mov	r22, r25
    4bd8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

																	phyPIB.fec = msg->value;
    4bdc:	8d 81       	ldd	r24, Y+5	; 0x05
    4bde:	9e 81       	ldd	r25, Y+6	; 0x06
    4be0:	fc 01       	movw	r30, r24
    4be2:	e7 57       	subi	r30, 0x77	; 119
    4be4:	ff 4f       	sbci	r31, 0xFF	; 255
    4be6:	80 81       	ld	r24, Z
    4be8:	91 81       	ldd	r25, Z+1	; 0x01
    4bea:	80 93 e7 0e 	sts	0x0EE7, r24
																	modeSet.fec = msg->value;
    4bee:	8d 81       	ldd	r24, Y+5	; 0x05
    4bf0:	9e 81       	ldd	r25, Y+6	; 0x06
    4bf2:	fc 01       	movw	r30, r24
    4bf4:	e7 57       	subi	r30, 0x77	; 119
    4bf6:	ff 4f       	sbci	r31, 0xFF	; 255
    4bf8:	80 81       	ld	r24, Z
    4bfa:	91 81       	ldd	r25, Z+1	; 0x01
    4bfc:	80 93 f6 0e 	sts	0x0EF6, r24

																	if (phyPIB.rxState == PHY_RX_ON)
    4c00:	80 91 bf 0e 	lds	r24, 0x0EBF
    4c04:	86 30       	cpi	r24, 0x06	; 6
    4c06:	09 f0       	breq	.+2      	; 0x4c0a <PLMESap+0xb4e>
    4c08:	3e c2       	rjmp	.+1148   	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4c0a:	80 91 5c 0f 	lds	r24, 0x0F5C
    4c0e:	98 2f       	mov	r25, r24
    4c10:	9e 60       	ori	r25, 0x0E	; 14
    4c12:	86 e5       	ldi	r24, 0x56	; 86
    4c14:	69 2f       	mov	r22, r25
    4c16:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4c1a:	35 c2       	rjmp	.+1130   	; 0x5086 <PLMESap+0xfca>
																											| (1 << NA_RxCmdStart_B)
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_MAC_ADDRESS1:			NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4c1c:	80 91 5c 0f 	lds	r24, 0x0F5C
    4c20:	98 2f       	mov	r25, r24
    4c22:	91 60       	ori	r25, 0x01	; 1
    4c24:	86 e5       	ldi	r24, 0x56	; 86
    4c26:	69 2f       	mov	r22, r25
    4c28:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	memcpy (phyPIB.macAddr0, msg->data, 6);
    4c2c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c2e:	9e 81       	ldd	r25, Y+6	; 0x06
    4c30:	9c 01       	movw	r18, r24
    4c32:	28 5f       	subi	r18, 0xF8	; 248
    4c34:	3f 4f       	sbci	r19, 0xFF	; 255
    4c36:	81 ec       	ldi	r24, 0xC1	; 193
    4c38:	9e e0       	ldi	r25, 0x0E	; 14
    4c3a:	b9 01       	movw	r22, r18
    4c3c:	46 e0       	ldi	r20, 0x06	; 6
    4c3e:	50 e0       	ldi	r21, 0x00	; 0
    4c40:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
																	NTRXSetIndexReg (0);
    4c44:	80 e0       	ldi	r24, 0x00	; 0
    4c46:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
																	NTRXSPIWrite (NA_RamStaAddr0_O, msg->data , 6);
    4c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    4c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    4c4e:	9c 01       	movw	r18, r24
    4c50:	28 5f       	subi	r18, 0xF8	; 248
    4c52:	3f 4f       	sbci	r19, 0xFF	; 255
    4c54:	80 e8       	ldi	r24, 0x80	; 128
    4c56:	b9 01       	movw	r22, r18
    4c58:	46 e0       	ldi	r20, 0x06	; 6
    4c5a:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
																	if (phyPIB.rxState == PHY_RX_ON)
    4c5e:	80 91 bf 0e 	lds	r24, 0x0EBF
    4c62:	86 30       	cpi	r24, 0x06	; 6
    4c64:	09 f0       	breq	.+2      	; 0x4c68 <PLMESap+0xbac>
    4c66:	0f c2       	rjmp	.+1054   	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4c68:	80 91 5c 0f 	lds	r24, 0x0F5C
    4c6c:	98 2f       	mov	r25, r24
    4c6e:	9e 60       	ori	r25, 0x0E	; 14
    4c70:	86 e5       	ldi	r24, 0x56	; 86
    4c72:	69 2f       	mov	r22, r25
    4c74:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4c78:	06 c2       	rjmp	.+1036   	; 0x5086 <PLMESap+0xfca>
																											| (1 << NA_RxCmdStart_B)
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_MAC_ADDRESS2:			NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4c7a:	80 91 5c 0f 	lds	r24, 0x0F5C
    4c7e:	98 2f       	mov	r25, r24
    4c80:	91 60       	ori	r25, 0x01	; 1
    4c82:	86 e5       	ldi	r24, 0x56	; 86
    4c84:	69 2f       	mov	r22, r25
    4c86:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	memcpy (phyPIB.macAddr1, msg->data, 6);
    4c8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4c8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4c8e:	9c 01       	movw	r18, r24
    4c90:	28 5f       	subi	r18, 0xF8	; 248
    4c92:	3f 4f       	sbci	r19, 0xFF	; 255
    4c94:	87 ec       	ldi	r24, 0xC7	; 199
    4c96:	9e e0       	ldi	r25, 0x0E	; 14
    4c98:	b9 01       	movw	r22, r18
    4c9a:	46 e0       	ldi	r20, 0x06	; 6
    4c9c:	50 e0       	ldi	r21, 0x00	; 0
    4c9e:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
																	NTRXSetIndexReg (0);
    4ca2:	80 e0       	ldi	r24, 0x00	; 0
    4ca4:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
																	NTRXSPIWrite (NA_RamStaAddr1_O, msg->data, 6);
    4ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    4caa:	9e 81       	ldd	r25, Y+6	; 0x06
    4cac:	9c 01       	movw	r18, r24
    4cae:	28 5f       	subi	r18, 0xF8	; 248
    4cb0:	3f 4f       	sbci	r19, 0xFF	; 255
    4cb2:	88 e8       	ldi	r24, 0x88	; 136
    4cb4:	b9 01       	movw	r22, r18
    4cb6:	46 e0       	ldi	r20, 0x06	; 6
    4cb8:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
																	if (phyPIB.rxState == PHY_RX_ON)
    4cbc:	80 91 bf 0e 	lds	r24, 0x0EBF
    4cc0:	86 30       	cpi	r24, 0x06	; 6
    4cc2:	09 f0       	breq	.+2      	; 0x4cc6 <PLMESap+0xc0a>
    4cc4:	e0 c1       	rjmp	.+960    	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4cc6:	80 91 5c 0f 	lds	r24, 0x0F5C
    4cca:	98 2f       	mov	r25, r24
    4ccc:	9e 60       	ori	r25, 0x0E	; 14
    4cce:	86 e5       	ldi	r24, 0x56	; 86
    4cd0:	69 2f       	mov	r22, r25
    4cd2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4cd6:	d7 c1       	rjmp	.+942    	; 0x5086 <PLMESap+0xfca>
																											| (1 << NA_RxCmdStart_B)
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_TX_ADDR_SELECT:		NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4cd8:	80 91 5c 0f 	lds	r24, 0x0F5C
    4cdc:	98 2f       	mov	r25, r24
    4cde:	91 60       	ori	r25, 0x01	; 1
    4ce0:	86 e5       	ldi	r24, 0x56	; 86
    4ce2:	69 2f       	mov	r22, r25
    4ce4:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	phyPIB.txAddrSel = (MyByte8T)(msg->value);
    4ce8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cea:	9e 81       	ldd	r25, Y+6	; 0x06
    4cec:	fc 01       	movw	r30, r24
    4cee:	e7 57       	subi	r30, 0x77	; 119
    4cf0:	ff 4f       	sbci	r31, 0xFF	; 255
    4cf2:	80 81       	ld	r24, Z
    4cf4:	91 81       	ldd	r25, Z+1	; 0x01
    4cf6:	80 93 cd 0e 	sts	0x0ECD, r24
																	if (msg->value == 0)
    4cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    4cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    4cfe:	fc 01       	movw	r30, r24
    4d00:	e7 57       	subi	r30, 0x77	; 119
    4d02:	ff 4f       	sbci	r31, 0xFF	; 255
    4d04:	80 81       	ld	r24, Z
    4d06:	91 81       	ldd	r25, Z+1	; 0x01
    4d08:	00 97       	sbiw	r24, 0x00	; 0
    4d0a:	31 f4       	brne	.+12     	; 0x4d18 <PLMESap+0xc5c>
																	{
																		ntrxShadowReg[NA_TxAddrSlct_O] &= ~(1 << NA_TxAddrSlct_B);
    4d0c:	80 91 5a 0f 	lds	r24, 0x0F5A
    4d10:	8f 77       	andi	r24, 0x7F	; 127
    4d12:	80 93 5a 0f 	sts	0x0F5A, r24
    4d16:	05 c0       	rjmp	.+10     	; 0x4d22 <PLMESap+0xc66>
																	}
																	else
																	{
																		ntrxShadowReg[NA_TxAddrSlct_O] |= (1 << NA_TxAddrSlct_B);
    4d18:	80 91 5a 0f 	lds	r24, 0x0F5A
    4d1c:	80 68       	ori	r24, 0x80	; 128
    4d1e:	80 93 5a 0f 	sts	0x0F5A, r24
																	}
																	NTRXSPIWriteByte (NA_TxAddrSlct_O, ntrxShadowReg[NA_TxAddrSlct_O]);
    4d22:	90 91 5a 0f 	lds	r25, 0x0F5A
    4d26:	84 e5       	ldi	r24, 0x54	; 84
    4d28:	69 2f       	mov	r22, r25
    4d2a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	if (phyPIB.rxState == PHY_RX_ON)
    4d2e:	80 91 bf 0e 	lds	r24, 0x0EBF
    4d32:	86 30       	cpi	r24, 0x06	; 6
    4d34:	09 f0       	breq	.+2      	; 0x4d38 <PLMESap+0xc7c>
    4d36:	a7 c1       	rjmp	.+846    	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4d38:	80 91 5c 0f 	lds	r24, 0x0F5C
    4d3c:	98 2f       	mov	r25, r24
    4d3e:	9e 60       	ori	r25, 0x0E	; 14
    4d40:	86 e5       	ldi	r24, 0x56	; 86
    4d42:	69 2f       	mov	r22, r25
    4d44:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4d48:	9e c1       	rjmp	.+828    	; 0x5086 <PLMESap+0xfca>
																											| (1 << NA_RxCmdStart_B)
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_ADDR_MATCHING:			NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    4d4a:	80 91 5c 0f 	lds	r24, 0x0F5C
    4d4e:	98 2f       	mov	r25, r24
    4d50:	91 60       	ori	r25, 0x01	; 1
    4d52:	86 e5       	ldi	r24, 0x56	; 86
    4d54:	69 2f       	mov	r22, r25
    4d56:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	phyPIB.addrMatch = (MyByte8T)(msg->value);
    4d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d5e:	fc 01       	movw	r30, r24
    4d60:	e7 57       	subi	r30, 0x77	; 119
    4d62:	ff 4f       	sbci	r31, 0xFF	; 255
    4d64:	80 81       	ld	r24, Z
    4d66:	91 81       	ldd	r25, Z+1	; 0x01
    4d68:	80 93 d0 0e 	sts	0x0ED0, r24
																	if (msg->value == 0)
    4d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d6e:	9e 81       	ldd	r25, Y+6	; 0x06
    4d70:	fc 01       	movw	r30, r24
    4d72:	e7 57       	subi	r30, 0x77	; 119
    4d74:	ff 4f       	sbci	r31, 0xFF	; 255
    4d76:	80 81       	ld	r24, Z
    4d78:	91 81       	ldd	r25, Z+1	; 0x01
    4d7a:	00 97       	sbiw	r24, 0x00	; 0
    4d7c:	31 f4       	brne	.+12     	; 0x4d8a <PLMESap+0xcce>
																	{
																		/* promiscuous mode */
																		ntrxShadowReg[NA_RxAddrMode_O] &= ~(1 << NA_RxAddrMode_B);
    4d7e:	80 91 61 0f 	lds	r24, 0x0F61
    4d82:	87 7f       	andi	r24, 0xF7	; 247
    4d84:	80 93 61 0f 	sts	0x0F61, r24
    4d88:	05 c0       	rjmp	.+10     	; 0x4d94 <PLMESap+0xcd8>
																	}
																	else
																	{
																		ntrxShadowReg[NA_RxAddrMode_O] |= (1 << NA_RxAddrMode_B);
    4d8a:	80 91 61 0f 	lds	r24, 0x0F61
    4d8e:	88 60       	ori	r24, 0x08	; 8
    4d90:	80 93 61 0f 	sts	0x0F61, r24
																	}
																	NTRXSPIWriteByte (NA_RxAddrMode_O, ntrxShadowReg[NA_RxAddrMode_O]);
    4d94:	90 91 61 0f 	lds	r25, 0x0F61
    4d98:	8b e5       	ldi	r24, 0x5B	; 91
    4d9a:	69 2f       	mov	r22, r25
    4d9c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	if (phyPIB.rxState == PHY_RX_ON)
    4da0:	80 91 bf 0e 	lds	r24, 0x0EBF
    4da4:	86 30       	cpi	r24, 0x06	; 6
    4da6:	09 f0       	breq	.+2      	; 0x4daa <PLMESap+0xcee>
    4da8:	6e c1       	rjmp	.+732    	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4daa:	80 91 5c 0f 	lds	r24, 0x0F5C
    4dae:	98 2f       	mov	r25, r24
    4db0:	9e 60       	ori	r25, 0x0E	; 14
    4db2:	86 e5       	ldi	r24, 0x56	; 86
    4db4:	69 2f       	mov	r22, r25
    4db6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4dba:	65 c1       	rjmp	.+714    	; 0x5086 <PLMESap+0xfca>
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									case PHY_RECALIBRATION:			/* delay time for recalibration */
																	phyPIB.recalInterval = msg->value * 1000;
    4dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbe:	9e 81       	ldd	r25, Y+6	; 0x06
    4dc0:	fc 01       	movw	r30, r24
    4dc2:	e7 57       	subi	r30, 0x77	; 119
    4dc4:	ff 4f       	sbci	r31, 0xFF	; 255
    4dc6:	20 81       	ld	r18, Z
    4dc8:	31 81       	ldd	r19, Z+1	; 0x01
    4dca:	88 ee       	ldi	r24, 0xE8	; 232
    4dcc:	93 e0       	ldi	r25, 0x03	; 3
    4dce:	ac 01       	movw	r20, r24
    4dd0:	24 9f       	mul	r18, r20
    4dd2:	c0 01       	movw	r24, r0
    4dd4:	25 9f       	mul	r18, r21
    4dd6:	90 0d       	add	r25, r0
    4dd8:	34 9f       	mul	r19, r20
    4dda:	90 0d       	add	r25, r0
    4ddc:	11 24       	eor	r1, r1
    4dde:	cc 01       	movw	r24, r24
    4de0:	a0 e0       	ldi	r26, 0x00	; 0
    4de2:	b0 e0       	ldi	r27, 0x00	; 0
    4de4:	80 93 d3 0e 	sts	0x0ED3, r24
    4de8:	90 93 d4 0e 	sts	0x0ED4, r25
    4dec:	a0 93 d5 0e 	sts	0x0ED5, r26
    4df0:	b0 93 d6 0e 	sts	0x0ED6, r27
    4df4:	48 c1       	rjmp	.+656    	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_PWR_DOWN_MODE:			if (msg->value > 1)
    4df6:	8d 81       	ldd	r24, Y+5	; 0x05
    4df8:	9e 81       	ldd	r25, Y+6	; 0x06
    4dfa:	fc 01       	movw	r30, r24
    4dfc:	e7 57       	subi	r30, 0x77	; 119
    4dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    4e00:	80 81       	ld	r24, Z
    4e02:	91 81       	ldd	r25, Z+1	; 0x01
    4e04:	82 30       	cpi	r24, 0x02	; 2
    4e06:	91 05       	cpc	r25, r1
    4e08:	40 f0       	brcs	.+16     	; 0x4e1a <PLMESap+0xd5e>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    4e0a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e0c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e0e:	fc 01       	movw	r30, r24
    4e10:	e8 57       	subi	r30, 0x78	; 120
    4e12:	ff 4f       	sbci	r31, 0xFF	; 255
    4e14:	85 e0       	ldi	r24, 0x05	; 5
    4e16:	80 83       	st	Z, r24
    4e18:	36 c1       	rjmp	.+620    	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		trxPollMode = (phyPIB.recalInterval == 0) ? FALSE : TRUE;
    4e1a:	80 91 d3 0e 	lds	r24, 0x0ED3
    4e1e:	90 91 d4 0e 	lds	r25, 0x0ED4
    4e22:	a0 91 d5 0e 	lds	r26, 0x0ED5
    4e26:	b0 91 d6 0e 	lds	r27, 0x0ED6
    4e2a:	1d 86       	std	Y+13, r1	; 0x0d
    4e2c:	00 97       	sbiw	r24, 0x00	; 0
    4e2e:	a1 05       	cpc	r26, r1
    4e30:	b1 05       	cpc	r27, r1
    4e32:	11 f0       	breq	.+4      	; 0x4e38 <PLMESap+0xd7c>
    4e34:	51 e0       	ldi	r21, 0x01	; 1
    4e36:	5d 87       	std	Y+13, r21	; 0x0d
    4e38:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e3a:	80 93 db 06 	sts	0x06DB, r24
																		phyPIB.pwrDownMode = msg->value;
    4e3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4e40:	9e 81       	ldd	r25, Y+6	; 0x06
    4e42:	fc 01       	movw	r30, r24
    4e44:	e7 57       	subi	r30, 0x77	; 119
    4e46:	ff 4f       	sbci	r31, 0xFF	; 255
    4e48:	80 81       	ld	r24, Z
    4e4a:	91 81       	ldd	r25, Z+1	; 0x01
    4e4c:	80 93 db 0e 	sts	0x0EDB, r24
																		NTRXResetSettings ();
    4e50:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <NTRXResetSettings>
																		NTRXPowerdownMode (msg->value, *(MyDword32T*)(msg->data));
    4e54:	8d 81       	ldd	r24, Y+5	; 0x05
    4e56:	9e 81       	ldd	r25, Y+6	; 0x06
    4e58:	fc 01       	movw	r30, r24
    4e5a:	e7 57       	subi	r30, 0x77	; 119
    4e5c:	ff 4f       	sbci	r31, 0xFF	; 255
    4e5e:	80 81       	ld	r24, Z
    4e60:	91 81       	ldd	r25, Z+1	; 0x01
    4e62:	68 2f       	mov	r22, r24
    4e64:	8d 81       	ldd	r24, Y+5	; 0x05
    4e66:	9e 81       	ldd	r25, Y+6	; 0x06
    4e68:	08 96       	adiw	r24, 0x08	; 8
    4e6a:	fc 01       	movw	r30, r24
    4e6c:	20 81       	ld	r18, Z
    4e6e:	31 81       	ldd	r19, Z+1	; 0x01
    4e70:	42 81       	ldd	r20, Z+2	; 0x02
    4e72:	53 81       	ldd	r21, Z+3	; 0x03
    4e74:	86 2f       	mov	r24, r22
    4e76:	ba 01       	movw	r22, r20
    4e78:	a9 01       	movw	r20, r18
    4e7a:	0e 94 33 32 	call	0x6466	; 0x6466 <NTRXPowerdownMode>
    4e7e:	03 c1       	rjmp	.+518    	; 0x5086 <PLMESap+0xfca>
																	}
																	break;

									case PHY_FRAME_TYPE:			phyPIB.frameType = ( msg->value & 0x07 );
    4e80:	8d 81       	ldd	r24, Y+5	; 0x05
    4e82:	9e 81       	ldd	r25, Y+6	; 0x06
    4e84:	fc 01       	movw	r30, r24
    4e86:	e7 57       	subi	r30, 0x77	; 119
    4e88:	ff 4f       	sbci	r31, 0xFF	; 255
    4e8a:	80 81       	ld	r24, Z
    4e8c:	91 81       	ldd	r25, Z+1	; 0x01
    4e8e:	87 70       	andi	r24, 0x07	; 7
    4e90:	80 93 dc 0e 	sts	0x0EDC, r24
																	ntrxShadowReg[NA_RxDataEn_O] = ~( 0x07 );
    4e94:	88 ef       	ldi	r24, 0xF8	; 248
    4e96:	80 93 61 0f 	sts	0x0F61, r24
																	ntrxShadowReg[NA_RxDataEn_O] |= phyPIB.frameType;
    4e9a:	90 91 61 0f 	lds	r25, 0x0F61
    4e9e:	80 91 dc 0e 	lds	r24, 0x0EDC
    4ea2:	89 2b       	or	r24, r25
    4ea4:	80 93 61 0f 	sts	0x0F61, r24
																	NTRXSPIWriteByte (NA_RxDataEn_O , ntrxShadowReg[NA_RxDataEn_O]);
    4ea8:	90 91 61 0f 	lds	r25, 0x0F61
    4eac:	8b e5       	ldi	r24, 0x5B	; 91
    4eae:	69 2f       	mov	r22, r25
    4eb0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4eb4:	e8 c0       	rjmp	.+464    	; 0x5086 <PLMESap+0xfca>
																	break;

									case PHY_TESTMODE:				if (msg->value > 2)
    4eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    4eb8:	9e 81       	ldd	r25, Y+6	; 0x06
    4eba:	fc 01       	movw	r30, r24
    4ebc:	e7 57       	subi	r30, 0x77	; 119
    4ebe:	ff 4f       	sbci	r31, 0xFF	; 255
    4ec0:	80 81       	ld	r24, Z
    4ec2:	91 81       	ldd	r25, Z+1	; 0x01
    4ec4:	83 30       	cpi	r24, 0x03	; 3
    4ec6:	91 05       	cpc	r25, r1
    4ec8:	40 f0       	brcs	.+16     	; 0x4eda <PLMESap+0xe1e>
																	{
																		msg->status = PHY_INVALID_PARAMETER;
    4eca:	8d 81       	ldd	r24, Y+5	; 0x05
    4ecc:	9e 81       	ldd	r25, Y+6	; 0x06
    4ece:	fc 01       	movw	r30, r24
    4ed0:	e8 57       	subi	r30, 0x78	; 120
    4ed2:	ff 4f       	sbci	r31, 0xFF	; 255
    4ed4:	85 e0       	ldi	r24, 0x05	; 5
    4ed6:	80 83       	st	Z, r24
    4ed8:	d6 c0       	rjmp	.+428    	; 0x5086 <PLMESap+0xfca>
																	}
																	else
																	{
																		switch (msg->value)
    4eda:	8d 81       	ldd	r24, Y+5	; 0x05
    4edc:	9e 81       	ldd	r25, Y+6	; 0x06
    4ede:	fc 01       	movw	r30, r24
    4ee0:	e7 57       	subi	r30, 0x77	; 119
    4ee2:	ff 4f       	sbci	r31, 0xFF	; 255
    4ee4:	20 81       	ld	r18, Z
    4ee6:	31 81       	ldd	r19, Z+1	; 0x01
    4ee8:	3c 87       	std	Y+12, r19	; 0x0c
    4eea:	2b 87       	std	Y+11, r18	; 0x0b
    4eec:	4b 85       	ldd	r20, Y+11	; 0x0b
    4eee:	5c 85       	ldd	r21, Y+12	; 0x0c
    4ef0:	41 30       	cpi	r20, 0x01	; 1
    4ef2:	51 05       	cpc	r21, r1
    4ef4:	31 f0       	breq	.+12     	; 0x4f02 <PLMESap+0xe46>
    4ef6:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ef8:	9c 85       	ldd	r25, Y+12	; 0x0c
    4efa:	82 30       	cpi	r24, 0x02	; 2
    4efc:	91 05       	cpc	r25, r1
    4efe:	69 f0       	breq	.+26     	; 0x4f1a <PLMESap+0xe5e>
    4f00:	18 c0       	rjmp	.+48     	; 0x4f32 <PLMESap+0xe76>
																		{
																			case 1:	TestmodeOff ();
    4f02:	0e 94 3c 20 	call	0x4078	; 0x4078 <TestmodeOff>
																					NTRXSetTestChirpMode (TRUE);
    4f06:	81 e0       	ldi	r24, 0x01	; 1
    4f08:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
																					/* this blocks the transmission path of the PDSap */
																					txSendMsg = &upMsg;
    4f0c:	8d e0       	ldi	r24, 0x0D	; 13
    4f0e:	9e e0       	ldi	r25, 0x0E	; 14
    4f10:	90 93 ff 0d 	sts	0x0DFF, r25
    4f14:	80 93 fe 0d 	sts	0x0DFE, r24
    4f18:	12 c0       	rjmp	.+36     	; 0x4f3e <PLMESap+0xe82>
																					break;

																			 case 2: TestmodeOff ();
    4f1a:	0e 94 3c 20 	call	0x4078	; 0x4078 <TestmodeOff>
																					NTRXSetTestCarrierMode (TRUE);
    4f1e:	81 e0       	ldi	r24, 0x01	; 1
    4f20:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
																					/* this blocks the transmission path of the PDSap */
																					txSendMsg = &upMsg;
    4f24:	8d e0       	ldi	r24, 0x0D	; 13
    4f26:	9e e0       	ldi	r25, 0x0E	; 14
    4f28:	90 93 ff 0d 	sts	0x0DFF, r25
    4f2c:	80 93 fe 0d 	sts	0x0DFE, r24
    4f30:	06 c0       	rjmp	.+12     	; 0x4f3e <PLMESap+0xe82>
																					break;

																			default:/* this enables the transmission path of the PDSap */
																					TestmodeOff ();
    4f32:	0e 94 3c 20 	call	0x4078	; 0x4078 <TestmodeOff>
																					txSendMsg = NULL;
    4f36:	10 92 ff 0d 	sts	0x0DFF, r1
    4f3a:	10 92 fe 0d 	sts	0x0DFE, r1
																		}

																		phyPIB.testmode = msg->value;
    4f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f40:	9e 81       	ldd	r25, Y+6	; 0x06
    4f42:	fc 01       	movw	r30, r24
    4f44:	e7 57       	subi	r30, 0x77	; 119
    4f46:	ff 4f       	sbci	r31, 0xFF	; 255
    4f48:	80 81       	ld	r24, Z
    4f4a:	91 81       	ldd	r25, Z+1	; 0x01
    4f4c:	80 93 dd 0e 	sts	0x0EDD, r24
    4f50:	9a c0       	rjmp	.+308    	; 0x5086 <PLMESap+0xfca>

																	}
																	break;

									case PHY_RX_CMD:
																	switch (msg->value)
    4f52:	8d 81       	ldd	r24, Y+5	; 0x05
    4f54:	9e 81       	ldd	r25, Y+6	; 0x06
    4f56:	fc 01       	movw	r30, r24
    4f58:	e7 57       	subi	r30, 0x77	; 119
    4f5a:	ff 4f       	sbci	r31, 0xFF	; 255
    4f5c:	20 81       	ld	r18, Z
    4f5e:	31 81       	ldd	r19, Z+1	; 0x01
    4f60:	3a 87       	std	Y+10, r19	; 0x0a
    4f62:	29 87       	std	Y+9, r18	; 0x09
    4f64:	49 85       	ldd	r20, Y+9	; 0x09
    4f66:	5a 85       	ldd	r21, Y+10	; 0x0a
    4f68:	46 30       	cpi	r20, 0x06	; 6
    4f6a:	51 05       	cpc	r21, r1
    4f6c:	29 f0       	breq	.+10     	; 0x4f78 <PLMESap+0xebc>
    4f6e:	89 85       	ldd	r24, Y+9	; 0x09
    4f70:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f72:	88 30       	cpi	r24, 0x08	; 8
    4f74:	91 05       	cpc	r25, r1
    4f76:	59 f5       	brne	.+86     	; 0x4fce <PLMESap+0xf12>
																	{
																		case PHY_TRX_OFF:
																		case PHY_RX_ON:
																							phyPIB.rxState = msg->value;
    4f78:	8d 81       	ldd	r24, Y+5	; 0x05
    4f7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	e7 57       	subi	r30, 0x77	; 119
    4f80:	ff 4f       	sbci	r31, 0xFF	; 255
    4f82:	80 81       	ld	r24, Z
    4f84:	91 81       	ldd	r25, Z+1	; 0x01
    4f86:	80 93 bf 0e 	sts	0x0EBF, r24
																							/*stop the receiver and clear the buffers */
																							NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O]
    4f8a:	80 91 5c 0f 	lds	r24, 0x0F5C
    4f8e:	98 2f       	mov	r25, r24
    4f90:	9d 60       	ori	r25, 0x0D	; 13
    4f92:	86 e5       	ldi	r24, 0x56	; 86
    4f94:	69 2f       	mov	r22, r25
    4f96:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																															| (1 << NA_RxCmdStop_B)
																															| (0x03 << NA_RxBufferCmd_LSB));
																							/* clear interrupts */
																							NTRXSPIWriteByte (NA_RxIntsReset_O, 0x7F);
    4f9a:	81 e1       	ldi	r24, 0x11	; 17
    4f9c:	6f e7       	ldi	r22, 0x7F	; 127
    4f9e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																							rxIrq = 0;
    4fa2:	10 92 af 0e 	sts	0x0EAF, r1
#																							ifdef CONFIG_NTRX_SNIFFER
																							upMsg.count=0;
#																							endif
																							if (msg->value == PHY_RX_ON)
    4fa6:	8d 81       	ldd	r24, Y+5	; 0x05
    4fa8:	9e 81       	ldd	r25, Y+6	; 0x06
    4faa:	fc 01       	movw	r30, r24
    4fac:	e7 57       	subi	r30, 0x77	; 119
    4fae:	ff 4f       	sbci	r31, 0xFF	; 255
    4fb0:	80 81       	ld	r24, Z
    4fb2:	91 81       	ldd	r25, Z+1	; 0x01
    4fb4:	86 30       	cpi	r24, 0x06	; 6
    4fb6:	91 05       	cpc	r25, r1
    4fb8:	09 f0       	breq	.+2      	; 0x4fbc <PLMESap+0xf00>
    4fba:	65 c0       	rjmp	.+202    	; 0x5086 <PLMESap+0xfca>
																							{
																								/*start the receiver*/
																								NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    4fbc:	80 91 5c 0f 	lds	r24, 0x0F5C
    4fc0:	98 2f       	mov	r25, r24
    4fc2:	92 60       	ori	r25, 0x02	; 2
    4fc4:	86 e5       	ldi	r24, 0x56	; 86
    4fc6:	69 2f       	mov	r22, r25
    4fc8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    4fcc:	5c c0       	rjmp	.+184    	; 0x5086 <PLMESap+0xfca>
																																| (1 << NA_RxCmdStart_B));
																							}
																							break;

																		default: 			msg->status = PHY_INVALID_PARAMETER;
    4fce:	8d 81       	ldd	r24, Y+5	; 0x05
    4fd0:	9e 81       	ldd	r25, Y+6	; 0x06
    4fd2:	fc 01       	movw	r30, r24
    4fd4:	e8 57       	subi	r30, 0x78	; 120
    4fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    4fd8:	85 e0       	ldi	r24, 0x05	; 5
    4fda:	80 83       	st	Z, r24
    4fdc:	54 c0       	rjmp	.+168    	; 0x5086 <PLMESap+0xfca>
																							break;
																	}
																	break;

									case PHY_RX_STATE:				switch (msg->value)
    4fde:	8d 81       	ldd	r24, Y+5	; 0x05
    4fe0:	9e 81       	ldd	r25, Y+6	; 0x06
    4fe2:	fc 01       	movw	r30, r24
    4fe4:	e7 57       	subi	r30, 0x77	; 119
    4fe6:	ff 4f       	sbci	r31, 0xFF	; 255
    4fe8:	20 81       	ld	r18, Z
    4fea:	31 81       	ldd	r19, Z+1	; 0x01
    4fec:	38 87       	std	Y+8, r19	; 0x08
    4fee:	2f 83       	std	Y+7, r18	; 0x07
    4ff0:	4f 81       	ldd	r20, Y+7	; 0x07
    4ff2:	58 85       	ldd	r21, Y+8	; 0x08
    4ff4:	46 30       	cpi	r20, 0x06	; 6
    4ff6:	51 05       	cpc	r21, r1
    4ff8:	29 f0       	breq	.+10     	; 0x5004 <PLMESap+0xf48>
    4ffa:	8f 81       	ldd	r24, Y+7	; 0x07
    4ffc:	98 85       	ldd	r25, Y+8	; 0x08
    4ffe:	88 30       	cpi	r24, 0x08	; 8
    5000:	91 05       	cpc	r25, r1
    5002:	51 f4       	brne	.+20     	; 0x5018 <PLMESap+0xf5c>
																	{
																		case PHY_RX_ON:
																		case PHY_TRX_OFF: 	phyPIB.rxState = msg->value;
    5004:	8d 81       	ldd	r24, Y+5	; 0x05
    5006:	9e 81       	ldd	r25, Y+6	; 0x06
    5008:	fc 01       	movw	r30, r24
    500a:	e7 57       	subi	r30, 0x77	; 119
    500c:	ff 4f       	sbci	r31, 0xFF	; 255
    500e:	80 81       	ld	r24, Z
    5010:	91 81       	ldd	r25, Z+1	; 0x01
    5012:	80 93 bf 0e 	sts	0x0EBF, r24
    5016:	37 c0       	rjmp	.+110    	; 0x5086 <PLMESap+0xfca>
																							break;

																		default: 			msg->status = PHY_INVALID_PARAMETER;
    5018:	8d 81       	ldd	r24, Y+5	; 0x05
    501a:	9e 81       	ldd	r25, Y+6	; 0x06
    501c:	fc 01       	movw	r30, r24
    501e:	e8 57       	subi	r30, 0x78	; 120
    5020:	ff 4f       	sbci	r31, 0xFF	; 255
    5022:	85 e0       	ldi	r24, 0x05	; 5
    5024:	80 83       	st	Z, r24
    5026:	2f c0       	rjmp	.+94     	; 0x5086 <PLMESap+0xfca>
																							break;
																	}
																	break;

									case PHY_SYNCWORD:				NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    5028:	80 91 5c 0f 	lds	r24, 0x0F5C
    502c:	98 2f       	mov	r25, r24
    502e:	91 60       	ori	r25, 0x01	; 1
    5030:	86 e5       	ldi	r24, 0x56	; 86
    5032:	69 2f       	mov	r22, r25
    5034:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
																	memcpy (phyPIB.syncword, (MyByte8T *)(msg->value), 8);
    5038:	8d 81       	ldd	r24, Y+5	; 0x05
    503a:	9e 81       	ldd	r25, Y+6	; 0x06
    503c:	fc 01       	movw	r30, r24
    503e:	e7 57       	subi	r30, 0x77	; 119
    5040:	ff 4f       	sbci	r31, 0xFF	; 255
    5042:	80 81       	ld	r24, Z
    5044:	91 81       	ldd	r25, Z+1	; 0x01
    5046:	9c 01       	movw	r18, r24
    5048:	8e ed       	ldi	r24, 0xDE	; 222
    504a:	9e e0       	ldi	r25, 0x0E	; 14
    504c:	b9 01       	movw	r22, r18
    504e:	48 e0       	ldi	r20, 0x08	; 8
    5050:	50 e0       	ldi	r21, 0x00	; 0
    5052:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
																	NTRXSetSyncWord(phyPIB.syncword);
    5056:	8e ed       	ldi	r24, 0xDE	; 222
    5058:	9e e0       	ldi	r25, 0x0E	; 14
    505a:	0e 94 16 30 	call	0x602c	; 0x602c <NTRXSetSyncWord>
																	if (phyPIB.rxState == PHY_RX_ON)
    505e:	80 91 bf 0e 	lds	r24, 0x0EBF
    5062:	86 30       	cpi	r24, 0x06	; 6
    5064:	81 f4       	brne	.+32     	; 0x5086 <PLMESap+0xfca>
																	{
																		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    5066:	80 91 5c 0f 	lds	r24, 0x0F5C
    506a:	98 2f       	mov	r25, r24
    506c:	9e 60       	ori	r25, 0x0E	; 14
    506e:	86 e5       	ldi	r24, 0x56	; 86
    5070:	69 2f       	mov	r22, r25
    5072:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    5076:	07 c0       	rjmp	.+14     	; 0x5086 <PLMESap+0xfca>
																											| (1 << NA_RxCmdStart_B)
																											| (0x03 << NA_RxBufferCmd_LSB));
																	}
																	break;

									default: 						msg->status = PHY_UNSUPPORTED_ATTRIBUTE;
    5078:	8d 81       	ldd	r24, Y+5	; 0x05
    507a:	9e 81       	ldd	r25, Y+6	; 0x06
    507c:	fc 01       	movw	r30, r24
    507e:	e8 57       	subi	r30, 0x78	; 120
    5080:	ff 4f       	sbci	r31, 0xFF	; 255
    5082:	8a e0       	ldi	r24, 0x0A	; 10
    5084:	80 83       	st	Z, r24
								SendCfgUp (msg);
								break;
		default:				break;
	}
	/* ieee config stuff */
}
    5086:	6d 96       	adiw	r28, 0x1d	; 29
    5088:	0f b6       	in	r0, 0x3f	; 63
    508a:	f8 94       	cli
    508c:	de bf       	out	0x3e, r29	; 62
    508e:	0f be       	out	0x3f, r0	; 63
    5090:	cd bf       	out	0x3d, r28	; 61
    5092:	cf 91       	pop	r28
    5094:	df 91       	pop	r29
    5096:	08 95       	ret

00005098 <PDCallback>:
 *
 */
/****************************************************************************/
void PDCallback (void)
/****************************************************************************/
{
    5098:	df 93       	push	r29
    509a:	cf 93       	push	r28
    509c:	00 d0       	rcall	.+0      	; 0x509e <PDCallback+0x6>
    509e:	0f 92       	push	r0
    50a0:	cd b7       	in	r28, 0x3d	; 61
    50a2:	de b7       	in	r29, 0x3e	; 62
	/*
	 * use 1 led to indicate message reception on the devBoard
	 * The led will stay on for a 50 ms.
     */
#   ifdef CONFIG_TRAFFIC_LED
    TRIGGER_LED_RX ();
    50a4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    50a8:	dc 01       	movw	r26, r24
    50aa:	cb 01       	movw	r24, r22
    50ac:	c2 96       	adiw	r24, 0x32	; 50
    50ae:	a1 1d       	adc	r26, r1
    50b0:	b1 1d       	adc	r27, r1
    50b2:	80 93 05 0e 	sts	0x0E05, r24
    50b6:	90 93 06 0e 	sts	0x0E06, r25
    50ba:	a0 93 07 0e 	sts	0x0E07, r26
    50be:	b0 93 08 0e 	sts	0x0E08, r27
    50c2:	a8 e2       	ldi	r26, 0x28	; 40
    50c4:	b0 e0       	ldi	r27, 0x00	; 0
    50c6:	e8 e2       	ldi	r30, 0x28	; 40
    50c8:	f0 e0       	ldi	r31, 0x00	; 0
    50ca:	80 81       	ld	r24, Z
    50cc:	8f 77       	andi	r24, 0x7F	; 127
    50ce:	8c 93       	st	X, r24
#   endif /* CONFIG_TRAFFIC_LED */

	/*
	 * read the crc2 status register
	 */
    NTRXSPIReadByte (NA_RxCrc2Stat_O, &status);
    50d0:	81 e3       	ldi	r24, 0x31	; 49
    50d2:	9e 01       	movw	r18, r28
    50d4:	2f 5f       	subi	r18, 0xFF	; 255
    50d6:	3f 4f       	sbci	r19, 0xFF	; 255
    50d8:	b9 01       	movw	r22, r18
    50da:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
    rxIrq = 0;
    50de:	10 92 af 0e 	sts	0x0EAF, r1

    /* check if data is valid */
    if ((status & (1 << NA_RxCrc2Stat_B)) != 0)
    50e2:	89 81       	ldd	r24, Y+1	; 0x01
    50e4:	88 23       	and	r24, r24
    50e6:	0c f0       	brlt	.+2      	; 0x50ea <PDCallback+0x52>
    50e8:	78 c1       	rjmp	.+752    	; 0x53da <PDCallback+0x342>
    {
        NTRXSetIndexReg (0);
    50ea:	80 e0       	ldi	r24, 0x00	; 0
    50ec:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
        /* read source address */
        NTRXSPIRead (NA_RamRxSrcAddr_O, upMsg.addr, 6);
    50f0:	2e e0       	ldi	r18, 0x0E	; 14
    50f2:	3e e0       	ldi	r19, 0x0E	; 14
    50f4:	80 eb       	ldi	r24, 0xB0	; 176
    50f6:	b9 01       	movw	r22, r18
    50f8:	46 e0       	ldi	r20, 0x06	; 6
    50fa:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
        /* read length plus additionl bits */
        NTRXSPIRead (NA_RamRxLength_O, reg, 2);
    50fe:	9e 01       	movw	r18, r28
    5100:	2e 5f       	subi	r18, 0xFE	; 254
    5102:	3f 4f       	sbci	r19, 0xFF	; 255
    5104:	88 eb       	ldi	r24, 0xB8	; 184
    5106:	b9 01       	movw	r22, r18
    5108:	42 e0       	ldi	r20, 0x02	; 2
    510a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>

        rState = reg[1]>>5;
    510e:	8b 81       	ldd	r24, Y+3	; 0x03
    5110:	82 95       	swap	r24
    5112:	86 95       	lsr	r24
    5114:	87 70       	andi	r24, 0x07	; 7
    5116:	80 93 b2 0e 	sts	0x0EB2, r24

// Sensorfly NOTE: We modified this part of the code to allow for "broadcast" messaging functionality. To revert, uncomment the commented lines from here until "End of sensorfly note". Basically, by default it doesn't read the destination address into the upMsg unless it's configured to "Sniff", so we want to always read the address.

        /* read destination address */
//#		ifdef CONFIG_NTRX_SNIFFER
        NTRXSPIRead (NA_RamRxDstAddr_O, upMsg.rxAddr, 6); 
    511a:	2d e9       	ldi	r18, 0x9D	; 157
    511c:	3e e0       	ldi	r19, 0x0E	; 14
    511e:	88 ea       	ldi	r24, 0xA8	; 168
    5120:	b9 01       	movw	r22, r18
    5122:	46 e0       	ldi	r20, 0x06	; 6
    5124:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
//		upMsg.frameType = (status & 0x0f);
//#		endif

// END of Sensorfly note

		upMsg.len = reg[0];
    5128:	8a 81       	ldd	r24, Y+2	; 0x02
    512a:	80 93 14 0e 	sts	0x0E14, r24
        if (upMsg.len > PHY_PACKET_SIZE)
    512e:	80 91 14 0e 	lds	r24, 0x0E14
    5132:	81 38       	cpi	r24, 0x81	; 129
    5134:	70 f0       	brcs	.+28     	; 0x5152 <PDCallback+0xba>
        {
		    /* restart receiver */
			if (phyPIB.rxState == PHY_RX_ON)
    5136:	80 91 bf 0e 	lds	r24, 0x0EBF
    513a:	86 30       	cpi	r24, 0x06	; 6
    513c:	09 f0       	breq	.+2      	; 0x5140 <PDCallback+0xa8>
    513e:	4d c1       	rjmp	.+666    	; 0x53da <PDCallback+0x342>
			{
    			NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    5140:	80 91 5c 0f 	lds	r24, 0x0F5C
    5144:	98 2f       	mov	r25, r24
    5146:	9e 60       	ori	r25, 0x0E	; 14
    5148:	86 e5       	ldi	r24, 0x56	; 86
    514a:	69 2f       	mov	r22, r25
    514c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    5150:	44 c1       	rjmp	.+648    	; 0x53da <PDCallback+0x342>
			}
        }
        else
        {

			if (buffSwapped == TRUE)
    5152:	80 91 00 0e 	lds	r24, 0x0E00
    5156:	81 30       	cpi	r24, 0x01	; 1
    5158:	89 f4       	brne	.+34     	; 0x517c <PDCallback+0xe4>
			{
				buffSwapped = FALSE;
    515a:	10 92 00 0e 	sts	0x0E00, r1
				/* SWAP BUFFER for receive*/
				ntrxShadowReg[NA_SwapBbBuffers_O] &= ~(1 << NA_SwapBbBuffers_B);
    515e:	80 91 50 0f 	lds	r24, 0x0F50
    5162:	8e 7f       	andi	r24, 0xFE	; 254
    5164:	80 93 50 0f 	sts	0x0F50, r24
				NTRXSPIWriteByte (NA_SwapBbBuffers_O, ntrxShadowReg[NA_SwapBbBuffers_O]);
    5168:	90 91 50 0f 	lds	r25, 0x0F50
    516c:	8a e4       	ldi	r24, 0x4A	; 74
    516e:	69 2f       	mov	r22, r25
    5170:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

				NTRXSetIndexReg (3);
    5174:	83 e0       	ldi	r24, 0x03	; 3
    5176:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
    517a:	11 c0       	rjmp	.+34     	; 0x519e <PDCallback+0x106>
			}
			else
			{
				buffSwapped = TRUE;
    517c:	81 e0       	ldi	r24, 0x01	; 1
    517e:	80 93 00 0e 	sts	0x0E00, r24
				/* SWAP BUFFER for receive*/
				ntrxShadowReg[NA_SwapBbBuffers_O] |= (1 << NA_SwapBbBuffers_B);
    5182:	80 91 50 0f 	lds	r24, 0x0F50
    5186:	81 60       	ori	r24, 0x01	; 1
    5188:	80 93 50 0f 	sts	0x0F50, r24
				NTRXSPIWriteByte (NA_SwapBbBuffers_O, ntrxShadowReg[NA_SwapBbBuffers_O]);
    518c:	90 91 50 0f 	lds	r25, 0x0F50
    5190:	8a e4       	ldi	r24, 0x4A	; 74
    5192:	69 2f       	mov	r22, r25
    5194:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

				NTRXSetIndexReg (2);
    5198:	82 e0       	ldi	r24, 0x02	; 2
    519a:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
			}

			tiPhyRxTimeout_once = FALSE;
    519e:	10 92 ad 0e 	sts	0x0EAD, r1
			tiPhyRxTimeout = hwclock() + phyPIB.phyRxTimeout;
    51a2:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    51a6:	9b 01       	movw	r18, r22
    51a8:	ac 01       	movw	r20, r24
    51aa:	80 91 d7 0e 	lds	r24, 0x0ED7
    51ae:	90 91 d8 0e 	lds	r25, 0x0ED8
    51b2:	a0 91 d9 0e 	lds	r26, 0x0ED9
    51b6:	b0 91 da 0e 	lds	r27, 0x0EDA
    51ba:	82 0f       	add	r24, r18
    51bc:	93 1f       	adc	r25, r19
    51be:	a4 1f       	adc	r26, r20
    51c0:	b5 1f       	adc	r27, r21
    51c2:	80 93 a9 0e 	sts	0x0EA9, r24
    51c6:	90 93 aa 0e 	sts	0x0EAA, r25
    51ca:	a0 93 ab 0e 	sts	0x0EAB, r26
    51ce:	b0 93 ac 0e 	sts	0x0EAC, r27

			/*
			 * restart receiver and than read rx buffer. This is ok because we use
			 * buffer swapping.
			 */
			if (phyPIB.rxState == PHY_RX_ON)
    51d2:	80 91 bf 0e 	lds	r24, 0x0EBF
    51d6:	86 30       	cpi	r24, 0x06	; 6
    51d8:	41 f4       	brne	.+16     	; 0x51ea <PDCallback+0x152>
			{
    			NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O]
    51da:	80 91 5c 0f 	lds	r24, 0x0F5C
    51de:	98 2f       	mov	r25, r24
    51e0:	9e 60       	ori	r25, 0x0E	; 14
    51e2:	86 e5       	ldi	r24, 0x56	; 86
    51e4:	69 2f       	mov	r22, r25
    51e6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
									| (1 << NA_RxCmdStart_B)
									| (0x03 << NA_RxBufferCmd_LSB));
			}

            NTRXSPIRead ((MyByte8T)(NA_RamRxBuffer_O & 0xFF), upMsg.data, upMsg.len);
    51ea:	90 91 14 0e 	lds	r25, 0x0E14
    51ee:	25 e1       	ldi	r18, 0x15	; 21
    51f0:	3e e0       	ldi	r19, 0x0E	; 14
    51f2:	80 e8       	ldi	r24, 0x80	; 128
    51f4:	b9 01       	movw	r22, r18
    51f6:	49 2f       	mov	r20, r25
    51f8:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
			NTRXSetIndexReg (0);
    51fc:	80 e0       	ldi	r24, 0x00	; 0
    51fe:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
			/*
			 * if address matching off, ignore rangingstates
			 * this path is used for normal data reception
			 * ranging is handled in the else path
			 */
			if (((ntrxShadowReg[NA_RxAddrMode_O] & (1<<NA_RxAddrMode_B)) == 0) ||
    5202:	80 91 61 0f 	lds	r24, 0x0F61
    5206:	88 2f       	mov	r24, r24
    5208:	90 e0       	ldi	r25, 0x00	; 0
    520a:	88 70       	andi	r24, 0x08	; 8
    520c:	90 70       	andi	r25, 0x00	; 0
    520e:	00 97       	sbiw	r24, 0x00	; 0
    5210:	61 f0       	breq	.+24     	; 0x522a <PDCallback+0x192>
    5212:	80 91 b1 0e 	lds	r24, 0x0EB1
    5216:	88 23       	and	r24, r24
    5218:	21 f4       	brne	.+8      	; 0x5222 <PDCallback+0x18a>
    521a:	80 91 b2 0e 	lds	r24, 0x0EB2
    521e:	88 23       	and	r24, r24
    5220:	21 f0       	breq	.+8      	; 0x522a <PDCallback+0x192>
    5222:	80 91 a2 0e 	lds	r24, 0x0EA2
    5226:	8f 3f       	cpi	r24, 0xFF	; 255
    5228:	71 f4       	brne	.+28     	; 0x5246 <PDCallback+0x1ae>
				(lState == RANGING_READY && rState == RANGING_READY) || (upMsg.rxAddr[5] == 255) /* In Sensorfly, 255 is the broadcast address */  )
			{
				upMsg.value = 0xff;
    522a:	8f ef       	ldi	r24, 0xFF	; 255
    522c:	90 e0       	ldi	r25, 0x00	; 0
    522e:	90 93 97 0e 	sts	0x0E97, r25
    5232:	80 93 96 0e 	sts	0x0E96, r24
				upMsg.prim = PD_DATA_INDICATION;
    5236:	83 e0       	ldi	r24, 0x03	; 3
    5238:	80 93 0d 0e 	sts	0x0E0D, r24
				SendMsgUp (&upMsg);
    523c:	8d e0       	ldi	r24, 0x0D	; 13
    523e:	9e e0       	ldi	r25, 0x0E	; 14
    5240:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    5244:	ca c0       	rjmp	.+404    	; 0x53da <PDCallback+0x342>
			}
			else if((lState == RANGING_READY) && (rState == RANGING_START || rState == RANGING_FAST_START))
    5246:	80 91 b1 0e 	lds	r24, 0x0EB1
    524a:	88 23       	and	r24, r24
    524c:	a9 f5       	brne	.+106    	; 0x52b8 <PDCallback+0x220>
    524e:	80 91 b2 0e 	lds	r24, 0x0EB2
    5252:	81 30       	cpi	r24, 0x01	; 1
    5254:	21 f0       	breq	.+8      	; 0x525e <PDCallback+0x1c6>
    5256:	80 91 b2 0e 	lds	r24, 0x0EB2
    525a:	84 30       	cpi	r24, 0x04	; 4
    525c:	69 f5       	brne	.+90     	; 0x52b8 <PDCallback+0x220>
			{
				memcpy(rDest, upMsg.addr, 6);
    525e:	84 eb       	ldi	r24, 0xB4	; 180
    5260:	9e e0       	ldi	r25, 0x0E	; 14
    5262:	2e e0       	ldi	r18, 0x0E	; 14
    5264:	3e e0       	ldi	r19, 0x0E	; 14
    5266:	b9 01       	movw	r22, r18
    5268:	46 e0       	ldi	r20, 0x06	; 6
    526a:	50 e0       	ldi	r21, 0x00	; 0
    526c:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>

				RangingCallback_Rx(upMsg.data, upMsg.len);
    5270:	20 91 14 0e 	lds	r18, 0x0E14
    5274:	85 e1       	ldi	r24, 0x15	; 21
    5276:	9e e0       	ldi	r25, 0x0E	; 14
    5278:	62 2f       	mov	r22, r18
    527a:	0e 94 68 38 	call	0x70d0	; 0x70d0 <RangingCallback_Rx>

				if(rState == RANGING_START)
    527e:	80 91 b2 0e 	lds	r24, 0x0EB2
    5282:	81 30       	cpi	r24, 0x01	; 1
    5284:	51 f4       	brne	.+20     	; 0x529a <PDCallback+0x202>
				{
					lState = RANGING_ANSWER1;
    5286:	82 e0       	ldi	r24, 0x02	; 2
    5288:	80 93 b1 0e 	sts	0x0EB1, r24
					/* send ranging packet */
					RangingMode(RANGING_ANSWER1, rDest);
    528c:	24 eb       	ldi	r18, 0xB4	; 180
    528e:	3e e0       	ldi	r19, 0x0E	; 14
    5290:	82 e0       	ldi	r24, 0x02	; 2
    5292:	b9 01       	movw	r22, r18
    5294:	0e 94 ae 39 	call	0x735c	; 0x735c <RangingMode>
    5298:	a0 c0       	rjmp	.+320    	; 0x53da <PDCallback+0x342>
				}else if (rState == RANGING_FAST_START)
    529a:	80 91 b2 0e 	lds	r24, 0x0EB2
    529e:	84 30       	cpi	r24, 0x04	; 4
    52a0:	09 f0       	breq	.+2      	; 0x52a4 <PDCallback+0x20c>
    52a2:	9b c0       	rjmp	.+310    	; 0x53da <PDCallback+0x342>
				{
					lState = RANGING_FAST_ANSWER1;
    52a4:	85 e0       	ldi	r24, 0x05	; 5
    52a6:	80 93 b1 0e 	sts	0x0EB1, r24
					/* send ranging packet */
					RangingMode(RANGING_FAST_ANSWER1, rDest);
    52aa:	24 eb       	ldi	r18, 0xB4	; 180
    52ac:	3e e0       	ldi	r19, 0x0E	; 14
    52ae:	85 e0       	ldi	r24, 0x05	; 5
    52b0:	b9 01       	movw	r22, r18
    52b2:	0e 94 ae 39 	call	0x735c	; 0x735c <RangingMode>
    52b6:	91 c0       	rjmp	.+290    	; 0x53da <PDCallback+0x342>
				}
			}
			else if((memcmp(rDest, upMsg.addr, 6) == 0) && lState == RANGING_ANSWER1 && rState == RANGING_ANSWER1)
    52b8:	84 eb       	ldi	r24, 0xB4	; 180
    52ba:	9e e0       	ldi	r25, 0x0E	; 14
    52bc:	2e e0       	ldi	r18, 0x0E	; 14
    52be:	3e e0       	ldi	r19, 0x0E	; 14
    52c0:	b9 01       	movw	r22, r18
    52c2:	46 e0       	ldi	r20, 0x06	; 6
    52c4:	50 e0       	ldi	r21, 0x00	; 0
    52c6:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    52ca:	00 97       	sbiw	r24, 0x00	; 0
    52cc:	99 f4       	brne	.+38     	; 0x52f4 <PDCallback+0x25c>
    52ce:	80 91 b1 0e 	lds	r24, 0x0EB1
    52d2:	82 30       	cpi	r24, 0x02	; 2
    52d4:	79 f4       	brne	.+30     	; 0x52f4 <PDCallback+0x25c>
    52d6:	80 91 b2 0e 	lds	r24, 0x0EB2
    52da:	82 30       	cpi	r24, 0x02	; 2
    52dc:	59 f4       	brne	.+22     	; 0x52f4 <PDCallback+0x25c>
			{
				/* received ranging data to RangingCallback_Rx
				 * (without protocol header stuff)
				 */
				RangingCallback_Rx(upMsg.data, upMsg.len);
    52de:	20 91 14 0e 	lds	r18, 0x0E14
    52e2:	85 e1       	ldi	r24, 0x15	; 21
    52e4:	9e e0       	ldi	r25, 0x0E	; 14
    52e6:	62 2f       	mov	r22, r18
    52e8:	0e 94 68 38 	call	0x70d0	; 0x70d0 <RangingCallback_Rx>
				lState = RANGING_ANSWER2;
    52ec:	83 e0       	ldi	r24, 0x03	; 3
    52ee:	80 93 b1 0e 	sts	0x0EB1, r24
    52f2:	73 c0       	rjmp	.+230    	; 0x53da <PDCallback+0x342>
			}
			else if((memcmp(rDest, upMsg.addr, 6) == 0) &&
    52f4:	84 eb       	ldi	r24, 0xB4	; 180
    52f6:	9e e0       	ldi	r25, 0x0E	; 14
    52f8:	2e e0       	ldi	r18, 0x0E	; 14
    52fa:	3e e0       	ldi	r19, 0x0E	; 14
    52fc:	b9 01       	movw	r22, r18
    52fe:	46 e0       	ldi	r20, 0x06	; 6
    5300:	50 e0       	ldi	r21, 0x00	; 0
    5302:	0e 94 ce 44 	call	0x899c	; 0x899c <memcmp>
    5306:	00 97       	sbiw	r24, 0x00	; 0
    5308:	09 f0       	breq	.+2      	; 0x530c <PDCallback+0x274>
    530a:	67 c0       	rjmp	.+206    	; 0x53da <PDCallback+0x342>
    530c:	80 91 b1 0e 	lds	r24, 0x0EB1
    5310:	83 30       	cpi	r24, 0x03	; 3
    5312:	21 f4       	brne	.+8      	; 0x531c <PDCallback+0x284>
    5314:	80 91 b2 0e 	lds	r24, 0x0EB2
    5318:	83 30       	cpi	r24, 0x03	; 3
    531a:	51 f0       	breq	.+20     	; 0x5330 <PDCallback+0x298>
    531c:	80 91 b1 0e 	lds	r24, 0x0EB1
    5320:	85 30       	cpi	r24, 0x05	; 5
    5322:	09 f0       	breq	.+2      	; 0x5326 <PDCallback+0x28e>
    5324:	5a c0       	rjmp	.+180    	; 0x53da <PDCallback+0x342>
    5326:	80 91 b2 0e 	lds	r24, 0x0EB2
    532a:	85 30       	cpi	r24, 0x05	; 5
    532c:	09 f0       	breq	.+2      	; 0x5330 <PDCallback+0x298>
    532e:	55 c0       	rjmp	.+170    	; 0x53da <PDCallback+0x342>
					((lState == RANGING_ANSWER2 && rState == RANGING_ANSWER2) ||
					(lState == RANGING_FAST_ANSWER1 && rState == RANGING_FAST_ANSWER1)))
			{
				/* ranging was successfull, stop timeout */
				NTRXStopBbTimer();
    5330:	0e 94 07 33 	call	0x660e	; 0x660e <NTRXStopBbTimer>

				/* received ranging data to RangingCallback_Rx
				 *(without protocol header stuff)
				 */
				RangingCallback_Rx(upMsg.data, upMsg.len);
    5334:	20 91 14 0e 	lds	r18, 0x0E14
    5338:	85 e1       	ldi	r24, 0x15	; 21
    533a:	9e e0       	ldi	r25, 0x0E	; 14
    533c:	62 2f       	mov	r22, r18
    533e:	0e 94 68 38 	call	0x70d0	; 0x70d0 <RangingCallback_Rx>

				/* calculate the distance */
				rangingPIB.distance = getDistance();
    5342:	0e 94 5e 3a 	call	0x74bc	; 0x74bc <getDistance>
    5346:	dc 01       	movw	r26, r24
    5348:	cb 01       	movw	r24, r22
    534a:	80 93 8e 0f 	sts	0x0F8E, r24
    534e:	90 93 8f 0f 	sts	0x0F8F, r25
    5352:	a0 93 90 0f 	sts	0x0F90, r26
    5356:	b0 93 91 0f 	sts	0x0F91, r27
				rangingPIB.rssi = getRSSI();
    535a:	0e 94 7e 3a 	call	0x74fc	; 0x74fc <getRSSI>
    535e:	80 93 8d 0f 	sts	0x0F8D, r24

				if (rangingPIB.distance < 0.0)
    5362:	80 91 8e 0f 	lds	r24, 0x0F8E
    5366:	90 91 8f 0f 	lds	r25, 0x0F8F
    536a:	a0 91 90 0f 	lds	r26, 0x0F90
    536e:	b0 91 91 0f 	lds	r27, 0x0F91
    5372:	bc 01       	movw	r22, r24
    5374:	cd 01       	movw	r24, r26
    5376:	20 e0       	ldi	r18, 0x00	; 0
    5378:	30 e0       	ldi	r19, 0x00	; 0
    537a:	40 e0       	ldi	r20, 0x00	; 0
    537c:	50 e0       	ldi	r21, 0x00	; 0
    537e:	0e 94 ba 41 	call	0x8374	; 0x8374 <__cmpsf2>
    5382:	88 23       	and	r24, r24
    5384:	1c f4       	brge	.+6      	; 0x538c <PDCallback+0x2f4>
					rangingPIB.error = STAT_RANGING_VALUE_ERROR;
    5386:	80 e8       	ldi	r24, 0x80	; 128
    5388:	80 93 8c 0f 	sts	0x0F8C, r24

				upMsg.value = 0xff;
    538c:	8f ef       	ldi	r24, 0xFF	; 255
    538e:	90 e0       	ldi	r25, 0x00	; 0
    5390:	90 93 97 0e 	sts	0x0E97, r25
    5394:	80 93 96 0e 	sts	0x0E96, r24
				memcpy(upMsg.data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    5398:	85 e1       	ldi	r24, 0x15	; 21
    539a:	9e e0       	ldi	r25, 0x0E	; 14
    539c:	2c e8       	ldi	r18, 0x8C	; 140
    539e:	3f e0       	ldi	r19, 0x0F	; 15
    53a0:	b9 01       	movw	r22, r18
    53a2:	46 e0       	ldi	r20, 0x06	; 6
    53a4:	50 e0       	ldi	r21, 0x00	; 0
    53a6:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				upMsg.len  = sizeof(RangingPIB);
    53aa:	86 e0       	ldi	r24, 0x06	; 6
    53ac:	80 93 14 0e 	sts	0x0E14, r24

				if (rState == RANGING_ANSWER2)
    53b0:	80 91 b2 0e 	lds	r24, 0x0EB2
    53b4:	83 30       	cpi	r24, 0x03	; 3
    53b6:	21 f4       	brne	.+8      	; 0x53c0 <PDCallback+0x328>
					upMsg.prim = PD_RANGING_INDICATION;
    53b8:	83 e1       	ldi	r24, 0x13	; 19
    53ba:	80 93 0d 0e 	sts	0x0E0D, r24
    53be:	07 c0       	rjmp	.+14     	; 0x53ce <PDCallback+0x336>
				else if (rState == RANGING_FAST_ANSWER1)
    53c0:	80 91 b2 0e 	lds	r24, 0x0EB2
    53c4:	85 30       	cpi	r24, 0x05	; 5
    53c6:	19 f4       	brne	.+6      	; 0x53ce <PDCallback+0x336>
					upMsg.prim = PD_RANGING_FAST_INDICATION;
    53c8:	88 e1       	ldi	r24, 0x18	; 24
    53ca:	80 93 0d 0e 	sts	0x0E0D, r24

				/* set ready for new ranging */
				lState = RANGING_READY;
    53ce:	10 92 b1 0e 	sts	0x0EB1, r1
				SendMsgUp (&upMsg);
    53d2:	8d e0       	ldi	r24, 0x0D	; 13
    53d4:	9e e0       	ldi	r25, 0x0E	; 14
    53d6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
			}
#			endif
        }
    }
}
    53da:	0f 90       	pop	r0
    53dc:	0f 90       	pop	r0
    53de:	0f 90       	pop	r0
    53e0:	cf 91       	pop	r28
    53e2:	df 91       	pop	r29
    53e4:	08 95       	ret

000053e6 <PHYPoll>:
 *
 */
/***************************************************************************/
void PHYPoll (void)
/***************************************************************************/
{
    53e6:	df 93       	push	r29
    53e8:	cf 93       	push	r28
    53ea:	00 d0       	rcall	.+0      	; 0x53ec <PHYPoll+0x6>
    53ec:	00 d0       	rcall	.+0      	; 0x53ee <PHYPoll+0x8>
    53ee:	0f 92       	push	r0
    53f0:	cd b7       	in	r28, 0x3d	; 61
    53f2:	de b7       	in	r29, 0x3e	; 62
    MyByte8T arqCount;
	MyMsgT *tMsg;

	if (tiPhyRxTimeout < hwclock() && tiPhyRxTimeout_once == FALSE)
    53f4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    53f8:	9b 01       	movw	r18, r22
    53fa:	ac 01       	movw	r20, r24
    53fc:	80 91 a9 0e 	lds	r24, 0x0EA9
    5400:	90 91 aa 0e 	lds	r25, 0x0EAA
    5404:	a0 91 ab 0e 	lds	r26, 0x0EAB
    5408:	b0 91 ac 0e 	lds	r27, 0x0EAC
    540c:	82 17       	cp	r24, r18
    540e:	93 07       	cpc	r25, r19
    5410:	a4 07       	cpc	r26, r20
    5412:	b5 07       	cpc	r27, r21
    5414:	88 f4       	brcc	.+34     	; 0x5438 <PHYPoll+0x52>
    5416:	80 91 ad 0e 	lds	r24, 0x0EAD
    541a:	88 23       	and	r24, r24
    541c:	69 f4       	brne	.+26     	; 0x5438 <PHYPoll+0x52>
	{
		tiPhyRxTimeout_once = TRUE;
    541e:	81 e0       	ldi	r24, 0x01	; 1
    5420:	80 93 ad 0e 	sts	0x0EAD, r24

		upMsg.prim = PD_STATUS_INDICATION;
    5424:	84 e0       	ldi	r24, 0x04	; 4
    5426:	80 93 0d 0e 	sts	0x0E0D, r24
		upMsg.attribute = PHY_RX_TIMEOUT;
    542a:	80 e8       	ldi	r24, 0x80	; 128
    542c:	80 93 98 0e 	sts	0x0E98, r24
		SendMsgUp (&upMsg);
    5430:	8d e0       	ldi	r24, 0x0D	; 13
    5432:	9e e0       	ldi	r25, 0x0E	; 14
    5434:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
	}

    if (trxPollMode == TRUE)
    5438:	80 91 db 06 	lds	r24, 0x06DB
    543c:	81 30       	cpi	r24, 0x01	; 1
    543e:	11 f4       	brne	.+4      	; 0x5444 <PHYPoll+0x5e>
    {
        NTRXInterrupt ();
    5440:	0e 94 ae 2c 	call	0x595c	; 0x595c <NTRXInterrupt>
    }

    UpdateLEDs ();
    5444:	0e 94 50 1d 	call	0x3aa0	; 0x3aa0 <UpdateLEDs>

    if (ntrxState == TxWAIT)
    5448:	80 91 05 0f 	lds	r24, 0x0F05
    544c:	82 30       	cpi	r24, 0x02	; 2
    544e:	09 f0       	breq	.+2      	; 0x5452 <PHYPoll+0x6c>
    5450:	cc c1       	rjmp	.+920    	; 0x57ea <PHYPoll+0x404>
		/*
		 * get number of transmissions needed to last message
		 * This information is used to determine if the last
		 * transmission was successfull or failed.
		 */
		NTRXSPIReadByte (NA_TxArqCnt_O, &arqCount);
    5452:	9e 01       	movw	r18, r28
    5454:	2d 5f       	subi	r18, 0xFD	; 253
    5456:	3f 4f       	sbci	r19, 0xFF	; 255
    5458:	8c e3       	ldi	r24, 0x3C	; 60
    545a:	b9 01       	movw	r22, r18
    545c:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>

		if ((arqCount > phyPIB.arqMax) && (ntrxState == TxWAIT))
    5460:	90 91 ce 0e 	lds	r25, 0x0ECE
    5464:	8b 81       	ldd	r24, Y+3	; 0x03
    5466:	98 17       	cp	r25, r24
    5468:	08 f0       	brcs	.+2      	; 0x546c <PHYPoll+0x86>
    546a:	aa c0       	rjmp	.+340    	; 0x55c0 <PHYPoll+0x1da>
    546c:	80 91 05 0f 	lds	r24, 0x0F05
    5470:	82 30       	cpi	r24, 0x02	; 2
    5472:	09 f0       	breq	.+2      	; 0x5476 <PHYPoll+0x90>
    5474:	a5 c0       	rjmp	.+330    	; 0x55c0 <PHYPoll+0x1da>
		{
#	   		ifdef CONFIG_NTRX_AUTO_RECALIB
			if(( ++rcwd > 3 ) && ( phyPIB.recalInterval != 0 ))
    5476:	80 91 fc 0d 	lds	r24, 0x0DFC
    547a:	90 91 fd 0d 	lds	r25, 0x0DFD
    547e:	01 96       	adiw	r24, 0x01	; 1
    5480:	90 93 fd 0d 	sts	0x0DFD, r25
    5484:	80 93 fc 0d 	sts	0x0DFC, r24
    5488:	80 91 fc 0d 	lds	r24, 0x0DFC
    548c:	90 91 fd 0d 	lds	r25, 0x0DFD
    5490:	84 30       	cpi	r24, 0x04	; 4
    5492:	91 05       	cpc	r25, r1
    5494:	0c f4       	brge	.+2      	; 0x5498 <PHYPoll+0xb2>
    5496:	8a c0       	rjmp	.+276    	; 0x55ac <PHYPoll+0x1c6>
    5498:	80 91 d3 0e 	lds	r24, 0x0ED3
    549c:	90 91 d4 0e 	lds	r25, 0x0ED4
    54a0:	a0 91 d5 0e 	lds	r26, 0x0ED5
    54a4:	b0 91 d6 0e 	lds	r27, 0x0ED6
    54a8:	00 97       	sbiw	r24, 0x00	; 0
    54aa:	a1 05       	cpc	r26, r1
    54ac:	b1 05       	cpc	r27, r1
    54ae:	09 f4       	brne	.+2      	; 0x54b2 <PHYPoll+0xcc>
    54b0:	7d c0       	rjmp	.+250    	; 0x55ac <PHYPoll+0x1c6>
			{
				/* INFO: If the TRX sends a packet, calibration failes!
				 * In this case rcwd is not reset, but tiRecal is.
				 */
				/* normal operation mode */
				if (phyPIB.testmode == 0)
    54b2:	80 91 dd 0e 	lds	r24, 0x0EDD
    54b6:	88 23       	and	r24, r24
    54b8:	c1 f5       	brne	.+112    	; 0x552a <PHYPoll+0x144>
				{
					if (NTRXAllCalibration ())
    54ba:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
    54be:	88 23       	and	r24, r24
    54c0:	09 f4       	brne	.+2      	; 0x54c4 <PHYPoll+0xde>
    54c2:	74 c0       	rjmp	.+232    	; 0x55ac <PHYPoll+0x1c6>
					{
						tiRecal = hwclock() + phyPIB.recalInterval;
    54c4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    54c8:	9b 01       	movw	r18, r22
    54ca:	ac 01       	movw	r20, r24
    54cc:	80 91 d3 0e 	lds	r24, 0x0ED3
    54d0:	90 91 d4 0e 	lds	r25, 0x0ED4
    54d4:	a0 91 d5 0e 	lds	r26, 0x0ED5
    54d8:	b0 91 d6 0e 	lds	r27, 0x0ED6
    54dc:	82 0f       	add	r24, r18
    54de:	93 1f       	adc	r25, r19
    54e0:	a4 1f       	adc	r26, r20
    54e2:	b5 1f       	adc	r27, r21
    54e4:	80 93 a5 0e 	sts	0x0EA5, r24
    54e8:	90 93 a6 0e 	sts	0x0EA6, r25
    54ec:	a0 93 a7 0e 	sts	0x0EA7, r26
    54f0:	b0 93 a8 0e 	sts	0x0EA8, r27
						rcwd = 0;
    54f4:	10 92 fd 0d 	sts	0x0DFD, r1
    54f8:	10 92 fc 0d 	sts	0x0DFC, r1
						TRIGGER_LED_CAL();
    54fc:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    5500:	dc 01       	movw	r26, r24
    5502:	cb 01       	movw	r24, r22
    5504:	c2 96       	adiw	r24, 0x32	; 50
    5506:	a1 1d       	adc	r26, r1
    5508:	b1 1d       	adc	r27, r1
    550a:	80 93 09 0e 	sts	0x0E09, r24
    550e:	90 93 0a 0e 	sts	0x0E0A, r25
    5512:	a0 93 0b 0e 	sts	0x0E0B, r26
    5516:	b0 93 0c 0e 	sts	0x0E0C, r27
    551a:	a8 e2       	ldi	r26, 0x28	; 40
    551c:	b0 e0       	ldi	r27, 0x00	; 0
    551e:	e8 e2       	ldi	r30, 0x28	; 40
    5520:	f0 e0       	ldi	r31, 0x00	; 0
    5522:	80 81       	ld	r24, Z
    5524:	8f 7b       	andi	r24, 0xBF	; 191
    5526:	8c 93       	st	X, r24
    5528:	41 c0       	rjmp	.+130    	; 0x55ac <PHYPoll+0x1c6>
 					 * in case of an enabled testmode recalibration is a bit trickier.
					 * We first have to disable the testmode, recalibrate and then
 					 * enable the testmode again.
					 */

					if (phyPIB.testmode == 1)
    552a:	80 91 dd 0e 	lds	r24, 0x0EDD
    552e:	81 30       	cpi	r24, 0x01	; 1
    5530:	f9 f4       	brne	.+62     	; 0x5570 <PHYPoll+0x18a>
					{
						NTRXSetTestChirpMode (FALSE);
    5532:	80 e0       	ldi	r24, 0x00	; 0
    5534:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
						NTRXAllCalibration ();
    5538:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
						TRIGGER_LED_CAL();
    553c:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    5540:	dc 01       	movw	r26, r24
    5542:	cb 01       	movw	r24, r22
    5544:	c2 96       	adiw	r24, 0x32	; 50
    5546:	a1 1d       	adc	r26, r1
    5548:	b1 1d       	adc	r27, r1
    554a:	80 93 09 0e 	sts	0x0E09, r24
    554e:	90 93 0a 0e 	sts	0x0E0A, r25
    5552:	a0 93 0b 0e 	sts	0x0E0B, r26
    5556:	b0 93 0c 0e 	sts	0x0E0C, r27
    555a:	a8 e2       	ldi	r26, 0x28	; 40
    555c:	b0 e0       	ldi	r27, 0x00	; 0
    555e:	e8 e2       	ldi	r30, 0x28	; 40
    5560:	f0 e0       	ldi	r31, 0x00	; 0
    5562:	80 81       	ld	r24, Z
    5564:	8f 7b       	andi	r24, 0xBF	; 191
    5566:	8c 93       	st	X, r24
						NTRXSetTestChirpMode (TRUE);
    5568:	81 e0       	ldi	r24, 0x01	; 1
    556a:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
    556e:	1e c0       	rjmp	.+60     	; 0x55ac <PHYPoll+0x1c6>
					}
					else
					{
						NTRXSetTestCarrierMode	(FALSE);
    5570:	80 e0       	ldi	r24, 0x00	; 0
    5572:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
						NTRXAllCalibration ();
    5576:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
						TRIGGER_LED_CAL();
    557a:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    557e:	dc 01       	movw	r26, r24
    5580:	cb 01       	movw	r24, r22
    5582:	c2 96       	adiw	r24, 0x32	; 50
    5584:	a1 1d       	adc	r26, r1
    5586:	b1 1d       	adc	r27, r1
    5588:	80 93 09 0e 	sts	0x0E09, r24
    558c:	90 93 0a 0e 	sts	0x0E0A, r25
    5590:	a0 93 0b 0e 	sts	0x0E0B, r26
    5594:	b0 93 0c 0e 	sts	0x0E0C, r27
    5598:	a8 e2       	ldi	r26, 0x28	; 40
    559a:	b0 e0       	ldi	r27, 0x00	; 0
    559c:	e8 e2       	ldi	r30, 0x28	; 40
    559e:	f0 e0       	ldi	r31, 0x00	; 0
    55a0:	80 81       	ld	r24, Z
    55a2:	8f 7b       	andi	r24, 0xBF	; 191
    55a4:	8c 93       	st	X, r24
						NTRXSetTestCarrierMode	(TRUE);
    55a6:	81 e0       	ldi	r24, 0x01	; 1
    55a8:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
				}
			}
#      		endif

			TRIGGER_LED_ERR();
			txSendMsg->status = PHY_NO_ACK;
    55ac:	80 91 fe 0d 	lds	r24, 0x0DFE
    55b0:	90 91 ff 0d 	lds	r25, 0x0DFF
    55b4:	fc 01       	movw	r30, r24
    55b6:	e8 57       	subi	r30, 0x78	; 120
    55b8:	ff 4f       	sbci	r31, 0xFF	; 255
    55ba:	8c e0       	ldi	r24, 0x0C	; 12
    55bc:	80 83       	st	Z, r24
    55be:	09 c0       	rjmp	.+18     	; 0x55d2 <PHYPoll+0x1ec>
		}
		else
		{
			txSendMsg->status = PHY_SUCCESS;
    55c0:	80 91 fe 0d 	lds	r24, 0x0DFE
    55c4:	90 91 ff 0d 	lds	r25, 0x0DFF
    55c8:	fc 01       	movw	r30, r24
    55ca:	e8 57       	subi	r30, 0x78	; 120
    55cc:	ff 4f       	sbci	r31, 0xFF	; 255
    55ce:	87 e0       	ldi	r24, 0x07	; 7
    55d0:	80 83       	st	Z, r24
		}

		txIrq &= ~(0x01 << NA_TxEnd_B);
    55d2:	80 91 ae 0e 	lds	r24, 0x0EAE
    55d6:	8b 7f       	andi	r24, 0xFB	; 251
    55d8:	80 93 ae 0e 	sts	0x0EAE, r24
		ntrxState = TxIDLE;
    55dc:	10 92 05 0f 	sts	0x0F05, r1
		txSendMsg->value = arqCount;
    55e0:	20 91 fe 0d 	lds	r18, 0x0DFE
    55e4:	30 91 ff 0d 	lds	r19, 0x0DFF
    55e8:	8b 81       	ldd	r24, Y+3	; 0x03
    55ea:	88 2f       	mov	r24, r24
    55ec:	90 e0       	ldi	r25, 0x00	; 0
    55ee:	f9 01       	movw	r30, r18
    55f0:	e7 57       	subi	r30, 0x77	; 119
    55f2:	ff 4f       	sbci	r31, 0xFF	; 255
    55f4:	91 83       	std	Z+1, r25	; 0x01
    55f6:	80 83       	st	Z, r24

		switch (txSendMsg->prim)
    55f8:	e0 91 fe 0d 	lds	r30, 0x0DFE
    55fc:	f0 91 ff 0d 	lds	r31, 0x0DFF
    5600:	80 81       	ld	r24, Z
    5602:	28 2f       	mov	r18, r24
    5604:	30 e0       	ldi	r19, 0x00	; 0
    5606:	3d 83       	std	Y+5, r19	; 0x05
    5608:	2c 83       	std	Y+4, r18	; 0x04
    560a:	8c 81       	ldd	r24, Y+4	; 0x04
    560c:	9d 81       	ldd	r25, Y+5	; 0x05
    560e:	81 31       	cpi	r24, 0x11	; 17
    5610:	91 05       	cpc	r25, r1
    5612:	09 f4       	brne	.+2      	; 0x5616 <PHYPoll+0x230>
    5614:	cf c0       	rjmp	.+414    	; 0x57b4 <PHYPoll+0x3ce>
    5616:	2c 81       	ldd	r18, Y+4	; 0x04
    5618:	3d 81       	ldd	r19, Y+5	; 0x05
    561a:	22 31       	cpi	r18, 0x12	; 18
    561c:	31 05       	cpc	r19, r1
    561e:	64 f4       	brge	.+24     	; 0x5638 <PHYPoll+0x252>
    5620:	8c 81       	ldd	r24, Y+4	; 0x04
    5622:	9d 81       	ldd	r25, Y+5	; 0x05
    5624:	8f 30       	cpi	r24, 0x0F	; 15
    5626:	91 05       	cpc	r25, r1
    5628:	a1 f0       	breq	.+40     	; 0x5652 <PHYPoll+0x26c>
    562a:	2c 81       	ldd	r18, Y+4	; 0x04
    562c:	3d 81       	ldd	r19, Y+5	; 0x05
    562e:	20 31       	cpi	r18, 0x10	; 16
    5630:	31 05       	cpc	r19, r1
    5632:	09 f4       	brne	.+2      	; 0x5636 <PHYPoll+0x250>
    5634:	9d c0       	rjmp	.+314    	; 0x5770 <PHYPoll+0x38a>
    5636:	c5 c0       	rjmp	.+394    	; 0x57c2 <PHYPoll+0x3dc>
    5638:	8c 81       	ldd	r24, Y+4	; 0x04
    563a:	9d 81       	ldd	r25, Y+5	; 0x05
    563c:	85 31       	cpi	r24, 0x15	; 21
    563e:	91 05       	cpc	r25, r1
    5640:	09 f4       	brne	.+2      	; 0x5644 <PHYPoll+0x25e>
    5642:	4e c0       	rjmp	.+156    	; 0x56e0 <PHYPoll+0x2fa>
    5644:	2c 81       	ldd	r18, Y+4	; 0x04
    5646:	3d 81       	ldd	r19, Y+5	; 0x05
    5648:	26 31       	cpi	r18, 0x16	; 22
    564a:	31 05       	cpc	r19, r1
    564c:	09 f4       	brne	.+2      	; 0x5650 <PHYPoll+0x26a>
    564e:	b2 c0       	rjmp	.+356    	; 0x57b4 <PHYPoll+0x3ce>
    5650:	b8 c0       	rjmp	.+368    	; 0x57c2 <PHYPoll+0x3dc>
		{
			case PD_RANGING_REQUEST_EXECUTE:
				txSendMsg->prim = PD_RANGING_CONFIRM;
    5652:	e0 91 fe 0d 	lds	r30, 0x0DFE
    5656:	f0 91 ff 0d 	lds	r31, 0x0DFF
    565a:	82 e1       	ldi	r24, 0x12	; 18
    565c:	80 83       	st	Z, r24

				bbState = BB_STATE_NORMAL_PHASE1;
    565e:	10 92 b3 0e 	sts	0x0EB3, r1

				if (txSendMsg->status == PHY_SUCCESS)
    5662:	80 91 fe 0d 	lds	r24, 0x0DFE
    5666:	90 91 ff 0d 	lds	r25, 0x0DFF
    566a:	fc 01       	movw	r30, r24
    566c:	e8 57       	subi	r30, 0x78	; 120
    566e:	ff 4f       	sbci	r31, 0xFF	; 255
    5670:	80 81       	ld	r24, Z
    5672:	87 30       	cpi	r24, 0x07	; 7
    5674:	69 f4       	brne	.+26     	; 0x5690 <PHYPoll+0x2aa>
				{
					RangingCallback_Ack(arqCount);
    5676:	8b 81       	ldd	r24, Y+3	; 0x03
    5678:	0e 94 3d 39 	call	0x727a	; 0x727a <RangingCallback_Ack>
					lState = RANGING_ANSWER1;
    567c:	82 e0       	ldi	r24, 0x02	; 2
    567e:	80 93 b1 0e 	sts	0x0EB1, r24
					NTRXStartBbTimer(modeSet.rangingTimeout);
    5682:	80 91 ff 0e 	lds	r24, 0x0EFF
    5686:	90 91 00 0f 	lds	r25, 0x0F00
    568a:	0e 94 f3 32 	call	0x65e6	; 0x65e6 <NTRXStartBbTimer>
    568e:	07 c0       	rjmp	.+14     	; 0x569e <PHYPoll+0x2b8>
				}
				else
				{
					rangingPIB.error |= STAT_NO_REMOTE_STATION;
    5690:	80 91 8c 0f 	lds	r24, 0x0F8C
    5694:	82 60       	ori	r24, 0x02	; 2
    5696:	80 93 8c 0f 	sts	0x0F8C, r24
					lState = RANGING_READY;
    569a:	10 92 b1 0e 	sts	0x0EB1, r1
				}

				memcpy(txSendMsg->data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    569e:	80 91 fe 0d 	lds	r24, 0x0DFE
    56a2:	90 91 ff 0d 	lds	r25, 0x0DFF
    56a6:	08 96       	adiw	r24, 0x08	; 8
    56a8:	2c e8       	ldi	r18, 0x8C	; 140
    56aa:	3f e0       	ldi	r19, 0x0F	; 15
    56ac:	b9 01       	movw	r22, r18
    56ae:	46 e0       	ldi	r20, 0x06	; 6
    56b0:	50 e0       	ldi	r21, 0x00	; 0
    56b2:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				txSendMsg->len = sizeof(RangingPIB);
    56b6:	e0 91 fe 0d 	lds	r30, 0x0DFE
    56ba:	f0 91 ff 0d 	lds	r31, 0x0DFF
    56be:	86 e0       	ldi	r24, 0x06	; 6
    56c0:	87 83       	std	Z+7, r24	; 0x07

				tMsg = txSendMsg;
    56c2:	80 91 fe 0d 	lds	r24, 0x0DFE
    56c6:	90 91 ff 0d 	lds	r25, 0x0DFF
    56ca:	9a 83       	std	Y+2, r25	; 0x02
    56cc:	89 83       	std	Y+1, r24	; 0x01
				txSendMsg = NULL;
    56ce:	10 92 ff 0d 	sts	0x0DFF, r1
    56d2:	10 92 fe 0d 	sts	0x0DFE, r1
				SendMsgUp (tMsg);
    56d6:	89 81       	ldd	r24, Y+1	; 0x01
    56d8:	9a 81       	ldd	r25, Y+2	; 0x02
    56da:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    56de:	85 c0       	rjmp	.+266    	; 0x57ea <PHYPoll+0x404>
				break;
			case PD_RANGING_FAST_REQUEST_EXECUTE:
				txSendMsg->prim = PD_RANGING_FAST_CONFIRM;
    56e0:	e0 91 fe 0d 	lds	r30, 0x0DFE
    56e4:	f0 91 ff 0d 	lds	r31, 0x0DFF
    56e8:	87 e1       	ldi	r24, 0x17	; 23
    56ea:	80 83       	st	Z, r24

				bbState = BB_STATE_FAST_PHASE1;
    56ec:	82 e0       	ldi	r24, 0x02	; 2
    56ee:	80 93 b3 0e 	sts	0x0EB3, r24

				if (txSendMsg->status == PHY_SUCCESS)
    56f2:	80 91 fe 0d 	lds	r24, 0x0DFE
    56f6:	90 91 ff 0d 	lds	r25, 0x0DFF
    56fa:	fc 01       	movw	r30, r24
    56fc:	e8 57       	subi	r30, 0x78	; 120
    56fe:	ff 4f       	sbci	r31, 0xFF	; 255
    5700:	80 81       	ld	r24, Z
    5702:	87 30       	cpi	r24, 0x07	; 7
    5704:	69 f4       	brne	.+26     	; 0x5720 <PHYPoll+0x33a>
				{
					RangingCallback_Ack(arqCount);
    5706:	8b 81       	ldd	r24, Y+3	; 0x03
    5708:	0e 94 3d 39 	call	0x727a	; 0x727a <RangingCallback_Ack>
					lState = RANGING_FAST_ANSWER1;
    570c:	85 e0       	ldi	r24, 0x05	; 5
    570e:	80 93 b1 0e 	sts	0x0EB1, r24
					NTRXStartBbTimer(modeSet.rangingFastTimeout);
    5712:	80 91 01 0f 	lds	r24, 0x0F01
    5716:	90 91 02 0f 	lds	r25, 0x0F02
    571a:	0e 94 f3 32 	call	0x65e6	; 0x65e6 <NTRXStartBbTimer>
    571e:	07 c0       	rjmp	.+14     	; 0x572e <PHYPoll+0x348>
				}
				else
				{
					rangingPIB.error |= STAT_NO_REMOTE_STATION;
    5720:	80 91 8c 0f 	lds	r24, 0x0F8C
    5724:	82 60       	ori	r24, 0x02	; 2
    5726:	80 93 8c 0f 	sts	0x0F8C, r24
					lState = RANGING_READY;
    572a:	10 92 b1 0e 	sts	0x0EB1, r1
				}

				memcpy(txSendMsg->data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    572e:	80 91 fe 0d 	lds	r24, 0x0DFE
    5732:	90 91 ff 0d 	lds	r25, 0x0DFF
    5736:	08 96       	adiw	r24, 0x08	; 8
    5738:	2c e8       	ldi	r18, 0x8C	; 140
    573a:	3f e0       	ldi	r19, 0x0F	; 15
    573c:	b9 01       	movw	r22, r18
    573e:	46 e0       	ldi	r20, 0x06	; 6
    5740:	50 e0       	ldi	r21, 0x00	; 0
    5742:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				txSendMsg->len = sizeof(RangingPIB);
    5746:	e0 91 fe 0d 	lds	r30, 0x0DFE
    574a:	f0 91 ff 0d 	lds	r31, 0x0DFF
    574e:	86 e0       	ldi	r24, 0x06	; 6
    5750:	87 83       	std	Z+7, r24	; 0x07

				tMsg = txSendMsg;
    5752:	80 91 fe 0d 	lds	r24, 0x0DFE
    5756:	90 91 ff 0d 	lds	r25, 0x0DFF
    575a:	9a 83       	std	Y+2, r25	; 0x02
    575c:	89 83       	std	Y+1, r24	; 0x01
				txSendMsg = NULL;
    575e:	10 92 ff 0d 	sts	0x0DFF, r1
    5762:	10 92 fe 0d 	sts	0x0DFE, r1
				SendMsgUp (tMsg);
    5766:	89 81       	ldd	r24, Y+1	; 0x01
    5768:	9a 81       	ldd	r25, Y+2	; 0x02
    576a:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
    576e:	3d c0       	rjmp	.+122    	; 0x57ea <PHYPoll+0x404>
				break;
			case PD_RANGING_ANSWER1_EXECUTE:

				if(txSendMsg->status == PHY_SUCCESS)
    5770:	80 91 fe 0d 	lds	r24, 0x0DFE
    5774:	90 91 ff 0d 	lds	r25, 0x0DFF
    5778:	fc 01       	movw	r30, r24
    577a:	e8 57       	subi	r30, 0x78	; 120
    577c:	ff 4f       	sbci	r31, 0xFF	; 255
    577e:	80 81       	ld	r24, Z
    5780:	87 30       	cpi	r24, 0x07	; 7
    5782:	89 f4       	brne	.+34     	; 0x57a6 <PHYPoll+0x3c0>
				{
					RangingCallback_Ack(arqCount);
    5784:	8b 81       	ldd	r24, Y+3	; 0x03
    5786:	0e 94 3d 39 	call	0x727a	; 0x727a <RangingCallback_Ack>

					txSendMsg = NULL;
    578a:	10 92 ff 0d 	sts	0x0DFF, r1
    578e:	10 92 fe 0d 	sts	0x0DFE, r1

					lState = RANGING_ANSWER2;
    5792:	83 e0       	ldi	r24, 0x03	; 3
    5794:	80 93 b1 0e 	sts	0x0EB1, r24

					/* send ranging packet with TxEnd information
					 * from RangingMode before
					 */
					RangingMode(RANGING_ANSWER2, rDest);
    5798:	24 eb       	ldi	r18, 0xB4	; 180
    579a:	3e e0       	ldi	r19, 0x0E	; 14
    579c:	83 e0       	ldi	r24, 0x03	; 3
    579e:	b9 01       	movw	r22, r18
    57a0:	0e 94 ae 39 	call	0x735c	; 0x735c <RangingMode>
    57a4:	22 c0       	rjmp	.+68     	; 0x57ea <PHYPoll+0x404>
				}
				else
				{
					lState = RANGING_READY;
    57a6:	10 92 b1 0e 	sts	0x0EB1, r1
					txSendMsg = NULL;
    57aa:	10 92 ff 0d 	sts	0x0DFF, r1
    57ae:	10 92 fe 0d 	sts	0x0DFE, r1
    57b2:	1b c0       	rjmp	.+54     	; 0x57ea <PHYPoll+0x404>

				break;

			case PD_RANGING_FAST_ANSWER1_EXECUTE:
			case PD_RANGING_ANSWER2_EXECUTE:
				lState = RANGING_READY;
    57b4:	10 92 b1 0e 	sts	0x0EB1, r1

				txSendMsg = NULL;
    57b8:	10 92 ff 0d 	sts	0x0DFF, r1
    57bc:	10 92 fe 0d 	sts	0x0DFE, r1
    57c0:	14 c0       	rjmp	.+40     	; 0x57ea <PHYPoll+0x404>
				break;

			default:
				txSendMsg->prim = PD_DATA_CONFIRM;
    57c2:	e0 91 fe 0d 	lds	r30, 0x0DFE
    57c6:	f0 91 ff 0d 	lds	r31, 0x0DFF
    57ca:	82 e0       	ldi	r24, 0x02	; 2
    57cc:	80 83       	st	Z, r24

				tMsg = txSendMsg;
    57ce:	80 91 fe 0d 	lds	r24, 0x0DFE
    57d2:	90 91 ff 0d 	lds	r25, 0x0DFF
    57d6:	9a 83       	std	Y+2, r25	; 0x02
    57d8:	89 83       	std	Y+1, r24	; 0x01
				txSendMsg = NULL;
    57da:	10 92 ff 0d 	sts	0x0DFF, r1
    57de:	10 92 fe 0d 	sts	0x0DFE, r1
				SendMsgUp (tMsg);
    57e2:	89 81       	ldd	r24, Y+1	; 0x01
    57e4:	9a 81       	ldd	r25, Y+2	; 0x02
    57e6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>
		}

    }

    /* check if nanoNET TRX chip has received valid data */
    if (ntrxState == TxIDLE)
    57ea:	80 91 05 0f 	lds	r24, 0x0F05
    57ee:	88 23       	and	r24, r24
    57f0:	51 f4       	brne	.+20     	; 0x5806 <PHYPoll+0x420>
    {
        if ((rxIrq & (0x01 << NA_RxEnd_B)) != 0 )
    57f2:	80 91 af 0e 	lds	r24, 0x0EAF
    57f6:	88 2f       	mov	r24, r24
    57f8:	90 e0       	ldi	r25, 0x00	; 0
    57fa:	84 70       	andi	r24, 0x04	; 4
    57fc:	90 70       	andi	r25, 0x00	; 0
    57fe:	00 97       	sbiw	r24, 0x00	; 0
    5800:	11 f0       	breq	.+4      	; 0x5806 <PHYPoll+0x420>
        {
            PDCallback ();
    5802:	0e 94 4c 28 	call	0x5098	; 0x5098 <PDCallback>
        }
    }

#   ifdef CONFIG_NTRX_AUTO_RECALIB
    if (phyPIB.recalInterval != 0)
    5806:	80 91 d3 0e 	lds	r24, 0x0ED3
    580a:	90 91 d4 0e 	lds	r25, 0x0ED4
    580e:	a0 91 d5 0e 	lds	r26, 0x0ED5
    5812:	b0 91 d6 0e 	lds	r27, 0x0ED6
    5816:	00 97       	sbiw	r24, 0x00	; 0
    5818:	a1 05       	cpc	r26, r1
    581a:	b1 05       	cpc	r27, r1
    581c:	09 f4       	brne	.+2      	; 0x5820 <PHYPoll+0x43a>
    581e:	96 c0       	rjmp	.+300    	; 0x594c <PHYPoll+0x566>
    {
        if ((rcwd > 3) || (tiRecal < hwclock()))
    5820:	80 91 fc 0d 	lds	r24, 0x0DFC
    5824:	90 91 fd 0d 	lds	r25, 0x0DFD
    5828:	84 30       	cpi	r24, 0x04	; 4
    582a:	91 05       	cpc	r25, r1
    582c:	94 f4       	brge	.+36     	; 0x5852 <PHYPoll+0x46c>
    582e:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    5832:	9b 01       	movw	r18, r22
    5834:	ac 01       	movw	r20, r24
    5836:	80 91 a5 0e 	lds	r24, 0x0EA5
    583a:	90 91 a6 0e 	lds	r25, 0x0EA6
    583e:	a0 91 a7 0e 	lds	r26, 0x0EA7
    5842:	b0 91 a8 0e 	lds	r27, 0x0EA8
    5846:	82 17       	cp	r24, r18
    5848:	93 07       	cpc	r25, r19
    584a:	a4 07       	cpc	r26, r20
    584c:	b5 07       	cpc	r27, r21
    584e:	08 f0       	brcs	.+2      	; 0x5852 <PHYPoll+0x46c>
    5850:	7d c0       	rjmp	.+250    	; 0x594c <PHYPoll+0x566>
        {
			/* INFO: If the TRX sends a packet, calibration failes!
			 * In this case rcwd is not reset, but tiRecal is. */
			if (phyPIB.testmode == 0)
    5852:	80 91 dd 0e 	lds	r24, 0x0EDD
    5856:	88 23       	and	r24, r24
    5858:	c1 f5       	brne	.+112    	; 0x58ca <PHYPoll+0x4e4>
			{
				if (NTRXAllCalibration ())
    585a:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
    585e:	88 23       	and	r24, r24
    5860:	09 f4       	brne	.+2      	; 0x5864 <PHYPoll+0x47e>
    5862:	74 c0       	rjmp	.+232    	; 0x594c <PHYPoll+0x566>
				{
		            tiRecal = hwclock() + phyPIB.recalInterval;
    5864:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    5868:	9b 01       	movw	r18, r22
    586a:	ac 01       	movw	r20, r24
    586c:	80 91 d3 0e 	lds	r24, 0x0ED3
    5870:	90 91 d4 0e 	lds	r25, 0x0ED4
    5874:	a0 91 d5 0e 	lds	r26, 0x0ED5
    5878:	b0 91 d6 0e 	lds	r27, 0x0ED6
    587c:	82 0f       	add	r24, r18
    587e:	93 1f       	adc	r25, r19
    5880:	a4 1f       	adc	r26, r20
    5882:	b5 1f       	adc	r27, r21
    5884:	80 93 a5 0e 	sts	0x0EA5, r24
    5888:	90 93 a6 0e 	sts	0x0EA6, r25
    588c:	a0 93 a7 0e 	sts	0x0EA7, r26
    5890:	b0 93 a8 0e 	sts	0x0EA8, r27
					rcwd = 0;
    5894:	10 92 fd 0d 	sts	0x0DFD, r1
    5898:	10 92 fc 0d 	sts	0x0DFC, r1
					TRIGGER_LED_CAL();
    589c:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    58a0:	dc 01       	movw	r26, r24
    58a2:	cb 01       	movw	r24, r22
    58a4:	c2 96       	adiw	r24, 0x32	; 50
    58a6:	a1 1d       	adc	r26, r1
    58a8:	b1 1d       	adc	r27, r1
    58aa:	80 93 09 0e 	sts	0x0E09, r24
    58ae:	90 93 0a 0e 	sts	0x0E0A, r25
    58b2:	a0 93 0b 0e 	sts	0x0E0B, r26
    58b6:	b0 93 0c 0e 	sts	0x0E0C, r27
    58ba:	a8 e2       	ldi	r26, 0x28	; 40
    58bc:	b0 e0       	ldi	r27, 0x00	; 0
    58be:	e8 e2       	ldi	r30, 0x28	; 40
    58c0:	f0 e0       	ldi	r31, 0x00	; 0
    58c2:	80 81       	ld	r24, Z
    58c4:	8f 7b       	andi	r24, 0xBF	; 191
    58c6:	8c 93       	st	X, r24
    58c8:	41 c0       	rjmp	.+130    	; 0x594c <PHYPoll+0x566>
				/*
					* in case of an enabled testmode recalibration is a bit trickier.
					* We first have to disable the testmode, recalibrate and then
					* enable the testmode again.
					*/
				if (phyPIB.testmode == 1)
    58ca:	80 91 dd 0e 	lds	r24, 0x0EDD
    58ce:	81 30       	cpi	r24, 0x01	; 1
    58d0:	f9 f4       	brne	.+62     	; 0x5910 <PHYPoll+0x52a>
				{
					NTRXSetTestChirpMode (FALSE);
    58d2:	80 e0       	ldi	r24, 0x00	; 0
    58d4:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
					NTRXAllCalibration ();
    58d8:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
					TRIGGER_LED_CAL();
    58dc:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    58e0:	dc 01       	movw	r26, r24
    58e2:	cb 01       	movw	r24, r22
    58e4:	c2 96       	adiw	r24, 0x32	; 50
    58e6:	a1 1d       	adc	r26, r1
    58e8:	b1 1d       	adc	r27, r1
    58ea:	80 93 09 0e 	sts	0x0E09, r24
    58ee:	90 93 0a 0e 	sts	0x0E0A, r25
    58f2:	a0 93 0b 0e 	sts	0x0E0B, r26
    58f6:	b0 93 0c 0e 	sts	0x0E0C, r27
    58fa:	a8 e2       	ldi	r26, 0x28	; 40
    58fc:	b0 e0       	ldi	r27, 0x00	; 0
    58fe:	e8 e2       	ldi	r30, 0x28	; 40
    5900:	f0 e0       	ldi	r31, 0x00	; 0
    5902:	80 81       	ld	r24, Z
    5904:	8f 7b       	andi	r24, 0xBF	; 191
    5906:	8c 93       	st	X, r24
					NTRXSetTestChirpMode (TRUE);
    5908:	81 e0       	ldi	r24, 0x01	; 1
    590a:	0e 94 16 33 	call	0x662c	; 0x662c <NTRXSetTestChirpMode>
    590e:	1e c0       	rjmp	.+60     	; 0x594c <PHYPoll+0x566>
				}
				else
				{
					NTRXSetTestCarrierMode	(FALSE);
    5910:	80 e0       	ldi	r24, 0x00	; 0
    5912:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
					NTRXAllCalibration ();
    5916:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
					TRIGGER_LED_CAL();
    591a:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    591e:	dc 01       	movw	r26, r24
    5920:	cb 01       	movw	r24, r22
    5922:	c2 96       	adiw	r24, 0x32	; 50
    5924:	a1 1d       	adc	r26, r1
    5926:	b1 1d       	adc	r27, r1
    5928:	80 93 09 0e 	sts	0x0E09, r24
    592c:	90 93 0a 0e 	sts	0x0E0A, r25
    5930:	a0 93 0b 0e 	sts	0x0E0B, r26
    5934:	b0 93 0c 0e 	sts	0x0E0C, r27
    5938:	a8 e2       	ldi	r26, 0x28	; 40
    593a:	b0 e0       	ldi	r27, 0x00	; 0
    593c:	e8 e2       	ldi	r30, 0x28	; 40
    593e:	f0 e0       	ldi	r31, 0x00	; 0
    5940:	80 81       	ld	r24, Z
    5942:	8f 7b       	andi	r24, 0xBF	; 191
    5944:	8c 93       	st	X, r24
					NTRXSetTestCarrierMode	(TRUE);
    5946:	81 e0       	ldi	r24, 0x01	; 1
    5948:	0e 94 a8 33 	call	0x6750	; 0x6750 <NTRXSetTestCarrierMode>
				}
			}
        }
    }
#   endif /* CONFIG_NTRX_AUTO_RECALIB */
}
    594c:	0f 90       	pop	r0
    594e:	0f 90       	pop	r0
    5950:	0f 90       	pop	r0
    5952:	0f 90       	pop	r0
    5954:	0f 90       	pop	r0
    5956:	cf 91       	pop	r28
    5958:	df 91       	pop	r29
    595a:	08 95       	ret

0000595c <NTRXInterrupt>:
 *
 */
/**************************************************************************/
void NTRXInterrupt (void)
/**************************************************************************/
{
    595c:	df 93       	push	r29
    595e:	cf 93       	push	r28
    5960:	00 d0       	rcall	.+0      	; 0x5962 <NTRXInterrupt+0x6>
    5962:	cd b7       	in	r28, 0x3d	; 61
    5964:	de b7       	in	r29, 0x3e	; 62
	/* we have received an interrupt and neede to find out what caused it */
	NTRXSPIRead (NA_TxIntsRawStat_O, ntrxIrqStatus, 2);
    5966:	23 e0       	ldi	r18, 0x03	; 3
    5968:	3f e0       	ldi	r19, 0x0F	; 15
    596a:	80 e1       	ldi	r24, 0x10	; 16
    596c:	b9 01       	movw	r22, r18
    596e:	42 e0       	ldi	r20, 0x02	; 2
    5970:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
	/* check if it was the transmitter */
	if (txIrqStatus != 0)
    5974:	80 91 03 0f 	lds	r24, 0x0F03
    5978:	88 23       	and	r24, r24
    597a:	d1 f0       	breq	.+52     	; 0x59b0 <NTRXInterrupt+0x54>
	{
		/* clear interrupts */
		NTRXSPIWriteByte (NA_TxIntsReset_O, txIrqStatus);
    597c:	90 91 03 0f 	lds	r25, 0x0F03
    5980:	80 e1       	ldi	r24, 0x10	; 16
    5982:	69 2f       	mov	r22, r25
    5984:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		txIrq |= txIrqStatus & (0x01 << NA_TxEnd_B);
    5988:	80 91 03 0f 	lds	r24, 0x0F03
    598c:	98 2f       	mov	r25, r24
    598e:	94 70       	andi	r25, 0x04	; 4
    5990:	80 91 ae 0e 	lds	r24, 0x0EAE
    5994:	89 2b       	or	r24, r25
    5996:	80 93 ae 0e 	sts	0x0EAE, r24
		if ((txIrq & (0x01 << NA_TxEnd_B)) != 0)
    599a:	80 91 ae 0e 	lds	r24, 0x0EAE
    599e:	88 2f       	mov	r24, r24
    59a0:	90 e0       	ldi	r25, 0x00	; 0
    59a2:	84 70       	andi	r24, 0x04	; 4
    59a4:	90 70       	andi	r25, 0x00	; 0
    59a6:	00 97       	sbiw	r24, 0x00	; 0
    59a8:	19 f0       	breq	.+6      	; 0x59b0 <NTRXInterrupt+0x54>
		{
			ntrxState = TxWAIT;
    59aa:	82 e0       	ldi	r24, 0x02	; 2
    59ac:	80 93 05 0f 	sts	0x0F05, r24
		}
	}
	/* check if it was the receiver */
	if (rxIrqStatus != 0)
    59b0:	80 91 04 0f 	lds	r24, 0x0F04
    59b4:	88 23       	and	r24, r24
    59b6:	79 f0       	breq	.+30     	; 0x59d6 <NTRXInterrupt+0x7a>
	{
		/* clear interrupts */
		NTRXSPIWriteByte (NA_RxIntsReset_O, rxIrqStatus);
    59b8:	90 91 04 0f 	lds	r25, 0x0F04
    59bc:	81 e1       	ldi	r24, 0x11	; 17
    59be:	69 2f       	mov	r22, r25
    59c0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		rxIrq |= rxIrqStatus & (0x01 << NA_RxEnd_B);
    59c4:	80 91 04 0f 	lds	r24, 0x0F04
    59c8:	98 2f       	mov	r25, r24
    59ca:	94 70       	andi	r25, 0x04	; 4
    59cc:	80 91 af 0e 	lds	r24, 0x0EAF
    59d0:	89 2b       	or	r24, r25
    59d2:	80 93 af 0e 	sts	0x0EAF, r24
	}

	//BASEBAND
	NTRXSPIRead(NA_BbTimerIrqStatus_O,&bbtimerStatus,1);
    59d6:	2a eb       	ldi	r18, 0xBA	; 186
    59d8:	3e e0       	ldi	r19, 0x0E	; 14
    59da:	8f e0       	ldi	r24, 0x0F	; 15
    59dc:	b9 01       	movw	r22, r18
    59de:	41 e0       	ldi	r20, 0x01	; 1
    59e0:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
	/* check if it was the basebandtimer */
	if ((bbtimerStatus & 0x40) != 0)
    59e4:	80 91 ba 0e 	lds	r24, 0x0EBA
    59e8:	88 2f       	mov	r24, r24
    59ea:	90 e0       	ldi	r25, 0x00	; 0
    59ec:	80 74       	andi	r24, 0x40	; 64
    59ee:	90 70       	andi	r25, 0x00	; 0
    59f0:	00 97       	sbiw	r24, 0x00	; 0
    59f2:	09 f4       	brne	.+2      	; 0x59f6 <NTRXInterrupt+0x9a>
    59f4:	61 c0       	rjmp	.+194    	; 0x5ab8 <NTRXInterrupt+0x15c>
	{
		NTRXStopBbTimer();
    59f6:	0e 94 07 33 	call	0x660e	; 0x660e <NTRXStopBbTimer>

		switch(bbState)
    59fa:	80 91 b3 0e 	lds	r24, 0x0EB3
    59fe:	28 2f       	mov	r18, r24
    5a00:	30 e0       	ldi	r19, 0x00	; 0
    5a02:	3a 83       	std	Y+2, r19	; 0x02
    5a04:	29 83       	std	Y+1, r18	; 0x01
    5a06:	89 81       	ldd	r24, Y+1	; 0x01
    5a08:	9a 81       	ldd	r25, Y+2	; 0x02
    5a0a:	00 97       	sbiw	r24, 0x00	; 0
    5a0c:	31 f0       	breq	.+12     	; 0x5a1a <NTRXInterrupt+0xbe>
    5a0e:	29 81       	ldd	r18, Y+1	; 0x01
    5a10:	3a 81       	ldd	r19, Y+2	; 0x02
    5a12:	22 30       	cpi	r18, 0x02	; 2
    5a14:	31 05       	cpc	r19, r1
    5a16:	59 f0       	breq	.+22     	; 0x5a2e <NTRXInterrupt+0xd2>
    5a18:	14 c0       	rjmp	.+40     	; 0x5a42 <NTRXInterrupt+0xe6>
		{
			case BB_STATE_NORMAL_PHASE1:
				bbState = BB_STATE_NORMAL_PHASE2;
    5a1a:	81 e0       	ldi	r24, 0x01	; 1
    5a1c:	80 93 b3 0e 	sts	0x0EB3, r24
				NTRXStartBbTimer(modeSet.rangingTimeout);
    5a20:	80 91 ff 0e 	lds	r24, 0x0EFF
    5a24:	90 91 00 0f 	lds	r25, 0x0F00
    5a28:	0e 94 f3 32 	call	0x65e6	; 0x65e6 <NTRXStartBbTimer>
    5a2c:	45 c0       	rjmp	.+138    	; 0x5ab8 <NTRXInterrupt+0x15c>
				break;
			case BB_STATE_FAST_PHASE1:
				bbState = BB_STATE_FAST_PHASE2;
    5a2e:	83 e0       	ldi	r24, 0x03	; 3
    5a30:	80 93 b3 0e 	sts	0x0EB3, r24
				NTRXStartBbTimer(modeSet.rangingFastTimeout);
    5a34:	80 91 01 0f 	lds	r24, 0x0F01
    5a38:	90 91 02 0f 	lds	r25, 0x0F02
    5a3c:	0e 94 f3 32 	call	0x65e6	; 0x65e6 <NTRXStartBbTimer>
    5a40:	3b c0       	rjmp	.+118    	; 0x5ab8 <NTRXInterrupt+0x15c>
				break;
			default:
				if(lState == RANGING_ANSWER1)
    5a42:	80 91 b1 0e 	lds	r24, 0x0EB1
    5a46:	82 30       	cpi	r24, 0x02	; 2
    5a48:	59 f4       	brne	.+22     	; 0x5a60 <NTRXInterrupt+0x104>
				{
					rangingPIB.error |= STAT_NO_ANSWER1;
    5a4a:	80 91 8c 0f 	lds	r24, 0x0F8C
    5a4e:	84 60       	ori	r24, 0x04	; 4
    5a50:	80 93 8c 0f 	sts	0x0F8C, r24
					rangingPIB.error |= STAT_NO_ANSWER2;
    5a54:	80 91 8c 0f 	lds	r24, 0x0F8C
    5a58:	88 60       	ori	r24, 0x08	; 8
    5a5a:	80 93 8c 0f 	sts	0x0F8C, r24
    5a5e:	09 c0       	rjmp	.+18     	; 0x5a72 <NTRXInterrupt+0x116>
				}else if(lState == RANGING_ANSWER2)
    5a60:	80 91 b1 0e 	lds	r24, 0x0EB1
    5a64:	83 30       	cpi	r24, 0x03	; 3
    5a66:	29 f4       	brne	.+10     	; 0x5a72 <NTRXInterrupt+0x116>
				{
					rangingPIB.error |= STAT_NO_ANSWER2;
    5a68:	80 91 8c 0f 	lds	r24, 0x0F8C
    5a6c:	88 60       	ori	r24, 0x08	; 8
    5a6e:	80 93 8c 0f 	sts	0x0F8C, r24
				}

				lState = RANGING_DONE;
    5a72:	87 e0       	ldi	r24, 0x07	; 7
    5a74:	80 93 b1 0e 	sts	0x0EB1, r24

				upMsg.value = 0xff;
    5a78:	8f ef       	ldi	r24, 0xFF	; 255
    5a7a:	90 e0       	ldi	r25, 0x00	; 0
    5a7c:	90 93 97 0e 	sts	0x0E97, r25
    5a80:	80 93 96 0e 	sts	0x0E96, r24
				memcpy(upMsg.data, (MyByte8T*) &rangingPIB, sizeof(RangingPIB));
    5a84:	85 e1       	ldi	r24, 0x15	; 21
    5a86:	9e e0       	ldi	r25, 0x0E	; 14
    5a88:	2c e8       	ldi	r18, 0x8C	; 140
    5a8a:	3f e0       	ldi	r19, 0x0F	; 15
    5a8c:	b9 01       	movw	r22, r18
    5a8e:	46 e0       	ldi	r20, 0x06	; 6
    5a90:	50 e0       	ldi	r21, 0x00	; 0
    5a92:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
				upMsg.len  = sizeof(RangingPIB);
    5a96:	86 e0       	ldi	r24, 0x06	; 6
    5a98:	80 93 14 0e 	sts	0x0E14, r24
				upMsg.prim = PD_RANGING_INDICATION;
    5a9c:	83 e1       	ldi	r24, 0x13	; 19
    5a9e:	80 93 0d 0e 	sts	0x0E0D, r24
				SendMsgUp (&upMsg);
    5aa2:	8d e0       	ldi	r24, 0x0D	; 13
    5aa4:	9e e0       	ldi	r25, 0x0E	; 14
    5aa6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <APLCallback>

				/* set ready for new ranging */
				lState = RANGING_READY;
    5aaa:	10 92 b1 0e 	sts	0x0EB1, r1

				bbIrq = 1;
    5aae:	81 e0       	ldi	r24, 0x01	; 1
    5ab0:	80 93 bb 0e 	sts	0x0EBB, r24
				bbtimerStatus = 0;
    5ab4:	10 92 ba 0e 	sts	0x0EBA, r1

				break;
		}
	}
}
    5ab8:	0f 90       	pop	r0
    5aba:	0f 90       	pop	r0
    5abc:	cf 91       	pop	r28
    5abe:	df 91       	pop	r29
    5ac0:	08 95       	ret

00005ac2 <NTRXInit>:
 *
 */
/**************************************************************************/
void NTRXInit(void)
/**************************************************************************/
{
    5ac2:	df 93       	push	r29
    5ac4:	cf 93       	push	r28
    5ac6:	cd b7       	in	r28, 0x3d	; 61
    5ac8:	de b7       	in	r29, 0x3e	; 62
	if (first == TRUE)
    5aca:	80 91 8d 07 	lds	r24, 0x078D
    5ace:	81 30       	cpi	r24, 0x01	; 1
    5ad0:	09 f0       	breq	.+2      	; 0x5ad4 <NTRXInit+0x12>
    5ad2:	4a c0       	rjmp	.+148    	; 0x5b68 <NTRXInit+0xa6>
	{
		first = FALSE;
    5ad4:	10 92 8d 07 	sts	0x078D, r1
		modeSet.rangingTimeout		=	RANGING_TIMEOUT_6MS;
		modeSet.rangingFastTimeout	=	RANGING_TIMEOUT_4MS;
#		endif /* CONFIG_DEFAULT_TRX_80MHZ_500NS */

#		ifdef CONFIG_DEFAULT_TRX_80MHZ_1000NS
		modeSet.bw = NA_80MHz;
    5ad8:	10 92 f1 0e 	sts	0x0EF1, r1
		modeSet.sd = NA_1us;
    5adc:	81 e0       	ldi	r24, 0x01	; 1
    5ade:	80 93 f2 0e 	sts	0x0EF2, r24
		modeSet.sr = NA_1M_S;
    5ae2:	81 e0       	ldi	r24, 0x01	; 1
    5ae4:	80 93 f3 0e 	sts	0x0EF3, r24
		modeSet.fdma= FALSE;
    5ae8:	10 92 f4 0e 	sts	0x0EF4, r1
		modeSet.fec = FALSE;
    5aec:	10 92 f6 0e 	sts	0x0EF6, r1
		modeSet.fixnmap=NA_FIX_MODE;
    5af0:	81 e0       	ldi	r24, 0x01	; 1
    5af2:	80 93 f5 0e 	sts	0x0EF5, r24
		modeSet.rangingConst_FECon=122.554497; /**/
    5af6:	87 ee       	ldi	r24, 0xE7	; 231
    5af8:	9b e1       	ldi	r25, 0x1B	; 27
    5afa:	a5 ef       	ldi	r26, 0xF5	; 245
    5afc:	b2 e4       	ldi	r27, 0x42	; 66
    5afe:	80 93 f7 0e 	sts	0x0EF7, r24
    5b02:	90 93 f8 0e 	sts	0x0EF8, r25
    5b06:	a0 93 f9 0e 	sts	0x0EF9, r26
    5b0a:	b0 93 fa 0e 	sts	0x0EFA, r27
		modeSet.rangingConst_FECoff=92.554000; /**/
    5b0e:	86 ea       	ldi	r24, 0xA6	; 166
    5b10:	9b e1       	ldi	r25, 0x1B	; 27
    5b12:	a9 eb       	ldi	r26, 0xB9	; 185
    5b14:	b2 e4       	ldi	r27, 0x42	; 66
    5b16:	80 93 fb 0e 	sts	0x0EFB, r24
    5b1a:	90 93 fc 0e 	sts	0x0EFC, r25
    5b1e:	a0 93 fd 0e 	sts	0x0EFD, r26
    5b22:	b0 93 fe 0e 	sts	0x0EFE, r27
		modeSet.rangingTimeout		=	RANGING_TIMEOUT_7MS;
    5b26:	8c ea       	ldi	r24, 0xAC	; 172
    5b28:	9d e0       	ldi	r25, 0x0D	; 13
    5b2a:	90 93 00 0f 	sts	0x0F00, r25
    5b2e:	80 93 ff 0e 	sts	0x0EFF, r24
		modeSet.rangingFastTimeout	=	RANGING_TIMEOUT_5MS;
    5b32:	84 ec       	ldi	r24, 0xC4	; 196
    5b34:	99 e0       	ldi	r25, 0x09	; 9
    5b36:	90 93 02 0f 	sts	0x0F02, r25
    5b3a:	80 93 01 0f 	sts	0x0F01, r24
		modeSet.rangingTimeout		=	RANGING_TIMEOUT_13MS;
		modeSet.rangingFastTimeout	=	RANGING_TIMEOUT_9MS;
#		endif /* CONFIG_DEFAULT_TRX_80MHZ_4000NS */

    	/* init SPI HW&SW */
    	InitSPI();
    5b3e:	0e 94 a9 1b 	call	0x3752	; 0x3752 <InitSPI>
    	NanoReset();
    5b42:	0e 94 90 1b 	call	0x3720	; 0x3720 <NanoReset>

	    /* initialize shadow registers */
    	NTRXInitShadowRegister ();
    5b46:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <NTRXInitShadowRegister>
		/* configure SPI output of chip MSB first / push pull */
		SetupSPI ();
    5b4a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <SetupSPI>

    	HWDelayus( 1 ); //!! Some short delay seems necessary here??
    5b4e:	81 e0       	ldi	r24, 0x01	; 1
    5b50:	90 e0       	ldi	r25, 0x00	; 0
    5b52:	0e 94 03 16 	call	0x2c06	; 0x2c06 <HWDelayus>
	    /* check connection and firmware version and revision */
    	if (!NTRXCheckVerRev())
    5b56:	0e 94 49 2f 	call	0x5e92	; 0x5e92 <NTRXCheckVerRev>
    5b5a:	88 23       	and	r24, r24
    5b5c:	49 f4       	brne	.+18     	; 0x5b70 <NTRXInit+0xae>
	    {
        	error_handler (506);
    5b5e:	8a ef       	ldi	r24, 0xFA	; 250
    5b60:	91 e0       	ldi	r25, 0x01	; 1
    5b62:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <error_handler>
    5b66:	04 c0       	rjmp	.+8      	; 0x5b70 <NTRXInit+0xae>
            }
	}
	else
	{
		/* configure SPI output of chip MSB first / push pull */
		SetupSPI ();
    5b68:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <SetupSPI>
	    /* initialize shadow registers */
    	NTRXInitShadowRegister ();
    5b6c:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <NTRXInitShadowRegister>
	}
	memcpy (phyPIB.syncword, TRX_SYNC_WORD, 8 );
    5b70:	8e ed       	ldi	r24, 0xDE	; 222
    5b72:	9e e0       	ldi	r25, 0x0E	; 14
    5b74:	2e e8       	ldi	r18, 0x8E	; 142
    5b76:	37 e0       	ldi	r19, 0x07	; 7
    5b78:	b9 01       	movw	r22, r18
    5b7a:	48 e0       	ldi	r20, 0x08	; 8
    5b7c:	50 e0       	ldi	r21, 0x00	; 0
    5b7e:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
    NTRXSetupTrxMode (modeSet.bw, modeSet.sd, modeSet.sr);
    5b82:	80 91 f1 0e 	lds	r24, 0x0EF1
    5b86:	90 91 f2 0e 	lds	r25, 0x0EF2
    5b8a:	20 91 f3 0e 	lds	r18, 0x0EF3
    5b8e:	69 2f       	mov	r22, r25
    5b90:	42 2f       	mov	r20, r18
    5b92:	0e 94 29 30 	call	0x6052	; 0x6052 <NTRXSetupTrxMode>

}
    5b96:	cf 91       	pop	r28
    5b98:	df 91       	pop	r29
    5b9a:	08 95       	ret

00005b9c <NTRXResetSettings>:
 *
 */
/**************************************************************************/
void NTRXResetSettings (void)
/**************************************************************************/
{
    5b9c:	df 93       	push	r29
    5b9e:	cf 93       	push	r28
    5ba0:	cd b7       	in	r28, 0x3d	; 61
    5ba2:	de b7       	in	r29, 0x3e	; 62
	lfdma 	= 0;
    5ba4:	10 92 ee 0e 	sts	0x0EEE, r1
	lsd 	= 0;
    5ba8:	10 92 ef 0e 	sts	0x0EEF, r1
	lsr 	= 0;
    5bac:	10 92 f0 0e 	sts	0x0EF0, r1
}
    5bb0:	cf 91       	pop	r28
    5bb2:	df 91       	pop	r29
    5bb4:	08 95       	ret

00005bb6 <NTRXInitShadowRegister>:
 *
 */
/**************************************************************************/
void NTRXInitShadowRegister (void)
/**************************************************************************/
{
    5bb6:	df 93       	push	r29
    5bb8:	cf 93       	push	r28
    5bba:	00 d0       	rcall	.+0      	; 0x5bbc <NTRXInitShadowRegister+0x6>
    5bbc:	00 d0       	rcall	.+0      	; 0x5bbe <NTRXInitShadowRegister+0x8>
    5bbe:	cd b7       	in	r28, 0x3d	; 61
    5bc0:	de b7       	in	r29, 0x3e	; 62
    MyByte8T i;

    /*
     * set shadow registers to the initial value of the nanoNET TRX chip
     */
    for (i = 0; i < SHADOWREGCOUNT; i++)
    5bc2:	1c 82       	std	Y+4, r1	; 0x04
    5bc4:	16 c0       	rjmp	.+44     	; 0x5bf2 <NTRXInitShadowRegister+0x3c>
    {
        ntrxShadowReg[i] = ReadRomByte(ntrxInitShadowReg[i]);
    5bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    5bc8:	28 2f       	mov	r18, r24
    5bca:	30 e0       	ldi	r19, 0x00	; 0
    5bcc:	8c 81       	ldd	r24, Y+4	; 0x04
    5bce:	88 2f       	mov	r24, r24
    5bd0:	90 e0       	ldi	r25, 0x00	; 0
    5bd2:	88 58       	subi	r24, 0x88	; 136
    5bd4:	9f 4f       	sbci	r25, 0xFF	; 255
    5bd6:	9b 83       	std	Y+3, r25	; 0x03
    5bd8:	8a 83       	std	Y+2, r24	; 0x02
    5bda:	ea 81       	ldd	r30, Y+2	; 0x02
    5bdc:	fb 81       	ldd	r31, Y+3	; 0x03
    5bde:	84 91       	lpm	r24, Z+
    5be0:	89 83       	std	Y+1, r24	; 0x01
    5be2:	89 81       	ldd	r24, Y+1	; 0x01
    5be4:	f9 01       	movw	r30, r18
    5be6:	ea 5f       	subi	r30, 0xFA	; 250
    5be8:	f0 4f       	sbci	r31, 0xF0	; 240
    5bea:	80 83       	st	Z, r24
    MyByte8T i;

    /*
     * set shadow registers to the initial value of the nanoNET TRX chip
     */
    for (i = 0; i < SHADOWREGCOUNT; i++)
    5bec:	8c 81       	ldd	r24, Y+4	; 0x04
    5bee:	8f 5f       	subi	r24, 0xFF	; 255
    5bf0:	8c 83       	std	Y+4, r24	; 0x04
    5bf2:	8c 81       	ldd	r24, Y+4	; 0x04
    5bf4:	88 23       	and	r24, r24
    5bf6:	3c f7       	brge	.-50     	; 0x5bc6 <NTRXInitShadowRegister+0x10>
    {
        ntrxShadowReg[i] = ReadRomByte(ntrxInitShadowReg[i]);
    }
}
    5bf8:	0f 90       	pop	r0
    5bfa:	0f 90       	pop	r0
    5bfc:	0f 90       	pop	r0
    5bfe:	0f 90       	pop	r0
    5c00:	cf 91       	pop	r28
    5c02:	df 91       	pop	r29
    5c04:	08 95       	ret

00005c06 <NTRXSetChannel>:
 *
 */
/**************************************************************************/
void NTRXSetChannel (MyByte8T value)
/**************************************************************************/
{
    5c06:	df 93       	push	r29
    5c08:	cf 93       	push	r28
    5c0a:	00 d0       	rcall	.+0      	; 0x5c0c <NTRXSetChannel+0x6>
    5c0c:	0f 92       	push	r0
    5c0e:	cd b7       	in	r28, 0x3d	; 61
    5c10:	de b7       	in	r29, 0x3e	; 62
    5c12:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * first check for a valid parameter. If the parameter is out of range
	 * do nothing.
	 */
	if (value > NTRX_MAX_CHANNEL_ID)
    5c14:	89 81       	ldd	r24, Y+1	; 0x01
    5c16:	81 31       	cpi	r24, 0x11	; 17
    5c18:	c8 f5       	brcc	.+114    	; 0x5c8c <NTRXSetChannel+0x86>
	 * predefined channels. When a new channel is selected, the value
	 * is copied form the list to the first slot. For fdma only the first
	 * channel is stored. The other 14 channels are calculated with the
	 * first channel as the basis.
	 */
	switch (value)
    5c1a:	89 81       	ldd	r24, Y+1	; 0x01
    5c1c:	28 2f       	mov	r18, r24
    5c1e:	30 e0       	ldi	r19, 0x00	; 0
    5c20:	3b 83       	std	Y+3, r19	; 0x03
    5c22:	2a 83       	std	Y+2, r18	; 0x02
    5c24:	8a 81       	ldd	r24, Y+2	; 0x02
    5c26:	9b 81       	ldd	r25, Y+3	; 0x03
    5c28:	8f 30       	cpi	r24, 0x0F	; 15
    5c2a:	91 05       	cpc	r25, r1
    5c2c:	91 f0       	breq	.+36     	; 0x5c52 <NTRXSetChannel+0x4c>
    5c2e:	2a 81       	ldd	r18, Y+2	; 0x02
    5c30:	3b 81       	ldd	r19, Y+3	; 0x03
    5c32:	20 31       	cpi	r18, 0x10	; 16
    5c34:	31 05       	cpc	r19, r1
    5c36:	b1 f0       	breq	.+44     	; 0x5c64 <NTRXSetChannel+0x5e>
    5c38:	8a 81       	ldd	r24, Y+2	; 0x02
    5c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c3c:	00 97       	sbiw	r24, 0x00	; 0
    5c3e:	d9 f4       	brne	.+54     	; 0x5c76 <NTRXSetChannel+0x70>
	{
		case 0:	loTarVal[0][0] = loTarVal[1][0];
    5c40:	80 91 98 07 	lds	r24, 0x0798
    5c44:	80 93 96 07 	sts	0x0796, r24
				loTarVal[0][1] = loTarVal[1][1];
    5c48:	80 91 99 07 	lds	r24, 0x0799
    5c4c:	80 93 97 07 	sts	0x0797, r24
    5c50:	1d c0       	rjmp	.+58     	; 0x5c8c <NTRXSetChannel+0x86>
				break;

		case 15:loTarVal[0][0] = loTarVal[3][0];
    5c52:	80 91 9c 07 	lds	r24, 0x079C
    5c56:	80 93 96 07 	sts	0x0796, r24
				loTarVal[0][1] = loTarVal[3][1];
    5c5a:	80 91 9d 07 	lds	r24, 0x079D
    5c5e:	80 93 97 07 	sts	0x0797, r24
    5c62:	14 c0       	rjmp	.+40     	; 0x5c8c <NTRXSetChannel+0x86>
				break;

		case 16:loTarVal[0][0] = loTarVal[4][0];
    5c64:	80 91 9e 07 	lds	r24, 0x079E
    5c68:	80 93 96 07 	sts	0x0796, r24
				loTarVal[0][1] = loTarVal[4][1];
    5c6c:	80 91 9f 07 	lds	r24, 0x079F
    5c70:	80 93 97 07 	sts	0x0797, r24
    5c74:	0b c0       	rjmp	.+22     	; 0x5c8c <NTRXSetChannel+0x86>
				break;

		default:loTarVal[0][0] = loTarVal[2][0];
    5c76:	80 91 9a 07 	lds	r24, 0x079A
    5c7a:	80 93 96 07 	sts	0x0796, r24
				loTarVal[0][1] = loTarVal[2][1] + value - 1;
    5c7e:	90 91 9b 07 	lds	r25, 0x079B
    5c82:	89 81       	ldd	r24, Y+1	; 0x01
    5c84:	89 0f       	add	r24, r25
    5c86:	81 50       	subi	r24, 0x01	; 1
    5c88:	80 93 97 07 	sts	0x0797, r24
				break;

	}
}
    5c8c:	0f 90       	pop	r0
    5c8e:	0f 90       	pop	r0
    5c90:	0f 90       	pop	r0
    5c92:	cf 91       	pop	r28
    5c94:	df 91       	pop	r29
    5c96:	08 95       	ret

00005c98 <NTRXSetIndexReg>:
 *
 */
/**************************************************************************/
void NTRXSetIndexReg (MyByte8T page)
/**************************************************************************/
{
    5c98:	df 93       	push	r29
    5c9a:	cf 93       	push	r28
    5c9c:	0f 92       	push	r0
    5c9e:	cd b7       	in	r28, 0x3d	; 61
    5ca0:	de b7       	in	r29, 0x3e	; 62
    5ca2:	89 83       	std	Y+1, r24	; 0x01
    if (page != ntrxShadowReg[NA_RamIndex_O])
    5ca4:	90 91 14 0f 	lds	r25, 0x0F14
    5ca8:	89 81       	ldd	r24, Y+1	; 0x01
    5caa:	98 17       	cp	r25, r24
    5cac:	39 f0       	breq	.+14     	; 0x5cbc <NTRXSetIndexReg+0x24>
    {
        ntrxShadowReg[NA_RamIndex_O] = page;
    5cae:	89 81       	ldd	r24, Y+1	; 0x01
    5cb0:	80 93 14 0f 	sts	0x0F14, r24
        NTRXSPIWriteByte (NA_RamIndex_O, page);
    5cb4:	8e e0       	ldi	r24, 0x0E	; 14
    5cb6:	69 81       	ldd	r22, Y+1	; 0x01
    5cb8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    }
}
    5cbc:	0f 90       	pop	r0
    5cbe:	cf 91       	pop	r28
    5cc0:	df 91       	pop	r29
    5cc2:	08 95       	ret

00005cc4 <NTRXSetRamIndex>:
 *
 */
/**************************************************************************/
void NTRXSetRamIndex (MyByte8T page)
/**************************************************************************/
{
    5cc4:	df 93       	push	r29
    5cc6:	cf 93       	push	r28
    5cc8:	0f 92       	push	r0
    5cca:	cd b7       	in	r28, 0x3d	; 61
    5ccc:	de b7       	in	r29, 0x3e	; 62
    5cce:	89 83       	std	Y+1, r24	; 0x01
    page &= 0x03;
    5cd0:	89 81       	ldd	r24, Y+1	; 0x01
    5cd2:	83 70       	andi	r24, 0x03	; 3
    5cd4:	89 83       	std	Y+1, r24	; 0x01
    if (page != (ntrxShadowReg[NA_RamIndex_O] & 0x03))
    5cd6:	89 81       	ldd	r24, Y+1	; 0x01
    5cd8:	28 2f       	mov	r18, r24
    5cda:	30 e0       	ldi	r19, 0x00	; 0
    5cdc:	80 91 14 0f 	lds	r24, 0x0F14
    5ce0:	88 2f       	mov	r24, r24
    5ce2:	90 e0       	ldi	r25, 0x00	; 0
    5ce4:	83 70       	andi	r24, 0x03	; 3
    5ce6:	90 70       	andi	r25, 0x00	; 0
    5ce8:	28 17       	cp	r18, r24
    5cea:	39 07       	cpc	r19, r25
    5cec:	91 f0       	breq	.+36     	; 0x5d12 <NTRXSetRamIndex+0x4e>
    {
        ntrxShadowReg[NA_RamIndex_O] &= 0xf0;
    5cee:	80 91 14 0f 	lds	r24, 0x0F14
    5cf2:	80 7f       	andi	r24, 0xF0	; 240
    5cf4:	80 93 14 0f 	sts	0x0F14, r24
        ntrxShadowReg[NA_RamIndex_O] |= page;
    5cf8:	90 91 14 0f 	lds	r25, 0x0F14
    5cfc:	89 81       	ldd	r24, Y+1	; 0x01
    5cfe:	89 2b       	or	r24, r25
    5d00:	80 93 14 0f 	sts	0x0F14, r24
        page = ntrxShadowReg[NA_RamIndex_O];
    5d04:	80 91 14 0f 	lds	r24, 0x0F14
    5d08:	89 83       	std	Y+1, r24	; 0x01
        NTRXSPIWriteByte (NA_RamIndex_O, page);
    5d0a:	8e e0       	ldi	r24, 0x0E	; 14
    5d0c:	69 81       	ldd	r22, Y+1	; 0x01
    5d0e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    }
}
    5d12:	0f 90       	pop	r0
    5d14:	cf 91       	pop	r28
    5d16:	df 91       	pop	r29
    5d18:	08 95       	ret

00005d1a <NTRXRxLoCalibration>:
 *
 */
/**************************************************************************/
void NTRXRxLoCalibration (void)
/**************************************************************************/
{
    5d1a:	df 93       	push	r29
    5d1c:	cf 93       	push	r28
    5d1e:	00 d0       	rcall	.+0      	; 0x5d20 <NTRXRxLoCalibration+0x6>
    5d20:	0f 92       	push	r0
    5d22:	cd b7       	in	r28, 0x3d	; 61
    5d24:	de b7       	in	r29, 0x3e	; 62
    MyByte8T data[3];

	NTRXSPIWriteByte (NA_EnableLO_O, (ntrxShadowReg[NA_EnableLO_O] | (1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B)));
    5d26:	80 91 48 0f 	lds	r24, 0x0F48
    5d2a:	98 2f       	mov	r25, r24
    5d2c:	93 60       	ori	r25, 0x03	; 3
    5d2e:	82 e4       	ldi	r24, 0x42	; 66
    5d30:	69 2f       	mov	r22, r25
    5d32:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	HWDelayms( 4 ); /* ms */
    5d36:	84 e0       	ldi	r24, 0x04	; 4
    5d38:	90 e0       	ldi	r25, 0x00	; 0
    5d3a:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
	NTRXSPIWriteByte (NA_UseLoRxCaps_O, (ntrxShadowReg[NA_UseLoRxCaps_O] | (1 << NA_UseLoRxCaps_B)));
    5d3e:	80 91 22 0f 	lds	r24, 0x0F22
    5d42:	98 2f       	mov	r25, r24
    5d44:	90 68       	ori	r25, 0x80	; 128
    5d46:	8c e1       	ldi	r24, 0x1C	; 28
    5d48:	69 2f       	mov	r22, r25
    5d4a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    data[0] = 0x03;
    5d4e:	83 e0       	ldi	r24, 0x03	; 3
    5d50:	89 83       	std	Y+1, r24	; 0x01
	NTRXSPIWriteByte (NA_LoIntsReset_O, data[0]);
    5d52:	99 81       	ldd	r25, Y+1	; 0x01
    5d54:	82 e1       	ldi	r24, 0x12	; 18
    5d56:	69 2f       	mov	r22, r25
    5d58:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    NTRXSPIWrite (NA_LoTargetValue_O, loTarVal[0], 2);
    5d5c:	26 e9       	ldi	r18, 0x96	; 150
    5d5e:	37 e0       	ldi	r19, 0x07	; 7
    5d60:	8d e1       	ldi	r24, 0x1D	; 29
    5d62:	b9 01       	movw	r22, r18
    5d64:	42 e0       	ldi	r20, 0x02	; 2
    5d66:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

    do
    {
        NTRXSPIReadByte (NA_LoIntsRawStat_O, &data[0]);
    5d6a:	82 e1       	ldi	r24, 0x12	; 18
    5d6c:	9e 01       	movw	r18, r28
    5d6e:	2f 5f       	subi	r18, 0xFF	; 255
    5d70:	3f 4f       	sbci	r19, 0xFF	; 255
    5d72:	b9 01       	movw	r22, r18
    5d74:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
    } while ((data[0] & (1 << NA_LoTuningReady_B)) != (1 << NA_LoTuningReady_B));
    5d78:	89 81       	ldd	r24, Y+1	; 0x01
    5d7a:	88 2f       	mov	r24, r24
    5d7c:	90 e0       	ldi	r25, 0x00	; 0
    5d7e:	82 70       	andi	r24, 0x02	; 2
    5d80:	90 70       	andi	r25, 0x00	; 0
    5d82:	00 97       	sbiw	r24, 0x00	; 0
    5d84:	91 f3       	breq	.-28     	; 0x5d6a <NTRXRxLoCalibration+0x50>

	/* Read out caps values if needed */
    //NTRXSPIRead (0x16, data, 3);
	NTRXSPIWriteByte (NA_UseLoRxCaps_O, ntrxShadowReg[NA_UseLoRxCaps_O]);
    5d86:	90 91 22 0f 	lds	r25, 0x0F22
    5d8a:	8c e1       	ldi	r24, 0x1C	; 28
    5d8c:	69 2f       	mov	r22, r25
    5d8e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    5d92:	90 91 48 0f 	lds	r25, 0x0F48
    5d96:	82 e4       	ldi	r24, 0x42	; 66
    5d98:	69 2f       	mov	r22, r25
    5d9a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    5d9e:	0f 90       	pop	r0
    5da0:	0f 90       	pop	r0
    5da2:	0f 90       	pop	r0
    5da4:	cf 91       	pop	r28
    5da6:	df 91       	pop	r29
    5da8:	08 95       	ret

00005daa <NTRXTxLoCalibration>:
 *
 */
/**************************************************************************/
void NTRXTxLoCalibration (void)
/**************************************************************************/
{
    5daa:	df 93       	push	r29
    5dac:	cf 93       	push	r28
    5dae:	00 d0       	rcall	.+0      	; 0x5db0 <NTRXTxLoCalibration+0x6>
    5db0:	0f 92       	push	r0
    5db2:	cd b7       	in	r28, 0x3d	; 61
    5db4:	de b7       	in	r29, 0x3e	; 62
    MyByte8T data[3];

	NTRXSPIWriteByte (NA_EnableLO_O, (ntrxShadowReg[NA_EnableLO_O] | (1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B)));
    5db6:	80 91 48 0f 	lds	r24, 0x0F48
    5dba:	98 2f       	mov	r25, r24
    5dbc:	93 60       	ori	r25, 0x03	; 3
    5dbe:	82 e4       	ldi	r24, 0x42	; 66
    5dc0:	69 2f       	mov	r22, r25
    5dc2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	HWDelayms( 4 ); /* ms */
    5dc6:	84 e0       	ldi	r24, 0x04	; 4
    5dc8:	90 e0       	ldi	r25, 0x00	; 0
    5dca:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
    data[0] = 0x03;
    5dce:	83 e0       	ldi	r24, 0x03	; 3
    5dd0:	89 83       	std	Y+1, r24	; 0x01
    NTRXSPIWriteByte (NA_LoIntsReset_O, data[0]);
    5dd2:	99 81       	ldd	r25, Y+1	; 0x01
    5dd4:	82 e1       	ldi	r24, 0x12	; 18
    5dd6:	69 2f       	mov	r22, r25
    5dd8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    NTRXSPIWrite (NA_LoTargetValue_O, loTarVal[0], 2);
    5ddc:	26 e9       	ldi	r18, 0x96	; 150
    5dde:	37 e0       	ldi	r19, 0x07	; 7
    5de0:	8d e1       	ldi	r24, 0x1D	; 29
    5de2:	b9 01       	movw	r22, r18
    5de4:	42 e0       	ldi	r20, 0x02	; 2
    5de6:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

    do
    {
        NTRXSPIReadByte (NA_LoIntsRawStat_O, &(data[0]));
    5dea:	82 e1       	ldi	r24, 0x12	; 18
    5dec:	9e 01       	movw	r18, r28
    5dee:	2f 5f       	subi	r18, 0xFF	; 255
    5df0:	3f 4f       	sbci	r19, 0xFF	; 255
    5df2:	b9 01       	movw	r22, r18
    5df4:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
    } while ((data[0] & (1 << NA_LoTuningReady_B)) != (1 << NA_LoTuningReady_B));
    5df8:	89 81       	ldd	r24, Y+1	; 0x01
    5dfa:	88 2f       	mov	r24, r24
    5dfc:	90 e0       	ldi	r25, 0x00	; 0
    5dfe:	82 70       	andi	r24, 0x02	; 2
    5e00:	90 70       	andi	r25, 0x00	; 0
    5e02:	00 97       	sbiw	r24, 0x00	; 0
    5e04:	91 f3       	breq	.-28     	; 0x5dea <NTRXTxLoCalibration+0x40>

	/* Read out caps values if needed */
    //NTRXSPIRead (0x16, data, 3);
	NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    5e06:	90 91 48 0f 	lds	r25, 0x0F48
    5e0a:	82 e4       	ldi	r24, 0x42	; 66
    5e0c:	69 2f       	mov	r22, r25
    5e0e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    5e12:	0f 90       	pop	r0
    5e14:	0f 90       	pop	r0
    5e16:	0f 90       	pop	r0
    5e18:	cf 91       	pop	r28
    5e1a:	df 91       	pop	r29
    5e1c:	08 95       	ret

00005e1e <NTRXAllCalibration>:
 *
 */
/**************************************************************************/
MyBoolT NTRXAllCalibration (void)
/**************************************************************************/
{
    5e1e:	df 93       	push	r29
    5e20:	cf 93       	push	r28
    5e22:	00 d0       	rcall	.+0      	; 0x5e24 <NTRXAllCalibration+0x6>
    5e24:	cd b7       	in	r28, 0x3d	; 61
    5e26:	de b7       	in	r29, 0x3e	; 62

	/*
	 * make sure the we are not currently transmitting. This would destroy
	 * the partialy send message.
	 */
	if (ntrxState == TxSEND) return FALSE;
    5e28:	80 91 05 0f 	lds	r24, 0x0F05
    5e2c:	81 30       	cpi	r24, 0x01	; 1
    5e2e:	11 f4       	brne	.+4      	; 0x5e34 <NTRXAllCalibration+0x16>
    5e30:	1a 82       	std	Y+2, r1	; 0x02
    5e32:	29 c0       	rjmp	.+82     	; 0x5e86 <NTRXAllCalibration+0x68>

  	/*
	 * enable fast tuning
	 */
	value = (1 << NA_LoEnableFastTuning_B) | (1 << NA_LoEnableLsbNeg_B) | (4 << NA_LoFastTuningLevel_LSB);
    5e34:	89 e1       	ldi	r24, 0x19	; 25
    5e36:	89 83       	std	Y+1, r24	; 0x01
    NTRXSPIWriteByte (NA_LoEnableFastTuning_O, value);
    5e38:	8c e1       	ldi	r24, 0x1C	; 28
    5e3a:	69 81       	ldd	r22, Y+1	; 0x01
    5e3c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    ntrxShadowReg[NA_LoEnableFastTuning_O] = value;
    5e40:	89 81       	ldd	r24, Y+1	; 0x01
    5e42:	80 93 22 0f 	sts	0x0F22, r24

	/*
	 * stop the receiver and clear the buffers
	 */
	NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B) | (0x03 << NA_RxBufferCmd_LSB));
    5e46:	80 91 5c 0f 	lds	r24, 0x0F5C
    5e4a:	98 2f       	mov	r25, r24
    5e4c:	9d 60       	ori	r25, 0x0D	; 13
    5e4e:	86 e5       	ldi	r24, 0x56	; 86
    5e50:	69 2f       	mov	r22, r25
    5e52:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	NTRXSPIWriteByte (NA_RxIntsReset_O, 0x7F);
    5e56:	81 e1       	ldi	r24, 0x11	; 17
    5e58:	6f e7       	ldi	r22, 0x7F	; 127
    5e5a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    rxIrqStatus = 0;
    5e5e:	10 92 04 0f 	sts	0x0F04, r1

	/*
	 * calibrate transmitter and receiver
	 */
    NTRXRxLoCalibration ();
    5e62:	0e 94 8d 2e 	call	0x5d1a	; 0x5d1a <NTRXRxLoCalibration>
    NTRXTxLoCalibration ();
    5e66:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <NTRXTxLoCalibration>

	/*
	 * start receiver if it was started before calibration
	 */
	if (phyPIB.rxState == PHY_RX_ON)
    5e6a:	80 91 bf 0e 	lds	r24, 0x0EBF
    5e6e:	86 30       	cpi	r24, 0x06	; 6
    5e70:	41 f4       	brne	.+16     	; 0x5e82 <NTRXAllCalibration+0x64>
	{
		NTRXSPIWriteByte (NA_RxCmdStart_O, ntrxShadowReg[NA_RxCmdStart_O] | (1 << NA_RxCmdStart_B));
    5e72:	80 91 5c 0f 	lds	r24, 0x0F5C
    5e76:	98 2f       	mov	r25, r24
    5e78:	92 60       	ori	r25, 0x02	; 2
    5e7a:	86 e5       	ldi	r24, 0x56	; 86
    5e7c:	69 2f       	mov	r22, r25
    5e7e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	}
//    ntrxCal = 0;

	return TRUE;
    5e82:	81 e0       	ldi	r24, 0x01	; 1
    5e84:	8a 83       	std	Y+2, r24	; 0x02
    5e86:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5e88:	0f 90       	pop	r0
    5e8a:	0f 90       	pop	r0
    5e8c:	cf 91       	pop	r28
    5e8e:	df 91       	pop	r29
    5e90:	08 95       	ret

00005e92 <NTRXCheckVerRev>:
 *
 */
/**************************************************************************/
MyBoolT NTRXCheckVerRev (void)
/**************************************************************************/
{
    5e92:	df 93       	push	r29
    5e94:	cf 93       	push	r28
    5e96:	00 d0       	rcall	.+0      	; 0x5e98 <NTRXCheckVerRev+0x6>
    5e98:	0f 92       	push	r0
    5e9a:	cd b7       	in	r28, 0x3d	; 61
    5e9c:	de b7       	in	r29, 0x3e	; 62
    MyByte8T buff[2];

    NTRXSPIRead (NA_Version_O, buff, 1);
    5e9e:	81 e0       	ldi	r24, 0x01	; 1
    5ea0:	9e 01       	movw	r18, r28
    5ea2:	2f 5f       	subi	r18, 0xFF	; 255
    5ea4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ea6:	b9 01       	movw	r22, r18
    5ea8:	41 e0       	ldi	r20, 0x01	; 1
    5eaa:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
    NTRXSPIRead (NA_Revision_O, &(buff[1]), 1);
    5eae:	9e 01       	movw	r18, r28
    5eb0:	2e 5f       	subi	r18, 0xFE	; 254
    5eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5eb4:	82 e0       	ldi	r24, 0x02	; 2
    5eb6:	b9 01       	movw	r22, r18
    5eb8:	41 e0       	ldi	r20, 0x01	; 1
    5eba:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>

#   if ((CONFIG_PRINTF) && (CONFIG_LOGO))
    printf("ver:%d, rev:%d\n", buff[0], buff[1]);
#   endif

    if (buff[0] == NA_Version_I && buff[1] == NA_Revision_I)
    5ebe:	89 81       	ldd	r24, Y+1	; 0x01
    5ec0:	85 30       	cpi	r24, 0x05	; 5
    5ec2:	31 f4       	brne	.+12     	; 0x5ed0 <NTRXCheckVerRev+0x3e>
    5ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ec6:	81 30       	cpi	r24, 0x01	; 1
    5ec8:	19 f4       	brne	.+6      	; 0x5ed0 <NTRXCheckVerRev+0x3e>
    {
        return TRUE;
    5eca:	81 e0       	ldi	r24, 0x01	; 1
    5ecc:	8b 83       	std	Y+3, r24	; 0x03
    5ece:	01 c0       	rjmp	.+2      	; 0x5ed2 <NTRXCheckVerRev+0x40>
    }
    else
    {
        return FALSE;
    5ed0:	1b 82       	std	Y+3, r1	; 0x03
    5ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
}
    5ed4:	0f 90       	pop	r0
    5ed6:	0f 90       	pop	r0
    5ed8:	0f 90       	pop	r0
    5eda:	cf 91       	pop	r28
    5edc:	df 91       	pop	r29
    5ede:	08 95       	ret

00005ee0 <NTRXGetTxArqMax>:
 *
 */
/**************************************************************************/
MyByte8T NTRXGetTxArqMax (void)
/**************************************************************************/
{
    5ee0:	df 93       	push	r29
    5ee2:	cf 93       	push	r28
    5ee4:	cd b7       	in	r28, 0x3d	; 61
    5ee6:	de b7       	in	r29, 0x3e	; 62
	return ((ntrxShadowReg[NA_TxArqMax_O] >> 4) & 0x0f);
    5ee8:	80 91 42 0f 	lds	r24, 0x0F42
    5eec:	82 95       	swap	r24
    5eee:	8f 70       	andi	r24, 0x0F	; 15
}
    5ef0:	cf 91       	pop	r28
    5ef2:	df 91       	pop	r29
    5ef4:	08 95       	ret

00005ef6 <NTRXGetRxCrc2Mode>:
 * The value is taken from the shadow ram.
 */
/**************************************************************************/
MyBoolT NTRXGetRxCrc2Mode (void)
/**************************************************************************/
{
    5ef6:	df 93       	push	r29
    5ef8:	cf 93       	push	r28
    5efa:	cd b7       	in	r28, 0x3d	; 61
    5efc:	de b7       	in	r29, 0x3e	; 62
    return ((MyBoolT)((ntrxShadowReg[NA_RxCrc2Mode_O] & (1<< NA_RxCrc2Mode_B)) >> NA_RxCrc2Mode_B));
    5efe:	80 91 60 0f 	lds	r24, 0x0F60
    5f02:	88 2f       	mov	r24, r24
    5f04:	90 e0       	ldi	r25, 0x00	; 0
    5f06:	82 70       	andi	r24, 0x02	; 2
    5f08:	90 70       	andi	r25, 0x00	; 0
    5f0a:	95 95       	asr	r25
    5f0c:	87 95       	ror	r24
}
    5f0e:	cf 91       	pop	r28
    5f10:	df 91       	pop	r29
    5f12:	08 95       	ret

00005f14 <NTRXFctCal>:
 * by en- and disableing capacitors.
 */
/**************************************************************************/
void NTRXFctCal (void)
/**************************************************************************/
{
    5f14:	df 93       	push	r29
    5f16:	cf 93       	push	r28
    5f18:	cd b7       	in	r28, 0x3d	; 61
    5f1a:	de b7       	in	r29, 0x3e	; 62
    5f1c:	2b 97       	sbiw	r28, 0x0b	; 11
    5f1e:	0f b6       	in	r0, 0x3f	; 63
    5f20:	f8 94       	cli
    5f22:	de bf       	out	0x3e, r29	; 62
    5f24:	0f be       	out	0x3f, r0	; 63
    5f26:	cd bf       	out	0x3d, r28	; 61
    int capsVal = 7;
    5f28:	87 e0       	ldi	r24, 0x07	; 7
    5f2a:	90 e0       	ldi	r25, 0x00	; 0
    5f2c:	9a 87       	std	Y+10, r25	; 0x0a
    5f2e:	89 87       	std	Y+9, r24	; 0x09
    int targetValMax = 174;
    5f30:	8e ea       	ldi	r24, 0xAE	; 174
    5f32:	90 e0       	ldi	r25, 0x00	; 0
    5f34:	98 87       	std	Y+8, r25	; 0x08
    5f36:	8f 83       	std	Y+7, r24	; 0x07
    int targetValMin = 152;
    5f38:	88 e9       	ldi	r24, 0x98	; 152
    5f3a:	90 e0       	ldi	r25, 0x00	; 0
    5f3c:	9e 83       	std	Y+6, r25	; 0x06
    5f3e:	8d 83       	std	Y+5, r24	; 0x05
    int fctSum = 0;
    5f40:	1c 82       	std	Y+4, r1	; 0x04
    5f42:	1b 82       	std	Y+3, r1	; 0x03
    int ctref;
    unsigned char payload;
    // unsigned long t;

    payload = ( 1 << NA_FctClockEn_B ) | capsVal;
    5f44:	89 85       	ldd	r24, Y+9	; 0x09
    5f46:	80 61       	ori	r24, 0x10	; 16
    5f48:	8b 87       	std	Y+11, r24	; 0x0b
    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
    5f4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f4c:	87 e2       	ldi	r24, 0x27	; 39
    5f4e:	69 2f       	mov	r22, r25
    5f50:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	HWDelayus( 10 ); /* 10 us */
    5f54:	8a e0       	ldi	r24, 0x0A	; 10
    5f56:	90 e0       	ldi	r25, 0x00	; 0
    5f58:	0e 94 03 16 	call	0x2c06	; 0x2c06 <HWDelayus>
    5f5c:	4d c0       	rjmp	.+154    	; 0x5ff8 <NTRXFctCal+0xe4>

    while ((capsVal < 16) && (capsVal >= 0))
    {
        fctSum = 0;
    5f5e:	1c 82       	std	Y+4, r1	; 0x04
    5f60:	1b 82       	std	Y+3, r1	; 0x03
        for (ctref = 0; ctref < 4; ctref++)
    5f62:	1a 82       	std	Y+2, r1	; 0x02
    5f64:	19 82       	std	Y+1, r1	; 0x01
    5f66:	21 c0       	rjmp	.+66     	; 0x5faa <NTRXFctCal+0x96>
        {
    		payload = ( 1 << NA_FctClockEn_B ) | ( 1 << NA_StartFctMeasure_B ) | capsVal;
    5f68:	89 85       	ldd	r24, Y+9	; 0x09
    5f6a:	80 63       	ori	r24, 0x30	; 48
    5f6c:	8b 87       	std	Y+11, r24	; 0x0b
		    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
    5f6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f70:	87 e2       	ldi	r24, 0x27	; 39
    5f72:	69 2f       	mov	r22, r25
    5f74:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
			HWDelayus( 15 ); /* 10 us */
    5f78:	8f e0       	ldi	r24, 0x0F	; 15
    5f7a:	90 e0       	ldi	r25, 0x00	; 0
    5f7c:	0e 94 03 16 	call	0x2c06	; 0x2c06 <HWDelayus>

            NTRXSPIReadByte (NA_FctPeriod_O, &payload);
    5f80:	9e 01       	movw	r18, r28
    5f82:	25 5f       	subi	r18, 0xF5	; 245
    5f84:	3f 4f       	sbci	r19, 0xFF	; 255
    5f86:	87 e2       	ldi	r24, 0x27	; 39
    5f88:	b9 01       	movw	r22, r18
    5f8a:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
            fctSum += payload;
    5f8e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f90:	28 2f       	mov	r18, r24
    5f92:	30 e0       	ldi	r19, 0x00	; 0
    5f94:	8b 81       	ldd	r24, Y+3	; 0x03
    5f96:	9c 81       	ldd	r25, Y+4	; 0x04
    5f98:	82 0f       	add	r24, r18
    5f9a:	93 1f       	adc	r25, r19
    5f9c:	9c 83       	std	Y+4, r25	; 0x04
    5f9e:	8b 83       	std	Y+3, r24	; 0x03
	HWDelayus( 10 ); /* 10 us */

    while ((capsVal < 16) && (capsVal >= 0))
    {
        fctSum = 0;
        for (ctref = 0; ctref < 4; ctref++)
    5fa0:	89 81       	ldd	r24, Y+1	; 0x01
    5fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    5fa4:	01 96       	adiw	r24, 0x01	; 1
    5fa6:	9a 83       	std	Y+2, r25	; 0x02
    5fa8:	89 83       	std	Y+1, r24	; 0x01
    5faa:	89 81       	ldd	r24, Y+1	; 0x01
    5fac:	9a 81       	ldd	r25, Y+2	; 0x02
    5fae:	84 30       	cpi	r24, 0x04	; 4
    5fb0:	91 05       	cpc	r25, r1
    5fb2:	d4 f2       	brlt	.-76     	; 0x5f68 <NTRXFctCal+0x54>
			HWDelayus( 15 ); /* 10 us */

            NTRXSPIReadByte (NA_FctPeriod_O, &payload);
            fctSum += payload;
        }
        if (fctSum >= targetValMax)
    5fb4:	2b 81       	ldd	r18, Y+3	; 0x03
    5fb6:	3c 81       	ldd	r19, Y+4	; 0x04
    5fb8:	8f 81       	ldd	r24, Y+7	; 0x07
    5fba:	98 85       	ldd	r25, Y+8	; 0x08
    5fbc:	28 17       	cp	r18, r24
    5fbe:	39 07       	cpc	r19, r25
    5fc0:	34 f0       	brlt	.+12     	; 0x5fce <NTRXFctCal+0xba>
        {
            capsVal--;
    5fc2:	89 85       	ldd	r24, Y+9	; 0x09
    5fc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fc6:	01 97       	sbiw	r24, 0x01	; 1
    5fc8:	9a 87       	std	Y+10, r25	; 0x0a
    5fca:	89 87       	std	Y+9, r24	; 0x09
    5fcc:	15 c0       	rjmp	.+42     	; 0x5ff8 <NTRXFctCal+0xe4>
        }
        else if (fctSum <= targetValMin)
    5fce:	2b 81       	ldd	r18, Y+3	; 0x03
    5fd0:	3c 81       	ldd	r19, Y+4	; 0x04
    5fd2:	8d 81       	ldd	r24, Y+5	; 0x05
    5fd4:	9e 81       	ldd	r25, Y+6	; 0x06
    5fd6:	82 17       	cp	r24, r18
    5fd8:	93 07       	cpc	r25, r19
    5fda:	34 f0       	brlt	.+12     	; 0x5fe8 <NTRXFctCal+0xd4>
        {
            capsVal++;
    5fdc:	89 85       	ldd	r24, Y+9	; 0x09
    5fde:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fe0:	01 96       	adiw	r24, 0x01	; 1
    5fe2:	9a 87       	std	Y+10, r25	; 0x0a
    5fe4:	89 87       	std	Y+9, r24	; 0x09
    5fe6:	08 c0       	rjmp	.+16     	; 0x5ff8 <NTRXFctCal+0xe4>
        }
        else
        {
            payload = capsVal;
    5fe8:	89 85       	ldd	r24, Y+9	; 0x09
    5fea:	8b 87       	std	Y+11, r24	; 0x0b
		    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
    5fec:	9b 85       	ldd	r25, Y+11	; 0x0b
    5fee:	87 e2       	ldi	r24, 0x27	; 39
    5ff0:	69 2f       	mov	r22, r25
    5ff2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    5ff6:	11 c0       	rjmp	.+34     	; 0x601a <NTRXFctCal+0x106>

    payload = ( 1 << NA_FctClockEn_B ) | capsVal;
    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
	HWDelayus( 10 ); /* 10 us */

    while ((capsVal < 16) && (capsVal >= 0))
    5ff8:	89 85       	ldd	r24, Y+9	; 0x09
    5ffa:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ffc:	80 31       	cpi	r24, 0x10	; 16
    5ffe:	91 05       	cpc	r25, r1
    6000:	2c f4       	brge	.+10     	; 0x600c <NTRXFctCal+0xf8>
    6002:	89 85       	ldd	r24, Y+9	; 0x09
    6004:	9a 85       	ldd	r25, Y+10	; 0x0a
    6006:	99 23       	and	r25, r25
    6008:	0c f0       	brlt	.+2      	; 0x600c <NTRXFctCal+0xf8>
    600a:	a9 cf       	rjmp	.-174    	; 0x5f5e <NTRXFctCal+0x4a>
            payload = capsVal;
		    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
			return;
        }
    }
    payload = 6;
    600c:	86 e0       	ldi	r24, 0x06	; 6
    600e:	8b 87       	std	Y+11, r24	; 0x0b
    NTRXSPIWriteByte (NA_ChirpFilterCaps_O, payload);
    6010:	9b 85       	ldd	r25, Y+11	; 0x0b
    6012:	87 e2       	ldi	r24, 0x27	; 39
    6014:	69 2f       	mov	r22, r25
    6016:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    601a:	2b 96       	adiw	r28, 0x0b	; 11
    601c:	0f b6       	in	r0, 0x3f	; 63
    601e:	f8 94       	cli
    6020:	de bf       	out	0x3e, r29	; 62
    6022:	0f be       	out	0x3f, r0	; 63
    6024:	cd bf       	out	0x3d, r28	; 61
    6026:	cf 91       	pop	r28
    6028:	df 91       	pop	r29
    602a:	08 95       	ret

0000602c <NTRXSetSyncWord>:
 * (received) and processed.
 */
/**************************************************************************/
void NTRXSetSyncWord (MyByte8T *value)
/**************************************************************************/
{
    602c:	df 93       	push	r29
    602e:	cf 93       	push	r28
    6030:	00 d0       	rcall	.+0      	; 0x6032 <NTRXSetSyncWord+0x6>
    6032:	cd b7       	in	r28, 0x3d	; 61
    6034:	de b7       	in	r29, 0x3e	; 62
    6036:	9a 83       	std	Y+2, r25	; 0x02
    6038:	89 83       	std	Y+1, r24	; 0x01
	NTRXSPIWrite (NA_SyncWord_O, value, 8);
    603a:	29 81       	ldd	r18, Y+1	; 0x01
    603c:	3a 81       	ldd	r19, Y+2	; 0x02
    603e:	8a e2       	ldi	r24, 0x2A	; 42
    6040:	b9 01       	movw	r22, r18
    6042:	48 e0       	ldi	r20, 0x08	; 8
    6044:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
}
    6048:	0f 90       	pop	r0
    604a:	0f 90       	pop	r0
    604c:	cf 91       	pop	r28
    604e:	df 91       	pop	r29
    6050:	08 95       	ret

00006052 <NTRXSetupTrxMode>:
 *
 */
/**************************************************************************/
void NTRXSetupTrxMode (MyByte8T fdma, MyByte8T sd, MyByte8T sr)
/**************************************************************************/
{
    6052:	df 93       	push	r29
    6054:	cf 93       	push	r28
    6056:	00 d0       	rcall	.+0      	; 0x6058 <NTRXSetupTrxMode+0x6>
    6058:	00 d0       	rcall	.+0      	; 0x605a <NTRXSetupTrxMode+0x8>
    605a:	0f 92       	push	r0
    605c:	cd b7       	in	r28, 0x3d	; 61
    605e:	de b7       	in	r29, 0x3e	; 62
    6060:	89 83       	std	Y+1, r24	; 0x01
    6062:	6a 83       	std	Y+2, r22	; 0x02
    6064:	4b 83       	std	Y+3, r20	; 0x03
	static MyByte8T firstTime = 0;

	if ((lfdma == fdma) && (lsd == sd) && (lsr == sr))
    6066:	90 91 ee 0e 	lds	r25, 0x0EEE
    606a:	89 81       	ldd	r24, Y+1	; 0x01
    606c:	98 17       	cp	r25, r24
    606e:	69 f4       	brne	.+26     	; 0x608a <NTRXSetupTrxMode+0x38>
    6070:	90 91 ef 0e 	lds	r25, 0x0EEF
    6074:	8a 81       	ldd	r24, Y+2	; 0x02
    6076:	98 17       	cp	r25, r24
    6078:	41 f4       	brne	.+16     	; 0x608a <NTRXSetupTrxMode+0x38>
    607a:	90 91 f0 0e 	lds	r25, 0x0EF0
    607e:	8b 81       	ldd	r24, Y+3	; 0x03
    6080:	98 17       	cp	r25, r24
    6082:	19 f4       	brne	.+6      	; 0x608a <NTRXSetupTrxMode+0x38>
	{
	    NTRXAllCalibration ();
    6084:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>
    6088:	49 c1       	rjmp	.+658    	; 0x631c <NTRXSetupTrxMode+0x2ca>
		return;
	}

	modeSet.bw = fdma;
    608a:	89 81       	ldd	r24, Y+1	; 0x01
    608c:	80 93 f1 0e 	sts	0x0EF1, r24
	modeSet.sd = sd;
    6090:	8a 81       	ldd	r24, Y+2	; 0x02
    6092:	80 93 f2 0e 	sts	0x0EF2, r24
	modeSet.sr = sr;
    6096:	8b 81       	ldd	r24, Y+3	; 0x03
    6098:	80 93 f3 0e 	sts	0x0EF3, r24
	if (fdma == NA_22MHz)
    609c:	89 81       	ldd	r24, Y+1	; 0x01
    609e:	81 30       	cpi	r24, 0x01	; 1
    60a0:	39 f4       	brne	.+14     	; 0x60b0 <NTRXSetupTrxMode+0x5e>
	{
    	modeSet.fdma= TRUE;
    60a2:	81 e0       	ldi	r24, 0x01	; 1
    60a4:	80 93 f4 0e 	sts	0x0EF4, r24
    	modeSet.fixnmap=NA_FIX_MODE;
    60a8:	81 e0       	ldi	r24, 0x01	; 1
    60aa:	80 93 f5 0e 	sts	0x0EF5, r24
    60ae:	05 c0       	rjmp	.+10     	; 0x60ba <NTRXSetupTrxMode+0x68>
	}
	else
	{
    	modeSet.fdma= FALSE;
    60b0:	10 92 f4 0e 	sts	0x0EF4, r1
    	modeSet.fixnmap=NA_FIX_MODE;
    60b4:	81 e0       	ldi	r24, 0x01	; 1
    60b6:	80 93 f5 0e 	sts	0x0EF5, r24
	}

	if (firstTime++ != 0)
    60ba:	80 91 86 0f 	lds	r24, 0x0F86
    60be:	8c 83       	std	Y+4, r24	; 0x04
    60c0:	8c 81       	ldd	r24, Y+4	; 0x04
    60c2:	8d 83       	std	Y+5, r24	; 0x05
    60c4:	8d 81       	ldd	r24, Y+5	; 0x05
    60c6:	88 23       	and	r24, r24
    60c8:	11 f0       	breq	.+4      	; 0x60ce <NTRXSetupTrxMode+0x7c>
    60ca:	81 e0       	ldi	r24, 0x01	; 1
    60cc:	8d 83       	std	Y+5, r24	; 0x05
    60ce:	9d 81       	ldd	r25, Y+5	; 0x05
    60d0:	8c 81       	ldd	r24, Y+4	; 0x04
    60d2:	8f 5f       	subi	r24, 0xFF	; 255
    60d4:	80 93 86 0f 	sts	0x0F86, r24
    60d8:	99 23       	and	r25, r25
    60da:	a1 f1       	breq	.+104    	; 0x6144 <NTRXSetupTrxMode+0xf2>
	{
		if (ntrxShadowReg[NA_RamIndex_O] != 0)
    60dc:	80 91 14 0f 	lds	r24, 0x0F14
    60e0:	88 23       	and	r24, r24
    60e2:	21 f0       	breq	.+8      	; 0x60ec <NTRXSetupTrxMode+0x9a>
		{
			NTRXSPIWriteByte (NA_RamIndex_O, 0);
    60e4:	8e e0       	ldi	r24, 0x0E	; 14
    60e6:	60 e0       	ldi	r22, 0x00	; 0
    60e8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		}
		NTRXSPIWriteByte (NA_RxCmdStop_O, (1 << NA_RxCmdStop_B) | (0x03 << NA_RxBufferCmd_LSB));
    60ec:	86 e5       	ldi	r24, 0x56	; 86
    60ee:	6d e0       	ldi	r22, 0x0D	; 13
    60f0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		NTRXSPIWriteByte (NA_RxIntsReset_O, (0x7f << NA_RxIntsReset_LSB));
    60f4:	81 e1       	ldi	r24, 0x11	; 17
    60f6:	6f e7       	ldi	r22, 0x7F	; 127
    60f8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		NTRXSPIWriteByte (NA_ResetBbRadioCtrl_O, (1 << NA_ResetBbRadioCtrl_B));
    60fc:	87 e0       	ldi	r24, 0x07	; 7
    60fe:	64 e0       	ldi	r22, 0x04	; 4
    6100:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		ntrxShadowReg[NA_ResetBbRadioCtrl_O] = 0;
    6104:	10 92 0d 0f 	sts	0x0F0D, r1
		ntrxShadowReg[NA_EnableBbClock_O] &= ~(1 << NA_EnableBbClock_B);
    6108:	80 91 0e 0f 	lds	r24, 0x0F0E
    610c:	8d 7f       	andi	r24, 0xFD	; 253
    610e:	80 93 0e 0f 	sts	0x0F0E, r24
		NTRXSPIWrite (NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);
    6112:	2d e0       	ldi	r18, 0x0D	; 13
    6114:	3f e0       	ldi	r19, 0x0F	; 15
    6116:	87 e0       	ldi	r24, 0x07	; 7
    6118:	b9 01       	movw	r22, r18
    611a:	42 e0       	ldi	r20, 0x02	; 2
    611c:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
		ntrxShadowReg[NA_ResetBbClockGate_O] |= (1 << NA_ResetBbClockGate_B);
    6120:	80 91 0d 0f 	lds	r24, 0x0F0D
    6124:	82 60       	ori	r24, 0x02	; 2
    6126:	80 93 0d 0f 	sts	0x0F0D, r24
		ntrxShadowReg[NA_EnableBbClock_O] &= ~(1 << NA_EnableBbCrystal_B);
    612a:	80 91 0e 0f 	lds	r24, 0x0F0E
    612e:	8e 7f       	andi	r24, 0xFE	; 254
    6130:	80 93 0e 0f 	sts	0x0F0E, r24
		NTRXSPIWrite (NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);
    6134:	2d e0       	ldi	r18, 0x0D	; 13
    6136:	3f e0       	ldi	r19, 0x0F	; 15
    6138:	87 e0       	ldi	r24, 0x07	; 7
    613a:	b9 01       	movw	r22, r18
    613c:	42 e0       	ldi	r20, 0x02	; 2
    613e:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
    6142:	03 c0       	rjmp	.+6      	; 0x614a <NTRXSetupTrxMode+0xf8>

	}else 	phyPIB.rxState = PHY_RX_ON;
    6144:	86 e0       	ldi	r24, 0x06	; 6
    6146:	80 93 bf 0e 	sts	0x0EBF, r24


    /* first part of initial register setting */
	ntrxShadowReg[NA_ResetBbClockGate_O] |= (1 << NA_ResetBbClockGate_B);
    614a:	80 91 0d 0f 	lds	r24, 0x0F0D
    614e:	82 60       	ori	r24, 0x02	; 2
    6150:	80 93 0d 0f 	sts	0x0F0D, r24
	ntrxShadowReg[NA_EnableBbCrystal_O] |= (1 << NA_EnableBbCrystal_B);
    6154:	80 91 0e 0f 	lds	r24, 0x0F0E
    6158:	81 60       	ori	r24, 0x01	; 1
    615a:	80 93 0e 0f 	sts	0x0F0E, r24
	NTRXSPIWrite (NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);
    615e:	2d e0       	ldi	r18, 0x0D	; 13
    6160:	3f e0       	ldi	r19, 0x0F	; 15
    6162:	87 e0       	ldi	r24, 0x07	; 7
    6164:	b9 01       	movw	r22, r18
    6166:	42 e0       	ldi	r20, 0x02	; 2
    6168:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
	HWDelayms( 5 ); /* 5 ms */
    616c:	85 e0       	ldi	r24, 0x05	; 5
    616e:	90 e0       	ldi	r25, 0x00	; 0
    6170:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>
	ntrxShadowReg[NA_ResetBbClockGate_O] &= ~(1 << NA_ResetBbClockGate_B);
    6174:	80 91 0d 0f 	lds	r24, 0x0F0D
    6178:	8d 7f       	andi	r24, 0xFD	; 253
    617a:	80 93 0d 0f 	sts	0x0F0D, r24
	ntrxShadowReg[NA_EnableBbClock_O] |= (1 << NA_EnableBbClock_B);
    617e:	80 91 0e 0f 	lds	r24, 0x0F0E
    6182:	82 60       	ori	r24, 0x02	; 2
    6184:	80 93 0e 0f 	sts	0x0F0E, r24
	NTRXSPIWrite (NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);
    6188:	2d e0       	ldi	r18, 0x0D	; 13
    618a:	3f e0       	ldi	r19, 0x0F	; 15
    618c:	87 e0       	ldi	r24, 0x07	; 7
    618e:	b9 01       	movw	r22, r18
    6190:	42 e0       	ldi	r20, 0x02	; 2
    6192:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
	NTRXSPIWriteByte (NA_ResetBbRadioCtrl_O, (1 << NA_ResetBbRadioCtrl_B));
    6196:	87 e0       	ldi	r24, 0x07	; 7
    6198:	64 e0       	ldi	r22, 0x04	; 4
    619a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	NTRXSPIWriteByte (NA_ResetBbClockGate_O, 0);
    619e:	87 e0       	ldi	r24, 0x07	; 7
    61a0:	60 e0       	ldi	r22, 0x00	; 0
    61a2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_HoldAgcInBitSync_O] &= ~(0x7f << NA_HoldAgcInBitSync_LSB);
    61a6:	80 91 27 0f 	lds	r24, 0x0F27
    61aa:	80 78       	andi	r24, 0x80	; 128
    61ac:	80 93 27 0f 	sts	0x0F27, r24
	ntrxShadowReg[NA_HoldAgcInFrameSync_O] |= ((1 << NA_HoldAgcInFrameSync_B)
    61b0:	80 91 27 0f 	lds	r24, 0x0F27
    61b4:	88 69       	ori	r24, 0x98	; 152
    61b6:	80 93 27 0f 	sts	0x0F27, r24
							| (24 << NA_HoldAgcInBitSync_LSB));
	NTRXSPIWriteByte (NA_HoldAgcInFrameSync_O, ntrxShadowReg[NA_HoldAgcInFrameSync_O]);
    61ba:	90 91 27 0f 	lds	r25, 0x0F27
    61be:	81 e2       	ldi	r24, 0x21	; 33
    61c0:	69 2f       	mov	r22, r25
    61c2:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_ChirpFilterCaps_O] &= ~(0x0f << NA_ChirpFilterCaps_LSB);
    61c6:	80 91 2d 0f 	lds	r24, 0x0F2D
    61ca:	80 7f       	andi	r24, 0xF0	; 240
    61cc:	80 93 2d 0f 	sts	0x0F2D, r24
	NTRXSPIWriteByte (NA_ChirpFilterCaps_O, ntrxShadowReg[NA_ChirpFilterCaps_O]);
    61d0:	90 91 2d 0f 	lds	r25, 0x0F2D
    61d4:	87 e2       	ldi	r24, 0x27	; 39
    61d6:	69 2f       	mov	r22, r25
    61d8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    /* Tx Part */
	ntrxShadowReg[NA_TxArqMax_O] = (CONFIG_MAX_ARQ << NA_TxArqMax_LSB);
    61dc:	80 ee       	ldi	r24, 0xE0	; 224
    61de:	80 93 42 0f 	sts	0x0F42, r24
	ntrxShadowReg[NA_CsqUsePhaseShift_O] &= ~((1 << NA_CsqUsePhaseShift_B)
    61e2:	80 91 43 0f 	lds	r24, 0x0F43
    61e6:	8b 7e       	andi	r24, 0xEB	; 235
    61e8:	80 93 43 0f 	sts	0x0F43, r24
							| (1 << NA_CsqAsyMode_B));
	ntrxShadowReg[NA_CsqUseRam_O] |= (1 << NA_CsqUseRam_B);
    61ec:	80 91 43 0f 	lds	r24, 0x0F43
    61f0:	80 64       	ori	r24, 0x40	; 64
    61f2:	80 93 43 0f 	sts	0x0F43, r24
	NTRXSPIWrite (NA_TxArqMax_O, ntrxShadowReg + NA_TxArqMax_O, 2);
    61f6:	22 e4       	ldi	r18, 0x42	; 66
    61f8:	3f e0       	ldi	r19, 0x0F	; 15
    61fa:	8c e3       	ldi	r24, 0x3C	; 60
    61fc:	b9 01       	movw	r22, r18
    61fe:	42 e0       	ldi	r20, 0x02	; 2
    6200:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

	ntrxShadowReg[NA_EnableLO_O] &= ~((1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B));
    6204:	80 91 48 0f 	lds	r24, 0x0F48
    6208:	8c 7f       	andi	r24, 0xFC	; 252
    620a:	80 93 48 0f 	sts	0x0F48, r24
	ntrxShadowReg[NA_EnableExtPA_O] |= ((1 << NA_EnableExtPA_B)
    620e:	80 91 48 0f 	lds	r24, 0x0F48
    6212:	84 61       	ori	r24, 0x14	; 20
    6214:	80 93 48 0f 	sts	0x0F48, r24
							| (1 << NA_EnableCsqClock_B));
	ntrxShadowReg[NA_RfRxCompValueI_O] &= ~(0x0f << NA_RfRxCompValueI_LSB);
    6218:	80 91 4c 0f 	lds	r24, 0x0F4C
    621c:	80 7f       	andi	r24, 0xF0	; 240
    621e:	80 93 4c 0f 	sts	0x0F4C, r24
	ntrxShadowReg[NA_RfRxCompValueI_O] |= (0x0e << NA_RfRxCompValueI_LSB);
    6222:	80 91 4c 0f 	lds	r24, 0x0F4C
    6226:	8e 60       	ori	r24, 0x0E	; 14
    6228:	80 93 4c 0f 	sts	0x0F4C, r24
	ntrxShadowReg[NA_RfRxCompValueQ_O] &= ~(0x0f << NA_RfRxCompValueQ_LSB);
    622c:	80 91 4d 0f 	lds	r24, 0x0F4D
    6230:	80 7f       	andi	r24, 0xF0	; 240
    6232:	80 93 4d 0f 	sts	0x0F4D, r24
	ntrxShadowReg[NA_RfRxCompValueQ_O] |= (0x0e << NA_RfRxCompValueQ_LSB);
    6236:	80 91 4d 0f 	lds	r24, 0x0F4D
    623a:	8e 60       	ori	r24, 0x0E	; 14
    623c:	80 93 4d 0f 	sts	0x0F4D, r24
	NTRXSPIWrite (NA_EnableExtPA_O, ntrxShadowReg + NA_EnableExtPA_O, 7);
    6240:	28 e4       	ldi	r18, 0x48	; 72
    6242:	3f e0       	ldi	r19, 0x0F	; 15
    6244:	82 e4       	ldi	r24, 0x42	; 66
    6246:	b9 01       	movw	r22, r18
    6248:	47 e0       	ldi	r20, 0x07	; 7
    624a:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
	ntrxShadowReg[NA_TxScrambEn_O] |= (1 << NA_TxScrambEn_B);
    624e:	80 91 57 0f 	lds	r24, 0x0F57
    6252:	80 68       	ori	r24, 0x80	; 128
    6254:	80 93 57 0f 	sts	0x0F57, r24
	ntrxShadowReg[NA_TxAddrSlct_O] &= ~(1 << NA_TxAddrSlct_B);
    6258:	80 91 5a 0f 	lds	r24, 0x0F5A
    625c:	8f 77       	andi	r24, 0x7F	; 127
    625e:	80 93 5a 0f 	sts	0x0F5A, r24
	NTRXSPIWrite (NA_TxArq_O, ntrxShadowReg + NA_TxArq_O , 7);
    6262:	24 e5       	ldi	r18, 0x54	; 84
    6264:	3f e0       	ldi	r19, 0x0F	; 15
    6266:	8e e4       	ldi	r24, 0x4E	; 78
    6268:	b9 01       	movw	r22, r18
    626a:	47 e0       	ldi	r20, 0x07	; 7
    626c:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
	ntrxShadowReg[NA_RxCrc2Mode_O] |= (NA_RxCrc2ModeTrigOn_BC_C << NA_RxCrc2Mode_B);
    6270:	80 91 60 0f 	lds	r24, 0x0F60
    6274:	82 60       	ori	r24, 0x02	; 2
    6276:	80 93 60 0f 	sts	0x0F60, r24
	ntrxShadowReg[NA_RxTimeBCrc1Mode_O] &= ~(NA_RxTimeBCrc1ModeOn_BC_C << NA_RxTimeBCrc1Mode_B);
    627a:	80 91 60 0f 	lds	r24, 0x0F60
    627e:	8e 7f       	andi	r24, 0xFE	; 254
    6280:	80 93 60 0f 	sts	0x0F60, r24
	NTRXSPIWriteByte( NA_RxArqMode_O, ntrxShadowReg[NA_RxArqMode_O] );
    6284:	90 91 60 0f 	lds	r25, 0x0F60
    6288:	8a e5       	ldi	r24, 0x5A	; 90
    628a:	69 2f       	mov	r22, r25
    628c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
#	ifdef CONFIG_NTRX_SNIFFER
	ntrxShadowReg[NA_RxAddrMode_O] &= ~(1 << NA_RxAddrMode_B);
//	ntrxShadowReg[0x5b] |= (1 << NA_RxDataEn_B) | (1 << NA_RxBrdcastEn_B) | (1 << NA_RxTimeBEn_B); // set by default
	NTRXSPIWriteByte( NA_RxAddrMode_O, ntrxShadowReg[NA_RxAddrMode_O] );
#	else
	ntrxShadowReg[NA_RxAddrMode_O] |= (1 << NA_RxAddrMode_B);
    6290:	80 91 61 0f 	lds	r24, 0x0F61
    6294:	88 60       	ori	r24, 0x08	; 8
    6296:	80 93 61 0f 	sts	0x0F61, r24
#	endif

	ntrxShadowReg[NA_GateSizeFramesync_O]  = ((NA_GateSize5Slots_VC_C << NA_GateSizeFramesync_LSB)
    629a:	85 e5       	ldi	r24, 0x55	; 85
    629c:	80 93 64 0f 	sts	0x0F64, r24
							| (NA_GateSizeUnsync_I << NA_GateSizeUnsync_LSB)
							| (NA_GateSizeBitsync_I << NA_GateSizeBitsync_LSB)
							| ( 1 << NA_GateAdjBitsyncEn_B )
							);
	NTRXSPIWriteByte( NA_GateSizeFramesync_O, ntrxShadowReg[NA_GateSizeFramesync_O] );
    62a0:	90 91 64 0f 	lds	r25, 0x0F64
    62a4:	8e e5       	ldi	r24, 0x5E	; 94
    62a6:	69 2f       	mov	r22, r25
    62a8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>



	ntrxShadowReg[NA_AgcValue_O] &= ~(0x3f << NA_AgcValue_LSB);
    62ac:	80 91 2b 0f 	lds	r24, 0x0F2B
    62b0:	80 7c       	andi	r24, 0xC0	; 192
    62b2:	80 93 2b 0f 	sts	0x0F2B, r24
	ntrxShadowReg[NA_AgcValue_O] |= (23 << NA_AgcValue_LSB);
    62b6:	80 91 2b 0f 	lds	r24, 0x0F2B
    62ba:	87 61       	ori	r24, 0x17	; 23
    62bc:	80 93 2b 0f 	sts	0x0F2B, r24
	NTRXSPIWriteByte (NA_AgcValue_O, ntrxShadowReg[NA_AgcValue_O]);
    62c0:	90 91 2b 0f 	lds	r25, 0x0F2B
    62c4:	85 e2       	ldi	r24, 0x25	; 37
    62c6:	69 2f       	mov	r22, r25
    62c8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	HWDelayms( 2 ); /* 2 ms */
    62cc:	82 e0       	ldi	r24, 0x02	; 2
    62ce:	90 e0       	ldi	r25, 0x00	; 0
    62d0:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <HWDelayms>

	NTRXFctCal ();
    62d4:	0e 94 8a 2f 	call	0x5f14	; 0x5f14 <NTRXFctCal>

    NTRXSetRxIqMatrix (fdma, sd);
    62d8:	89 81       	ldd	r24, Y+1	; 0x01
    62da:	6a 81       	ldd	r22, Y+2	; 0x02
    62dc:	0e 94 46 34 	call	0x688c	; 0x688c <NTRXSetRxIqMatrix>
	NTRXSetCorrThreshold (fdma, sd);
    62e0:	89 81       	ldd	r24, Y+1	; 0x01
    62e2:	6a 81       	ldd	r22, Y+2	; 0x02
    62e4:	0e 94 e3 37 	call	0x6fc6	; 0x6fc6 <NTRXSetCorrThreshold>
   	NTRXSetTxIqMatrix (fdma, sd);
    62e8:	89 81       	ldd	r24, Y+1	; 0x01
    62ea:	6a 81       	ldd	r22, Y+2	; 0x02
    62ec:	0e 94 25 35 	call	0x6a4a	; 0x6a4a <NTRXSetTxIqMatrix>
	NTRXSetSyncWord(phyPIB.syncword);
    62f0:	8e ed       	ldi	r24, 0xDE	; 222
    62f2:	9e e0       	ldi	r25, 0x0E	; 14
    62f4:	0e 94 16 30 	call	0x602c	; 0x602c <NTRXSetSyncWord>

    NTRXAllCalibration ();
    62f8:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <NTRXAllCalibration>

   	NTRXSetAgcValues (fdma, sd, sr);
    62fc:	89 81       	ldd	r24, Y+1	; 0x01
    62fe:	6a 81       	ldd	r22, Y+2	; 0x02
    6300:	4b 81       	ldd	r20, Y+3	; 0x03
    6302:	0e 94 18 37 	call	0x6e30	; 0x6e30 <NTRXSetAgcValues>

	PHYInit ();
    6306:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <PHYInit>

	lfdma 	= fdma;
    630a:	89 81       	ldd	r24, Y+1	; 0x01
    630c:	80 93 ee 0e 	sts	0x0EEE, r24
	lsd   	= sd;
    6310:	8a 81       	ldd	r24, Y+2	; 0x02
    6312:	80 93 ef 0e 	sts	0x0EEF, r24
	lsr		= sr;
    6316:	8b 81       	ldd	r24, Y+3	; 0x03
    6318:	80 93 f0 0e 	sts	0x0EF0, r24
}
    631c:	0f 90       	pop	r0
    631e:	0f 90       	pop	r0
    6320:	0f 90       	pop	r0
    6322:	0f 90       	pop	r0
    6324:	0f 90       	pop	r0
    6326:	cf 91       	pop	r28
    6328:	df 91       	pop	r29
    632a:	08 95       	ret

0000632c <NTRXGetRtc>:
 *
 */
/**************************************************************************/
MyDword32T NTRXGetRtc (MyBoolT force)
/**************************************************************************/
{
    632c:	df 93       	push	r29
    632e:	cf 93       	push	r28
    6330:	cd b7       	in	r28, 0x3d	; 61
    6332:	de b7       	in	r29, 0x3e	; 62
    6334:	2c 97       	sbiw	r28, 0x0c	; 12
    6336:	0f b6       	in	r0, 0x3f	; 63
    6338:	f8 94       	cli
    633a:	de bf       	out	0x3e, r29	; 62
    633c:	0f be       	out	0x3f, r0	; 63
    633e:	cd bf       	out	0x3d, r28	; 61
    6340:	8c 87       	std	Y+12, r24	; 0x0c
	/*FIXME disabled for debugging!*/
	static MyDword32T currentRTC;					/**< stores the last RTC value*/
	static MyDword32T currentHwclock = 0xFFFFFFFF;	/**< stores the hwclock value when RTC was read*/
	MyDword32T now = hwclock();
    6342:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <hwclock>
    6346:	dc 01       	movw	r26, r24
    6348:	cb 01       	movw	r24, r22
    634a:	8b 83       	std	Y+3, r24	; 0x03
    634c:	9c 83       	std	Y+4, r25	; 0x04
    634e:	ad 83       	std	Y+5, r26	; 0x05
    6350:	be 83       	std	Y+6, r27	; 0x06

	/*
	Avoid redundant access to RTC to save time.
	force == TRUE lets the function read the RTC anyway.
	*/
	if ((now != currentHwclock) || (force))
    6352:	20 91 a0 07 	lds	r18, 0x07A0
    6356:	30 91 a1 07 	lds	r19, 0x07A1
    635a:	40 91 a2 07 	lds	r20, 0x07A2
    635e:	50 91 a3 07 	lds	r21, 0x07A3
    6362:	8b 81       	ldd	r24, Y+3	; 0x03
    6364:	9c 81       	ldd	r25, Y+4	; 0x04
    6366:	ad 81       	ldd	r26, Y+5	; 0x05
    6368:	be 81       	ldd	r27, Y+6	; 0x06
    636a:	82 17       	cp	r24, r18
    636c:	93 07       	cpc	r25, r19
    636e:	a4 07       	cpc	r26, r20
    6370:	b5 07       	cpc	r27, r21
    6372:	21 f4       	brne	.+8      	; 0x637c <NTRXGetRtc+0x50>
    6374:	8c 85       	ldd	r24, Y+12	; 0x0c
    6376:	88 23       	and	r24, r24
    6378:	09 f4       	brne	.+2      	; 0x637c <NTRXGetRtc+0x50>
    637a:	62 c0       	rjmp	.+196    	; 0x6440 <NTRXGetRtc+0x114>
		MyByte8T rtc[5];
		MyByte8T reg;


		/*read current RTC*/
		ENTER_TASK;
    637c:	ef e5       	ldi	r30, 0x5F	; 95
    637e:	f0 e0       	ldi	r31, 0x00	; 0
    6380:	80 81       	ld	r24, Z
    6382:	89 83       	std	Y+1, r24	; 0x01
    6384:	f8 94       	cli
		reg = ntrxShadowReg[NA_RtcCmdRd_O] | ( 1 << NA_RtcCmdRd_B );
    6386:	80 91 68 0f 	lds	r24, 0x0F68
    638a:	82 60       	ori	r24, 0x02	; 2
    638c:	8a 83       	std	Y+2, r24	; 0x02
		NTRXSPIWriteByte(NA_RtcCmdRd_O, reg);
    638e:	82 e6       	ldi	r24, 0x62	; 98
    6390:	6a 81       	ldd	r22, Y+2	; 0x02
    6392:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		HWDelayus( 130 );
    6396:	82 e8       	ldi	r24, 0x82	; 130
    6398:	90 e0       	ldi	r25, 0x00	; 0
    639a:	0e 94 03 16 	call	0x2c06	; 0x2c06 <HWDelayus>
		NTRXSPIRead(NA_RamRtcReg_O + 1, rtc, 4);
    639e:	9e 01       	movw	r18, r28
    63a0:	29 5f       	subi	r18, 0xF9	; 249
    63a2:	3f 4f       	sbci	r19, 0xFF	; 255
    63a4:	81 ef       	ldi	r24, 0xF1	; 241
    63a6:	b9 01       	movw	r22, r18
    63a8:	44 e0       	ldi	r20, 0x04	; 4
    63aa:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
		reg = 0;
    63ae:	1a 82       	std	Y+2, r1	; 0x02
		NTRXSPIWriteByte(NA_RtcCmdRd_O, reg);
    63b0:	82 e6       	ldi	r24, 0x62	; 98
    63b2:	6a 81       	ldd	r22, Y+2	; 0x02
    63b4:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		/*update current RTC and hwclock entries*/
		currentRTC = (
    63b8:	8f 81       	ldd	r24, Y+7	; 0x07
    63ba:	28 2f       	mov	r18, r24
    63bc:	30 e0       	ldi	r19, 0x00	; 0
    63be:	40 e0       	ldi	r20, 0x00	; 0
    63c0:	50 e0       	ldi	r21, 0x00	; 0
    63c2:	88 85       	ldd	r24, Y+8	; 0x08
    63c4:	88 2f       	mov	r24, r24
    63c6:	90 e0       	ldi	r25, 0x00	; 0
    63c8:	a0 e0       	ldi	r26, 0x00	; 0
    63ca:	b0 e0       	ldi	r27, 0x00	; 0
    63cc:	ba 2f       	mov	r27, r26
    63ce:	a9 2f       	mov	r26, r25
    63d0:	98 2f       	mov	r25, r24
    63d2:	88 27       	eor	r24, r24
    63d4:	28 2b       	or	r18, r24
    63d6:	39 2b       	or	r19, r25
    63d8:	4a 2b       	or	r20, r26
    63da:	5b 2b       	or	r21, r27
    63dc:	89 85       	ldd	r24, Y+9	; 0x09
    63de:	88 2f       	mov	r24, r24
    63e0:	90 e0       	ldi	r25, 0x00	; 0
    63e2:	a0 e0       	ldi	r26, 0x00	; 0
    63e4:	b0 e0       	ldi	r27, 0x00	; 0
    63e6:	dc 01       	movw	r26, r24
    63e8:	99 27       	eor	r25, r25
    63ea:	88 27       	eor	r24, r24
    63ec:	28 2b       	or	r18, r24
    63ee:	39 2b       	or	r19, r25
    63f0:	4a 2b       	or	r20, r26
    63f2:	5b 2b       	or	r21, r27
    63f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    63f6:	88 2f       	mov	r24, r24
    63f8:	90 e0       	ldi	r25, 0x00	; 0
    63fa:	a0 e0       	ldi	r26, 0x00	; 0
    63fc:	b0 e0       	ldi	r27, 0x00	; 0
    63fe:	b8 2f       	mov	r27, r24
    6400:	aa 27       	eor	r26, r26
    6402:	99 27       	eor	r25, r25
    6404:	88 27       	eor	r24, r24
    6406:	82 2b       	or	r24, r18
    6408:	93 2b       	or	r25, r19
    640a:	a4 2b       	or	r26, r20
    640c:	b5 2b       	or	r27, r21
    640e:	80 93 87 0f 	sts	0x0F87, r24
    6412:	90 93 88 0f 	sts	0x0F88, r25
    6416:	a0 93 89 0f 	sts	0x0F89, r26
    641a:	b0 93 8a 0f 	sts	0x0F8A, r27
				| (((MyDword32T)rtc[2]) << 16)
				| (((MyDword32T)rtc[3]) << 24)
		);
		/*FIXME what can we do with the most significant byte?!*/
		//currentRTC = (currentRTC >> 7) | (rtc[5] << 1);
		currentHwclock = now;
    641e:	8b 81       	ldd	r24, Y+3	; 0x03
    6420:	9c 81       	ldd	r25, Y+4	; 0x04
    6422:	ad 81       	ldd	r26, Y+5	; 0x05
    6424:	be 81       	ldd	r27, Y+6	; 0x06
    6426:	80 93 a0 07 	sts	0x07A0, r24
    642a:	90 93 a1 07 	sts	0x07A1, r25
    642e:	a0 93 a2 07 	sts	0x07A2, r26
    6432:	b0 93 a3 07 	sts	0x07A3, r27
		LEAVE_TASK;
    6436:	ef e5       	ldi	r30, 0x5F	; 95
    6438:	f0 e0       	ldi	r31, 0x00	; 0
    643a:	89 81       	ldd	r24, Y+1	; 0x01
    643c:	80 83       	st	Z, r24
    643e:	78 94       	sei
	}
	return currentRTC;
    6440:	80 91 87 0f 	lds	r24, 0x0F87
    6444:	90 91 88 0f 	lds	r25, 0x0F88
    6448:	a0 91 89 0f 	lds	r26, 0x0F89
    644c:	b0 91 8a 0f 	lds	r27, 0x0F8A
}
    6450:	bc 01       	movw	r22, r24
    6452:	cd 01       	movw	r24, r26
    6454:	2c 96       	adiw	r28, 0x0c	; 12
    6456:	0f b6       	in	r0, 0x3f	; 63
    6458:	f8 94       	cli
    645a:	de bf       	out	0x3e, r29	; 62
    645c:	0f be       	out	0x3f, r0	; 63
    645e:	cd bf       	out	0x3d, r28	; 61
    6460:	cf 91       	pop	r28
    6462:	df 91       	pop	r29
    6464:	08 95       	ret

00006466 <NTRXPowerdownMode>:
 *
 */
/**************************************************************************/
void NTRXPowerdownMode (MyByte8T mode, MyDword32T seconds)
/**************************************************************************/
{
    6466:	ef 92       	push	r14
    6468:	ff 92       	push	r15
    646a:	0f 93       	push	r16
    646c:	1f 93       	push	r17
    646e:	df 93       	push	r29
    6470:	cf 93       	push	r28
    6472:	cd b7       	in	r28, 0x3d	; 61
    6474:	de b7       	in	r29, 0x3e	; 62
    6476:	2d 97       	sbiw	r28, 0x0d	; 13
    6478:	0f b6       	in	r0, 0x3f	; 63
    647a:	f8 94       	cli
    647c:	de bf       	out	0x3e, r29	; 62
    647e:	0f be       	out	0x3f, r0	; 63
    6480:	cd bf       	out	0x3d, r28	; 61
    6482:	89 87       	std	Y+9, r24	; 0x09
    6484:	4a 87       	std	Y+10, r20	; 0x0a
    6486:	5b 87       	std	Y+11, r21	; 0x0b
    6488:	6c 87       	std	Y+12, r22	; 0x0c
    648a:	7d 87       	std	Y+13, r23	; 0x0d
	MyByte8T 	value, valNull = 0;
    648c:	1f 82       	std	Y+7, r1	; 0x07
	MyByte8T 	i;
	MyByte8T 	wakeupTime8;
	MyDword32T wakeupTime32;

	/*Stop receiver*/
	NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    648e:	80 91 5c 0f 	lds	r24, 0x0F5C
    6492:	98 2f       	mov	r25, r24
    6494:	91 60       	ori	r25, 0x01	; 1
    6496:	86 e5       	ldi	r24, 0x56	; 86
    6498:	69 2f       	mov	r22, r25
    649a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	if (seconds > 0)
    649e:	8a 85       	ldd	r24, Y+10	; 0x0a
    64a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    64a2:	ac 85       	ldd	r26, Y+12	; 0x0c
    64a4:	bd 85       	ldd	r27, Y+13	; 0x0d
    64a6:	00 97       	sbiw	r24, 0x00	; 0
    64a8:	a1 05       	cpc	r26, r1
    64aa:	b1 05       	cpc	r27, r1
    64ac:	09 f4       	brne	.+2      	; 0x64b0 <NTRXPowerdownMode+0x4a>
    64ae:	5d c0       	rjmp	.+186    	; 0x656a <NTRXPowerdownMode+0x104>
	{
		wakeupTime32 = (seconds << 7) + NTRXGetRtc(TRUE);
    64b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    64b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    64b4:	ac 85       	ldd	r26, Y+12	; 0x0c
    64b6:	bd 85       	ldd	r27, Y+13	; 0x0d
    64b8:	88 0f       	add	r24, r24
    64ba:	99 1f       	adc	r25, r25
    64bc:	aa 1f       	adc	r26, r26
    64be:	bb 1f       	adc	r27, r27
    64c0:	88 0f       	add	r24, r24
    64c2:	99 1f       	adc	r25, r25
    64c4:	aa 1f       	adc	r26, r26
    64c6:	bb 1f       	adc	r27, r27
    64c8:	88 0f       	add	r24, r24
    64ca:	99 1f       	adc	r25, r25
    64cc:	aa 1f       	adc	r26, r26
    64ce:	bb 1f       	adc	r27, r27
    64d0:	88 0f       	add	r24, r24
    64d2:	99 1f       	adc	r25, r25
    64d4:	aa 1f       	adc	r26, r26
    64d6:	bb 1f       	adc	r27, r27
    64d8:	88 0f       	add	r24, r24
    64da:	99 1f       	adc	r25, r25
    64dc:	aa 1f       	adc	r26, r26
    64de:	bb 1f       	adc	r27, r27
    64e0:	88 0f       	add	r24, r24
    64e2:	99 1f       	adc	r25, r25
    64e4:	aa 1f       	adc	r26, r26
    64e6:	bb 1f       	adc	r27, r27
    64e8:	88 0f       	add	r24, r24
    64ea:	99 1f       	adc	r25, r25
    64ec:	aa 1f       	adc	r26, r26
    64ee:	bb 1f       	adc	r27, r27
    64f0:	7c 01       	movw	r14, r24
    64f2:	8d 01       	movw	r16, r26
    64f4:	81 e0       	ldi	r24, 0x01	; 1
    64f6:	0e 94 96 31 	call	0x632c	; 0x632c <NTRXGetRtc>
    64fa:	dc 01       	movw	r26, r24
    64fc:	cb 01       	movw	r24, r22
    64fe:	8e 0d       	add	r24, r14
    6500:	9f 1d       	adc	r25, r15
    6502:	a0 1f       	adc	r26, r16
    6504:	b1 1f       	adc	r27, r17
    6506:	89 83       	std	Y+1, r24	; 0x01
    6508:	9a 83       	std	Y+2, r25	; 0x02
    650a:	ab 83       	std	Y+3, r26	; 0x03
    650c:	bc 83       	std	Y+4, r27	; 0x04

		/*write down wake up time*/
		for (i = NA_WakeUpTimeWe_LSB; i <= NA_WakeUpTimeWe_MSB; i++)
    650e:	81 e0       	ldi	r24, 0x01	; 1
    6510:	8e 83       	std	Y+6, r24	; 0x06
    6512:	28 c0       	rjmp	.+80     	; 0x6564 <NTRXPowerdownMode+0xfe>
		{

			/*convert 32bit integer wakeup time -> RTC value*/
			wakeupTime8 = (MyByte8T)(wakeupTime32 & 0xFF);
    6514:	89 81       	ldd	r24, Y+1	; 0x01
    6516:	8d 83       	std	Y+5, r24	; 0x05
			wakeupTime32 >>= 8;
    6518:	89 81       	ldd	r24, Y+1	; 0x01
    651a:	9a 81       	ldd	r25, Y+2	; 0x02
    651c:	ab 81       	ldd	r26, Y+3	; 0x03
    651e:	bc 81       	ldd	r27, Y+4	; 0x04
    6520:	89 2f       	mov	r24, r25
    6522:	9a 2f       	mov	r25, r26
    6524:	ab 2f       	mov	r26, r27
    6526:	bb 27       	eor	r27, r27
    6528:	89 83       	std	Y+1, r24	; 0x01
    652a:	9a 83       	std	Y+2, r25	; 0x02
    652c:	ab 83       	std	Y+3, r26	; 0x03
    652e:	bc 83       	std	Y+4, r27	; 0x04

			/*write one of the 3 bytes into the RtcWakeUpTime Register*/
			NTRXSPIWriteByte( NA_WakeUpTimeByte_O, wakeupTime8 );
    6530:	81 e0       	ldi	r24, 0x01	; 1
    6532:	6d 81       	ldd	r22, Y+5	; 0x05
    6534:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

			/*generate Strobe to store value in the right place*/
			value = 1 << (i);
    6538:	8e 81       	ldd	r24, Y+6	; 0x06
    653a:	28 2f       	mov	r18, r24
    653c:	30 e0       	ldi	r19, 0x00	; 0
    653e:	81 e0       	ldi	r24, 0x01	; 1
    6540:	90 e0       	ldi	r25, 0x00	; 0
    6542:	02 c0       	rjmp	.+4      	; 0x6548 <NTRXPowerdownMode+0xe2>
    6544:	88 0f       	add	r24, r24
    6546:	99 1f       	adc	r25, r25
    6548:	2a 95       	dec	r18
    654a:	e2 f7       	brpl	.-8      	; 0x6544 <NTRXPowerdownMode+0xde>
    654c:	88 87       	std	Y+8, r24	; 0x08
			NTRXSPIWriteByte( NA_WakeUpTimeWe_O, value );
    654e:	82 e0       	ldi	r24, 0x02	; 2
    6550:	68 85       	ldd	r22, Y+8	; 0x08
    6552:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
			NTRXSPIWriteByte( NA_WakeUpTimeWe_O, valNull );
    6556:	82 e0       	ldi	r24, 0x02	; 2
    6558:	6f 81       	ldd	r22, Y+7	; 0x07
    655a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	if (seconds > 0)
	{
		wakeupTime32 = (seconds << 7) + NTRXGetRtc(TRUE);

		/*write down wake up time*/
		for (i = NA_WakeUpTimeWe_LSB; i <= NA_WakeUpTimeWe_MSB; i++)
    655e:	8e 81       	ldd	r24, Y+6	; 0x06
    6560:	8f 5f       	subi	r24, 0xFF	; 255
    6562:	8e 83       	std	Y+6, r24	; 0x06
    6564:	8e 81       	ldd	r24, Y+6	; 0x06
    6566:	84 30       	cpi	r24, 0x04	; 4
    6568:	a8 f2       	brcs	.-86     	; 0x6514 <NTRXPowerdownMode+0xae>
			NTRXSPIWriteByte( NA_WakeUpTimeWe_O, value );
			NTRXSPIWriteByte( NA_WakeUpTimeWe_O, valNull );
		}
	}

	value = ( 0x00 | ( 1 << NA_ResetBbClockGate_B ));
    656a:	82 e0       	ldi	r24, 0x02	; 2
    656c:	88 87       	std	Y+8, r24	; 0x08
	NTRXSPIWriteByte( NA_PowerDown_O, value );
    656e:	87 e0       	ldi	r24, 0x07	; 7
    6570:	68 85       	ldd	r22, Y+8	; 0x08
    6572:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	value = 0;
    6576:	18 86       	std	Y+8, r1	; 0x08
	NTRXSPIWriteByte( 0x8, value );
    6578:	88 e0       	ldi	r24, 0x08	; 8
    657a:	68 85       	ldd	r22, Y+8	; 0x08
    657c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	/*set wakeup parameter*/
	if (seconds > 0)
    6580:	8a 85       	ldd	r24, Y+10	; 0x0a
    6582:	9b 85       	ldd	r25, Y+11	; 0x0b
    6584:	ac 85       	ldd	r26, Y+12	; 0x0c
    6586:	bd 85       	ldd	r27, Y+13	; 0x0d
    6588:	00 97       	sbiw	r24, 0x00	; 0
    658a:	a1 05       	cpc	r26, r1
    658c:	b1 05       	cpc	r27, r1
    658e:	59 f0       	breq	.+22     	; 0x65a6 <NTRXPowerdownMode+0x140>
	{
		value = (0x00
    6590:	89 85       	ldd	r24, Y+9	; 0x09
    6592:	88 2f       	mov	r24, r24
    6594:	90 e0       	ldi	r25, 0x00	; 0
    6596:	96 95       	lsr	r25
    6598:	98 2f       	mov	r25, r24
    659a:	88 27       	eor	r24, r24
    659c:	97 95       	ror	r25
    659e:	87 95       	ror	r24
    65a0:	81 61       	ori	r24, 0x11	; 17
    65a2:	88 87       	std	Y+8, r24	; 0x08
    65a4:	09 c0       	rjmp	.+18     	; 0x65b8 <NTRXPowerdownMode+0x152>
			| ( 1 << NA_PowerUpTime_LSB )
			| (( 0x01 & mode ) << NA_PowerDownMode_B ));
	}
	else
	{
		value = (( 0x01 & mode ) << NA_PowerDownMode_B );
    65a6:	89 85       	ldd	r24, Y+9	; 0x09
    65a8:	88 2f       	mov	r24, r24
    65aa:	90 e0       	ldi	r25, 0x00	; 0
    65ac:	96 95       	lsr	r25
    65ae:	98 2f       	mov	r25, r24
    65b0:	88 27       	eor	r24, r24
    65b2:	97 95       	ror	r25
    65b4:	87 95       	ror	r24
    65b6:	88 87       	std	Y+8, r24	; 0x08
	}
	NTRXSPIWriteByte( NA_EnableWakeUpRtc_O, value );
    65b8:	86 e0       	ldi	r24, 0x06	; 6
    65ba:	68 85       	ldd	r22, Y+8	; 0x08
    65bc:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	value =(0x00
    65c0:	83 e0       	ldi	r24, 0x03	; 3
    65c2:	88 87       	std	Y+8, r24	; 0x08
  			| ( 1 << NA_PowerDown_B )
			| ( 1 << NA_ResetBbClockGate_B ));
	NTRXSPIWriteByte( NA_PowerDown_O, value );
    65c4:	87 e0       	ldi	r24, 0x07	; 7
    65c6:	68 85       	ldd	r22, Y+8	; 0x08
    65c8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    65cc:	2d 96       	adiw	r28, 0x0d	; 13
    65ce:	0f b6       	in	r0, 0x3f	; 63
    65d0:	f8 94       	cli
    65d2:	de bf       	out	0x3e, r29	; 62
    65d4:	0f be       	out	0x3f, r0	; 63
    65d6:	cd bf       	out	0x3d, r28	; 61
    65d8:	cf 91       	pop	r28
    65da:	df 91       	pop	r29
    65dc:	1f 91       	pop	r17
    65de:	0f 91       	pop	r16
    65e0:	ff 90       	pop	r15
    65e2:	ef 90       	pop	r14
    65e4:	08 95       	ret

000065e6 <NTRXStartBbTimer>:
 *
 */
/**************************************************************************/
void NTRXStartBbTimer (MyInt16T startvalue)
/**************************************************************************/
{
    65e6:	df 93       	push	r29
    65e8:	cf 93       	push	r28
    65ea:	00 d0       	rcall	.+0      	; 0x65ec <NTRXStartBbTimer+0x6>
    65ec:	cd b7       	in	r28, 0x3d	; 61
    65ee:	de b7       	in	r29, 0x3e	; 62
    65f0:	9a 83       	std	Y+2, r25	; 0x02
    65f2:	89 83       	std	Y+1, r24	; 0x01
    NTRXSPIWrite (NA_BasebandTimerStartValue_O, (MyByte8T *)(&startvalue), 2);
    65f4:	9e 01       	movw	r18, r28
    65f6:	2f 5f       	subi	r18, 0xFF	; 255
    65f8:	3f 4f       	sbci	r19, 0xFF	; 255
    65fa:	88 e2       	ldi	r24, 0x28	; 40
    65fc:	b9 01       	movw	r22, r18
    65fe:	42 e0       	ldi	r20, 0x02	; 2
    6600:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
}
    6604:	0f 90       	pop	r0
    6606:	0f 90       	pop	r0
    6608:	cf 91       	pop	r28
    660a:	df 91       	pop	r29
    660c:	08 95       	ret

0000660e <NTRXStopBbTimer>:
 *
 */
/**************************************************************************/
void NTRXStopBbTimer (void)
/**************************************************************************/
{
    660e:	df 93       	push	r29
    6610:	cf 93       	push	r28
    6612:	cd b7       	in	r28, 0x3d	; 61
    6614:	de b7       	in	r29, 0x3e	; 62
	NTRXSPIWriteByte (NA_ClearBasebandTimerInt_O, ntrxShadowReg[NA_ClearBasebandTimerInt_O] | (1 << NA_ClearBasebandTimerInt_B));
    6616:	80 91 18 0f 	lds	r24, 0x0F18
    661a:	98 2f       	mov	r25, r24
    661c:	90 68       	ori	r25, 0x80	; 128
    661e:	82 e1       	ldi	r24, 0x12	; 18
    6620:	69 2f       	mov	r22, r25
    6622:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
}
    6626:	cf 91       	pop	r28
    6628:	df 91       	pop	r29
    662a:	08 95       	ret

0000662c <NTRXSetTestChirpMode>:
 * recalibrated. Otherwise the frequency might be out of range.
 */
/**************************************************************************/
void NTRXSetTestChirpMode (MyBoolT value)
/**************************************************************************/
{
    662c:	df 93       	push	r29
    662e:	cf 93       	push	r28
    6630:	0f 92       	push	r0
    6632:	cd b7       	in	r28, 0x3d	; 61
    6634:	de b7       	in	r29, 0x3e	; 62
    6636:	89 83       	std	Y+1, r24	; 0x01
	NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    6638:	80 91 5c 0f 	lds	r24, 0x0F5C
    663c:	98 2f       	mov	r25, r24
    663e:	91 60       	ori	r25, 0x01	; 1
    6640:	86 e5       	ldi	r24, 0x56	; 86
    6642:	69 2f       	mov	r22, r25
    6644:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	NTRXSPIWriteByte (NA_RxIntsReset_O, 0x7f);
    6648:	81 e1       	ldi	r24, 0x11	; 17
    664a:	6f e7       	ldi	r22, 0x7F	; 127
    664c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	if (value == TRUE)
    6650:	89 81       	ldd	r24, Y+1	; 0x01
    6652:	81 30       	cpi	r24, 0x01	; 1
    6654:	c1 f5       	brne	.+112    	; 0x66c6 <NTRXSetTestChirpMode+0x9a>
	{
		ntrxShadowReg[NA_CsqUsePhaseShift_O] |= (1 << NA_CsqUsePhaseShift_B);
    6656:	80 91 43 0f 	lds	r24, 0x0F43
    665a:	84 60       	ori	r24, 0x04	; 4
    665c:	80 93 43 0f 	sts	0x0F43, r24
		NTRXSPIWriteByte (NA_CsqUsePhaseShift_O, ntrxShadowReg[NA_CsqUsePhaseShift_O]);
    6660:	90 91 43 0f 	lds	r25, 0x0F43
    6664:	8d e3       	ldi	r24, 0x3D	; 61
    6666:	69 2f       	mov	r22, r25
    6668:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableLO_O] |= ((1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B) | (1 << NA_EnableCsqClock_B));
    666c:	80 91 48 0f 	lds	r24, 0x0F48
    6670:	87 60       	ori	r24, 0x07	; 7
    6672:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    6676:	90 91 48 0f 	lds	r25, 0x0F48
    667a:	82 e4       	ldi	r24, 0x42	; 66
    667c:	69 2f       	mov	r22, r25
    667e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableTx_O] |= (1 << NA_EnableTx_B);
    6682:	80 91 2d 0f 	lds	r24, 0x0F2D
    6686:	80 68       	ori	r24, 0x80	; 128
    6688:	80 93 2d 0f 	sts	0x0F2D, r24
		NTRXSPIWriteByte (NA_EnableTx_O, ntrxShadowReg[NA_EnableTx_O]);
    668c:	90 91 2d 0f 	lds	r25, 0x0F2D
    6690:	87 e2       	ldi	r24, 0x27	; 39
    6692:	69 2f       	mov	r22, r25
    6694:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableExtPA_O] |= 0x20;
    6698:	80 91 48 0f 	lds	r24, 0x0F48
    669c:	80 62       	ori	r24, 0x20	; 32
    669e:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableExtPA_O, ntrxShadowReg[NA_EnableExtPA_O]);
    66a2:	90 91 48 0f 	lds	r25, 0x0F48
    66a6:	82 e4       	ldi	r24, 0x42	; 66
    66a8:	69 2f       	mov	r22, r25
    66aa:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqUseRam_O] |= 0x80;
    66ae:	80 91 43 0f 	lds	r24, 0x0F43
    66b2:	80 68       	ori	r24, 0x80	; 128
    66b4:	80 93 43 0f 	sts	0x0F43, r24
		NTRXSPIWriteByte (NA_CsqUseRam_O, ntrxShadowReg[NA_CsqUseRam_O]);
    66b8:	90 91 43 0f 	lds	r25, 0x0F43
    66bc:	8d e3       	ldi	r24, 0x3D	; 61
    66be:	69 2f       	mov	r22, r25
    66c0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    66c4:	41 c0       	rjmp	.+130    	; 0x6748 <NTRXSetTestChirpMode+0x11c>
	}
	else
	{
		ntrxShadowReg[NA_CsqUseRam_O] &= ~(0x80);
    66c6:	80 91 43 0f 	lds	r24, 0x0F43
    66ca:	8f 77       	andi	r24, 0x7F	; 127
    66cc:	80 93 43 0f 	sts	0x0F43, r24
		NTRXSPIWriteByte (NA_CsqUseRam_O, ntrxShadowReg[NA_CsqUseRam_O]);
    66d0:	90 91 43 0f 	lds	r25, 0x0F43
    66d4:	8d e3       	ldi	r24, 0x3D	; 61
    66d6:	69 2f       	mov	r22, r25
    66d8:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableExtPA_O] &= ~(0x20);
    66dc:	80 91 48 0f 	lds	r24, 0x0F48
    66e0:	8f 7d       	andi	r24, 0xDF	; 223
    66e2:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableExtPA_O, ntrxShadowReg[NA_EnableExtPA_O]);
    66e6:	90 91 48 0f 	lds	r25, 0x0F48
    66ea:	82 e4       	ldi	r24, 0x42	; 66
    66ec:	69 2f       	mov	r22, r25
    66ee:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableTx_O] &= ~(1 << NA_EnableTx_B);
    66f2:	80 91 2d 0f 	lds	r24, 0x0F2D
    66f6:	8f 77       	andi	r24, 0x7F	; 127
    66f8:	80 93 2d 0f 	sts	0x0F2D, r24
		NTRXSPIWriteByte (NA_EnableTx_O, ntrxShadowReg[NA_EnableTx_O]);
    66fc:	90 91 2d 0f 	lds	r25, 0x0F2D
    6700:	87 e2       	ldi	r24, 0x27	; 39
    6702:	69 2f       	mov	r22, r25
    6704:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableCsqClock_O] &= ~(1 << NA_EnableCsqClock_B);
    6708:	80 91 48 0f 	lds	r24, 0x0F48
    670c:	8b 7f       	andi	r24, 0xFB	; 251
    670e:	80 93 48 0f 	sts	0x0F48, r24
		ntrxShadowReg[NA_EnableLOdiv10_O] &= ~(1 << NA_EnableLOdiv10_B);
    6712:	80 91 48 0f 	lds	r24, 0x0F48
    6716:	8d 7f       	andi	r24, 0xFD	; 253
    6718:	80 93 48 0f 	sts	0x0F48, r24
		ntrxShadowReg[NA_EnableLO_O] &= ~(1 << NA_EnableLO_B);
    671c:	80 91 48 0f 	lds	r24, 0x0F48
    6720:	8e 7f       	andi	r24, 0xFE	; 254
    6722:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    6726:	90 91 48 0f 	lds	r25, 0x0F48
    672a:	82 e4       	ldi	r24, 0x42	; 66
    672c:	69 2f       	mov	r22, r25
    672e:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqUsePhaseShift_O] &= ~(1 << NA_CsqUsePhaseShift_B);
    6732:	80 91 43 0f 	lds	r24, 0x0F43
    6736:	8b 7f       	andi	r24, 0xFB	; 251
    6738:	80 93 43 0f 	sts	0x0F43, r24
		NTRXSPIWriteByte (NA_CsqUsePhaseShift_O, ntrxShadowReg[NA_CsqUsePhaseShift_O]);
    673c:	90 91 43 0f 	lds	r25, 0x0F43
    6740:	8d e3       	ldi	r24, 0x3D	; 61
    6742:	69 2f       	mov	r22, r25
    6744:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	}
}
    6748:	0f 90       	pop	r0
    674a:	cf 91       	pop	r28
    674c:	df 91       	pop	r29
    674e:	08 95       	ret

00006750 <NTRXSetTestCarrierMode>:
 * recalibrated. Otherwise the frequency might be out of range.
 */
/**************************************************************************/
void NTRXSetTestCarrierMode (MyBoolT value)
/**************************************************************************/
{
    6750:	df 93       	push	r29
    6752:	cf 93       	push	r28
    6754:	0f 92       	push	r0
    6756:	cd b7       	in	r28, 0x3d	; 61
    6758:	de b7       	in	r29, 0x3e	; 62
    675a:	89 83       	std	Y+1, r24	; 0x01
	static MyByte8T fdma;

	NTRXSPIWriteByte (NA_RxCmdStop_O, ntrxShadowReg[NA_RxCmdStop_O] | (1 << NA_RxCmdStop_B));
    675c:	80 91 5c 0f 	lds	r24, 0x0F5C
    6760:	98 2f       	mov	r25, r24
    6762:	91 60       	ori	r25, 0x01	; 1
    6764:	86 e5       	ldi	r24, 0x56	; 86
    6766:	69 2f       	mov	r22, r25
    6768:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	NTRXSPIWriteByte (NA_RxIntsReset_O, 0x7f);
    676c:	81 e1       	ldi	r24, 0x11	; 17
    676e:	6f e7       	ldi	r22, 0x7F	; 127
    6770:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	if (value == TRUE)
    6774:	89 81       	ldd	r24, Y+1	; 0x01
    6776:	81 30       	cpi	r24, 0x01	; 1
    6778:	09 f0       	breq	.+2      	; 0x677c <NTRXSetTestCarrierMode+0x2c>
    677a:	59 c0       	rjmp	.+178    	; 0x682e <NTRXSetTestCarrierMode+0xde>
	{
		fdma = ntrxShadowReg[NA_FdmaEnable_O];
    677c:	80 91 50 0f 	lds	r24, 0x0F50
    6780:	80 93 8b 0f 	sts	0x0F8B, r24
		ntrxShadowReg[NA_FdmaEnable_O] &= ~(1 << NA_FdmaEnable_B);
    6784:	80 91 50 0f 	lds	r24, 0x0F50
    6788:	8f 7e       	andi	r24, 0xEF	; 239
    678a:	80 93 50 0f 	sts	0x0F50, r24
		NTRXSPIWriteByte (NA_FdmaEnable_O, ntrxShadowReg[NA_FdmaEnable_O]);
    678e:	90 91 50 0f 	lds	r25, 0x0F50
    6792:	8a e4       	ldi	r24, 0x4A	; 74
    6794:	69 2f       	mov	r22, r25
    6796:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableLO_O] |= ((1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B));
    679a:	80 91 48 0f 	lds	r24, 0x0F48
    679e:	83 60       	ori	r24, 0x03	; 3
    67a0:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    67a4:	90 91 48 0f 	lds	r25, 0x0F48
    67a8:	82 e4       	ldi	r24, 0x42	; 66
    67aa:	69 2f       	mov	r22, r25
    67ac:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqSetValue_O] = 0x1F;
    67b0:	8f e1       	ldi	r24, 0x1F	; 31
    67b2:	80 93 44 0f 	sts	0x0F44, r24
		NTRXSPIWriteByte (NA_CsqSetValue_O, ntrxShadowReg[NA_CsqSetValue_O]);
    67b6:	90 91 44 0f 	lds	r25, 0x0F44
    67ba:	8e e3       	ldi	r24, 0x3E	; 62
    67bc:	69 2f       	mov	r22, r25
    67be:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqSetValue_O] |= (1 << 6);
    67c2:	80 91 44 0f 	lds	r24, 0x0F44
    67c6:	80 64       	ori	r24, 0x40	; 64
    67c8:	80 93 44 0f 	sts	0x0F44, r24
		NTRXSPIWriteByte (NA_CsqSetValue_O, ntrxShadowReg[NA_CsqSetValue_O]);
    67cc:	90 91 44 0f 	lds	r25, 0x0F44
    67d0:	8e e3       	ldi	r24, 0x3E	; 62
    67d2:	69 2f       	mov	r22, r25
    67d4:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqSetValue_O] = 0x3F;
    67d8:	8f e3       	ldi	r24, 0x3F	; 63
    67da:	80 93 44 0f 	sts	0x0F44, r24
		NTRXSPIWriteByte (NA_CsqSetValue_O, ntrxShadowReg[NA_CsqSetValue_O]);
    67de:	90 91 44 0f 	lds	r25, 0x0F44
    67e2:	8e e3       	ldi	r24, 0x3E	; 62
    67e4:	69 2f       	mov	r22, r25
    67e6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_CsqSetValue_O] |= (1 << 7);
    67ea:	80 91 44 0f 	lds	r24, 0x0F44
    67ee:	80 68       	ori	r24, 0x80	; 128
    67f0:	80 93 44 0f 	sts	0x0F44, r24
		NTRXSPIWriteByte (NA_CsqSetValue_O, ntrxShadowReg[NA_CsqSetValue_O]);
    67f4:	90 91 44 0f 	lds	r25, 0x0F44
    67f8:	8e e3       	ldi	r24, 0x3E	; 62
    67fa:	69 2f       	mov	r22, r25
    67fc:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableTx_O] |= ((1 << NA_EnableTx_B) | (0x07 << NA_ChirpFilterCaps_LSB));
    6800:	80 91 2d 0f 	lds	r24, 0x0F2D
    6804:	87 68       	ori	r24, 0x87	; 135
    6806:	80 93 2d 0f 	sts	0x0F2D, r24
		NTRXSPIWriteByte (NA_EnableTx_O, ntrxShadowReg[NA_EnableTx_O]);
    680a:	90 91 2d 0f 	lds	r25, 0x0F2D
    680e:	87 e2       	ldi	r24, 0x27	; 39
    6810:	69 2f       	mov	r22, r25
    6812:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableExtPA_O] |= 0x20;
    6816:	80 91 48 0f 	lds	r24, 0x0F48
    681a:	80 62       	ori	r24, 0x20	; 32
    681c:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableExtPA_O, ntrxShadowReg[NA_EnableExtPA_O]);
    6820:	90 91 48 0f 	lds	r25, 0x0F48
    6824:	82 e4       	ldi	r24, 0x42	; 66
    6826:	69 2f       	mov	r22, r25
    6828:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    682c:	2b c0       	rjmp	.+86     	; 0x6884 <NTRXSetTestCarrierMode+0x134>
	}
	else
	{
		ntrxShadowReg[NA_EnableExtPA_O] &= ~(0x20);
    682e:	80 91 48 0f 	lds	r24, 0x0F48
    6832:	8f 7d       	andi	r24, 0xDF	; 223
    6834:	80 93 48 0f 	sts	0x0F48, r24
		NTRXSPIWriteByte (NA_EnableExtPA_O, ntrxShadowReg[NA_EnableExtPA_O]);
    6838:	90 91 48 0f 	lds	r25, 0x0F48
    683c:	82 e4       	ldi	r24, 0x42	; 66
    683e:	69 2f       	mov	r22, r25
    6840:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_EnableTx_O] &= ~(1 << NA_EnableTx_B);
    6844:	80 91 2d 0f 	lds	r24, 0x0F2D
    6848:	8f 77       	andi	r24, 0x7F	; 127
    684a:	80 93 2d 0f 	sts	0x0F2D, r24
		NTRXSPIWriteByte (NA_EnableTx_O, ntrxShadowReg[NA_EnableTx_O]);
    684e:	90 91 2d 0f 	lds	r25, 0x0F2D
    6852:	87 e2       	ldi	r24, 0x27	; 39
    6854:	69 2f       	mov	r22, r25
    6856:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
		ntrxShadowReg[NA_EnableLO_O] &= ~((1 << NA_EnableLO_B)
    685a:	80 91 48 0f 	lds	r24, 0x0F48
    685e:	88 7f       	andi	r24, 0xF8	; 248
    6860:	80 93 48 0f 	sts	0x0F48, r24
											| (1 << NA_EnableLOdiv10_B)
											| (1 << NA_EnableCsqClock_B));
		NTRXSPIWriteByte (NA_EnableLO_O, ntrxShadowReg[NA_EnableLO_O]);
    6864:	90 91 48 0f 	lds	r25, 0x0F48
    6868:	82 e4       	ldi	r24, 0x42	; 66
    686a:	69 2f       	mov	r22, r25
    686c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_FdmaEnable_O] = fdma;
    6870:	80 91 8b 0f 	lds	r24, 0x0F8B
    6874:	80 93 50 0f 	sts	0x0F50, r24
		NTRXSPIWriteByte (NA_FdmaEnable_O, ntrxShadowReg[NA_FdmaEnable_O]);
    6878:	90 91 50 0f 	lds	r25, 0x0F50
    687c:	8a e4       	ldi	r24, 0x4A	; 74
    687e:	69 2f       	mov	r22, r25
    6880:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
	}
}
    6884:	0f 90       	pop	r0
    6886:	cf 91       	pop	r28
    6888:	df 91       	pop	r29
    688a:	08 95       	ret

0000688c <NTRXSetRxIqMatrix>:
 *
 */
/**************************************************************************/
void NTRXSetRxIqMatrix (MyByte8T bandwidth, MyByte8T symbolDur)
/**************************************************************************/
{
    688c:	df 93       	push	r29
    688e:	cf 93       	push	r28
    6890:	cd b7       	in	r28, 0x3d	; 61
    6892:	de b7       	in	r29, 0x3e	; 62
    6894:	cd 54       	subi	r28, 0x4D	; 77
    6896:	d0 40       	sbci	r29, 0x00	; 0
    6898:	0f b6       	in	r0, 0x3f	; 63
    689a:	f8 94       	cli
    689c:	de bf       	out	0x3e, r29	; 62
    689e:	0f be       	out	0x3f, r0	; 63
    68a0:	cd bf       	out	0x3d, r28	; 61
    68a2:	fe 01       	movw	r30, r28
    68a4:	e8 5b       	subi	r30, 0xB8	; 184
    68a6:	ff 4f       	sbci	r31, 0xFF	; 255
    68a8:	80 83       	st	Z, r24
    68aa:	fe 01       	movw	r30, r28
    68ac:	e7 5b       	subi	r30, 0xB7	; 183
    68ae:	ff 4f       	sbci	r31, 0xFF	; 255
    68b0:	60 83       	st	Z, r22
    MyByte8T tmpBuffer[64];
    MyByte8T *ptr = NULL;
    68b2:	1f 82       	std	Y+7, r1	; 0x07
    68b4:	1e 82       	std	Y+6, r1	; 0x06
    MyWord16T len;
    if (bandwidth == NA_22MHz)
    68b6:	fe 01       	movw	r30, r28
    68b8:	e8 5b       	subi	r30, 0xB8	; 184
    68ba:	ff 4f       	sbci	r31, 0xFF	; 255
    68bc:	80 81       	ld	r24, Z
    68be:	81 30       	cpi	r24, 0x01	; 1
    68c0:	71 f5       	brne	.+92     	; 0x691e <NTRXSetRxIqMatrix+0x92>
    {
        switch (symbolDur)
    68c2:	fe 01       	movw	r30, r28
    68c4:	e7 5b       	subi	r30, 0xB7	; 183
    68c6:	ff 4f       	sbci	r31, 0xFF	; 255
    68c8:	80 81       	ld	r24, Z
    68ca:	28 2f       	mov	r18, r24
    68cc:	30 e0       	ldi	r19, 0x00	; 0
    68ce:	2e 96       	adiw	r28, 0x0e	; 14
    68d0:	3f af       	std	Y+63, r19	; 0x3f
    68d2:	2e af       	std	Y+62, r18	; 0x3e
    68d4:	2e 97       	sbiw	r28, 0x0e	; 14
    68d6:	2e 96       	adiw	r28, 0x0e	; 14
    68d8:	8e ad       	ldd	r24, Y+62	; 0x3e
    68da:	9f ad       	ldd	r25, Y+63	; 0x3f
    68dc:	2e 97       	sbiw	r28, 0x0e	; 14
    68de:	82 30       	cpi	r24, 0x02	; 2
    68e0:	91 05       	cpc	r25, r1
    68e2:	a1 f0       	breq	.+40     	; 0x690c <NTRXSetRxIqMatrix+0x80>
    68e4:	2e 96       	adiw	r28, 0x0e	; 14
    68e6:	2e ad       	ldd	r18, Y+62	; 0x3e
    68e8:	3f ad       	ldd	r19, Y+63	; 0x3f
    68ea:	2e 97       	sbiw	r28, 0x0e	; 14
    68ec:	23 30       	cpi	r18, 0x03	; 3
    68ee:	31 05       	cpc	r19, r1
    68f0:	91 f0       	breq	.+36     	; 0x6916 <NTRXSetRxIqMatrix+0x8a>
    68f2:	2e 96       	adiw	r28, 0x0e	; 14
    68f4:	8e ad       	ldd	r24, Y+62	; 0x3e
    68f6:	9f ad       	ldd	r25, Y+63	; 0x3f
    68f8:	2e 97       	sbiw	r28, 0x0e	; 14
    68fa:	81 30       	cpi	r24, 0x01	; 1
    68fc:	91 05       	cpc	r25, r1
    68fe:	09 f0       	breq	.+2      	; 0x6902 <NTRXSetRxIqMatrix+0x76>
    6900:	9a c0       	rjmp	.+308    	; 0x6a36 <NTRXSetRxIqMatrix+0x1aa>
        {
#			ifdef CONFIG_NTRX_22MHZ_1000NS
            case NA_1us:   ptr = (MyByte8T *)NA5TR1_Rx_22MHz_1000ns; break;
    6902:	8a ea       	ldi	r24, 0xAA	; 170
    6904:	91 e0       	ldi	r25, 0x01	; 1
    6906:	9f 83       	std	Y+7, r25	; 0x07
    6908:	8e 83       	std	Y+6, r24	; 0x06
    690a:	09 c0       	rjmp	.+18     	; 0x691e <NTRXSetRxIqMatrix+0x92>
#			endif /* CONFIG_NTRX_22MHZ_1000NS */
#			ifdef CONFIG_NTRX_22MHZ_2000NS
             case NA_2us:   ptr = (MyByte8T *)NA5TR1_Rx_22MHz_2000ns; break;
    690c:	83 eb       	ldi	r24, 0xB3	; 179
    690e:	91 e0       	ldi	r25, 0x01	; 1
    6910:	9f 83       	std	Y+7, r25	; 0x07
    6912:	8e 83       	std	Y+6, r24	; 0x06
    6914:	04 c0       	rjmp	.+8      	; 0x691e <NTRXSetRxIqMatrix+0x92>
#			endif /* CONFIG_NTRX_22MHZ_2000NS */
#			ifdef CONFIG_NTRX_22MHZ_4000NS
            case NA_4us:   ptr = (MyByte8T *)NA5TR1_Rx_22MHz_4000ns; break;
    6916:	84 ec       	ldi	r24, 0xC4	; 196
    6918:	91 e0       	ldi	r25, 0x01	; 1
    691a:	9f 83       	std	Y+7, r25	; 0x07
    691c:	8e 83       	std	Y+6, r24	; 0x06
#			endif /* CONFIG_NTRX_22MHZ_4000NS */
            default: return;
        }
    }
    if (bandwidth == NA_80MHz)
    691e:	fe 01       	movw	r30, r28
    6920:	e8 5b       	subi	r30, 0xB8	; 184
    6922:	ff 4f       	sbci	r31, 0xFF	; 255
    6924:	80 81       	ld	r24, Z
    6926:	88 23       	and	r24, r24
    6928:	09 f0       	breq	.+2      	; 0x692c <NTRXSetRxIqMatrix+0xa0>
    692a:	41 c0       	rjmp	.+130    	; 0x69ae <NTRXSetRxIqMatrix+0x122>
    {
        switch (symbolDur)
    692c:	fe 01       	movw	r30, r28
    692e:	e7 5b       	subi	r30, 0xB7	; 183
    6930:	ff 4f       	sbci	r31, 0xFF	; 255
    6932:	80 81       	ld	r24, Z
    6934:	28 2f       	mov	r18, r24
    6936:	30 e0       	ldi	r19, 0x00	; 0
    6938:	2c 96       	adiw	r28, 0x0c	; 12
    693a:	3f af       	std	Y+63, r19	; 0x3f
    693c:	2e af       	std	Y+62, r18	; 0x3e
    693e:	2c 97       	sbiw	r28, 0x0c	; 12
    6940:	2c 96       	adiw	r28, 0x0c	; 12
    6942:	8e ad       	ldd	r24, Y+62	; 0x3e
    6944:	9f ad       	ldd	r25, Y+63	; 0x3f
    6946:	2c 97       	sbiw	r28, 0x0c	; 12
    6948:	81 30       	cpi	r24, 0x01	; 1
    694a:	91 05       	cpc	r25, r1
    694c:	11 f1       	breq	.+68     	; 0x6992 <NTRXSetRxIqMatrix+0x106>
    694e:	2c 96       	adiw	r28, 0x0c	; 12
    6950:	2e ad       	ldd	r18, Y+62	; 0x3e
    6952:	3f ad       	ldd	r19, Y+63	; 0x3f
    6954:	2c 97       	sbiw	r28, 0x0c	; 12
    6956:	22 30       	cpi	r18, 0x02	; 2
    6958:	31 05       	cpc	r19, r1
    695a:	3c f4       	brge	.+14     	; 0x696a <NTRXSetRxIqMatrix+0xde>
    695c:	2c 96       	adiw	r28, 0x0c	; 12
    695e:	8e ad       	ldd	r24, Y+62	; 0x3e
    6960:	9f ad       	ldd	r25, Y+63	; 0x3f
    6962:	2c 97       	sbiw	r28, 0x0c	; 12
    6964:	00 97       	sbiw	r24, 0x00	; 0
    6966:	81 f0       	breq	.+32     	; 0x6988 <NTRXSetRxIqMatrix+0xfc>
    6968:	66 c0       	rjmp	.+204    	; 0x6a36 <NTRXSetRxIqMatrix+0x1aa>
    696a:	2c 96       	adiw	r28, 0x0c	; 12
    696c:	2e ad       	ldd	r18, Y+62	; 0x3e
    696e:	3f ad       	ldd	r19, Y+63	; 0x3f
    6970:	2c 97       	sbiw	r28, 0x0c	; 12
    6972:	22 30       	cpi	r18, 0x02	; 2
    6974:	31 05       	cpc	r19, r1
    6976:	91 f0       	breq	.+36     	; 0x699c <NTRXSetRxIqMatrix+0x110>
    6978:	2c 96       	adiw	r28, 0x0c	; 12
    697a:	8e ad       	ldd	r24, Y+62	; 0x3e
    697c:	9f ad       	ldd	r25, Y+63	; 0x3f
    697e:	2c 97       	sbiw	r28, 0x0c	; 12
    6980:	83 30       	cpi	r24, 0x03	; 3
    6982:	91 05       	cpc	r25, r1
    6984:	81 f0       	breq	.+32     	; 0x69a6 <NTRXSetRxIqMatrix+0x11a>
    6986:	57 c0       	rjmp	.+174    	; 0x6a36 <NTRXSetRxIqMatrix+0x1aa>
        {
#			ifdef CONFIG_NTRX_80MHZ_500NS
            case NA_500ns: ptr = (MyByte8T *)NA5TR1_Rx_80MHz_500ns; break;
    6988:	88 ef       	ldi	r24, 0xF8	; 248
    698a:	90 e0       	ldi	r25, 0x00	; 0
    698c:	9f 83       	std	Y+7, r25	; 0x07
    698e:	8e 83       	std	Y+6, r24	; 0x06
    6990:	0e c0       	rjmp	.+28     	; 0x69ae <NTRXSetRxIqMatrix+0x122>
#			endif /* CONFIG_NTRX_80MHZ_500NS */
#			ifdef CONFIG_NTRX_80MHZ_1000NS
            case NA_1us:   ptr = (MyByte8T *)NA5TR1_Rx_80MHz_1000ns; break;
    6992:	89 e0       	ldi	r24, 0x09	; 9
    6994:	91 e0       	ldi	r25, 0x01	; 1
    6996:	9f 83       	std	Y+7, r25	; 0x07
    6998:	8e 83       	std	Y+6, r24	; 0x06
    699a:	09 c0       	rjmp	.+18     	; 0x69ae <NTRXSetRxIqMatrix+0x122>
#			endif /* CONFIG_NTRX_80MHZ_1000NS */
#			ifdef CONFIG_NTRX_80MHZ_2000NS
            case NA_2us:   ptr = (MyByte8T *)NA5TR1_Rx_80MHz_2000ns; break;
    699c:	8a e2       	ldi	r24, 0x2A	; 42
    699e:	91 e0       	ldi	r25, 0x01	; 1
    69a0:	9f 83       	std	Y+7, r25	; 0x07
    69a2:	8e 83       	std	Y+6, r24	; 0x06
    69a4:	04 c0       	rjmp	.+8      	; 0x69ae <NTRXSetRxIqMatrix+0x122>
#			endif /* CONFIG_NTRX_80MHZ_2000NS */
#			ifdef CONFIG_NTRX_80MHZ_4000NS
            case NA_4us:   ptr = (MyByte8T *)NA5TR1_Rx_80MHz_4000ns; break;
    69a6:	89 e6       	ldi	r24, 0x69	; 105
    69a8:	91 e0       	ldi	r25, 0x01	; 1
    69aa:	9f 83       	std	Y+7, r25	; 0x07
    69ac:	8e 83       	std	Y+6, r24	; 0x06
#			endif /* CONFIG_NTRX_80MHZ_4000NS */
            default: return;
        }
    }

    len = ReadRomByte (ptr[0]);
    69ae:	8e 81       	ldd	r24, Y+6	; 0x06
    69b0:	9f 81       	ldd	r25, Y+7	; 0x07
    69b2:	9b 83       	std	Y+3, r25	; 0x03
    69b4:	8a 83       	std	Y+2, r24	; 0x02
    69b6:	ea 81       	ldd	r30, Y+2	; 0x02
    69b8:	fb 81       	ldd	r31, Y+3	; 0x03
    69ba:	84 91       	lpm	r24, Z+
    69bc:	89 83       	std	Y+1, r24	; 0x01
    69be:	89 81       	ldd	r24, Y+1	; 0x01
    69c0:	88 2f       	mov	r24, r24
    69c2:	90 e0       	ldi	r25, 0x00	; 0
    69c4:	9d 83       	std	Y+5, r25	; 0x05
    69c6:	8c 83       	std	Y+4, r24	; 0x04
    /* Device select 3 */
    memcpy_P (tmpBuffer, &(ptr[1]), len);
    69c8:	8e 81       	ldd	r24, Y+6	; 0x06
    69ca:	9f 81       	ldd	r25, Y+7	; 0x07
    69cc:	ac 01       	movw	r20, r24
    69ce:	4f 5f       	subi	r20, 0xFF	; 255
    69d0:	5f 4f       	sbci	r21, 0xFF	; 255
    69d2:	ce 01       	movw	r24, r28
    69d4:	08 96       	adiw	r24, 0x08	; 8
    69d6:	2c 81       	ldd	r18, Y+4	; 0x04
    69d8:	3d 81       	ldd	r19, Y+5	; 0x05
    69da:	ba 01       	movw	r22, r20
    69dc:	a9 01       	movw	r20, r18
    69de:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSetIndexReg (0x30);
    69e2:	80 e3       	ldi	r24, 0x30	; 48
    69e4:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
    NTRXSPIWrite ((NA_RamD3lPatI_O & 0xff),     tmpBuffer, len);
    69e8:	9c 81       	ldd	r25, Y+4	; 0x04
    69ea:	9e 01       	movw	r18, r28
    69ec:	28 5f       	subi	r18, 0xF8	; 248
    69ee:	3f 4f       	sbci	r19, 0xFF	; 255
    69f0:	80 e8       	ldi	r24, 0x80	; 128
    69f2:	b9 01       	movw	r22, r18
    69f4:	49 2f       	mov	r20, r25
    69f6:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

    memcpy_P (tmpBuffer, &(ptr[1+ len]), len);
    69fa:	8c 81       	ldd	r24, Y+4	; 0x04
    69fc:	9d 81       	ldd	r25, Y+5	; 0x05
    69fe:	9c 01       	movw	r18, r24
    6a00:	2f 5f       	subi	r18, 0xFF	; 255
    6a02:	3f 4f       	sbci	r19, 0xFF	; 255
    6a04:	8e 81       	ldd	r24, Y+6	; 0x06
    6a06:	9f 81       	ldd	r25, Y+7	; 0x07
    6a08:	ac 01       	movw	r20, r24
    6a0a:	42 0f       	add	r20, r18
    6a0c:	53 1f       	adc	r21, r19
    6a0e:	ce 01       	movw	r24, r28
    6a10:	08 96       	adiw	r24, 0x08	; 8
    6a12:	2c 81       	ldd	r18, Y+4	; 0x04
    6a14:	3d 81       	ldd	r19, Y+5	; 0x05
    6a16:	ba 01       	movw	r22, r20
    6a18:	a9 01       	movw	r20, r18
    6a1a:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSetIndexReg (0x31);
    6a1e:	81 e3       	ldi	r24, 0x31	; 49
    6a20:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
    NTRXSPIWrite ((NA_RamD3lPatQ_O & 0xff),     tmpBuffer, len);
    6a24:	9c 81       	ldd	r25, Y+4	; 0x04
    6a26:	9e 01       	movw	r18, r28
    6a28:	28 5f       	subi	r18, 0xF8	; 248
    6a2a:	3f 4f       	sbci	r19, 0xFF	; 255
    6a2c:	80 e8       	ldi	r24, 0x80	; 128
    6a2e:	b9 01       	movw	r22, r18
    6a30:	49 2f       	mov	r20, r25
    6a32:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
}
    6a36:	c3 5b       	subi	r28, 0xB3	; 179
    6a38:	df 4f       	sbci	r29, 0xFF	; 255
    6a3a:	0f b6       	in	r0, 0x3f	; 63
    6a3c:	f8 94       	cli
    6a3e:	de bf       	out	0x3e, r29	; 62
    6a40:	0f be       	out	0x3f, r0	; 63
    6a42:	cd bf       	out	0x3d, r28	; 61
    6a44:	cf 91       	pop	r28
    6a46:	df 91       	pop	r29
    6a48:	08 95       	ret

00006a4a <NTRXSetTxIqMatrix>:
 * This function initializes the iq parameter for the transmitter depending
 * on the bandwidth and symbol duration.
 *
 */
void NTRXSetTxIqMatrix (MyByte8T bandwidth, MyByte8T symbolDur)
{
    6a4a:	df 93       	push	r29
    6a4c:	cf 93       	push	r28
    6a4e:	cd b7       	in	r28, 0x3d	; 61
    6a50:	de b7       	in	r29, 0x3e	; 62
    6a52:	c6 51       	subi	r28, 0x16	; 22
    6a54:	d1 40       	sbci	r29, 0x01	; 1
    6a56:	0f b6       	in	r0, 0x3f	; 63
    6a58:	f8 94       	cli
    6a5a:	de bf       	out	0x3e, r29	; 62
    6a5c:	0f be       	out	0x3f, r0	; 63
    6a5e:	cd bf       	out	0x3d, r28	; 61
    6a60:	fe 01       	movw	r30, r28
    6a62:	ef 5e       	subi	r30, 0xEF	; 239
    6a64:	fe 4f       	sbci	r31, 0xFE	; 254
    6a66:	80 83       	st	Z, r24
    6a68:	fe 01       	movw	r30, r28
    6a6a:	ee 5e       	subi	r30, 0xEE	; 238
    6a6c:	fe 4f       	sbci	r31, 0xFE	; 254
    6a6e:	60 83       	st	Z, r22
    MyByte8T tmpBuffer[245];
    MyWord16T len;
    MyWord16T offset;
    MyByte8T *ptr = NULL;
    6a70:	1f 8a       	std	Y+23, r1	; 0x17
    6a72:	1e 8a       	std	Y+22, r1	; 0x16

    if (bandwidth == NA_22MHz)
    6a74:	fe 01       	movw	r30, r28
    6a76:	ef 5e       	subi	r30, 0xEF	; 239
    6a78:	fe 4f       	sbci	r31, 0xFE	; 254
    6a7a:	80 81       	ld	r24, Z
    6a7c:	81 30       	cpi	r24, 0x01	; 1
    6a7e:	b1 f5       	brne	.+108    	; 0x6aec <NTRXSetTxIqMatrix+0xa2>
    {
        switch (symbolDur)
    6a80:	fe 01       	movw	r30, r28
    6a82:	ee 5e       	subi	r30, 0xEE	; 238
    6a84:	fe 4f       	sbci	r31, 0xFE	; 254
    6a86:	80 81       	ld	r24, Z
    6a88:	28 2f       	mov	r18, r24
    6a8a:	30 e0       	ldi	r19, 0x00	; 0
    6a8c:	cb 5e       	subi	r28, 0xEB	; 235
    6a8e:	de 4f       	sbci	r29, 0xFE	; 254
    6a90:	39 83       	std	Y+1, r19	; 0x01
    6a92:	28 83       	st	Y, r18
    6a94:	c5 51       	subi	r28, 0x15	; 21
    6a96:	d1 40       	sbci	r29, 0x01	; 1
    6a98:	cb 5e       	subi	r28, 0xEB	; 235
    6a9a:	de 4f       	sbci	r29, 0xFE	; 254
    6a9c:	88 81       	ld	r24, Y
    6a9e:	99 81       	ldd	r25, Y+1	; 0x01
    6aa0:	c5 51       	subi	r28, 0x15	; 21
    6aa2:	d1 40       	sbci	r29, 0x01	; 1
    6aa4:	82 30       	cpi	r24, 0x02	; 2
    6aa6:	91 05       	cpc	r25, r1
    6aa8:	c1 f0       	breq	.+48     	; 0x6ada <NTRXSetTxIqMatrix+0x90>
    6aaa:	cb 5e       	subi	r28, 0xEB	; 235
    6aac:	de 4f       	sbci	r29, 0xFE	; 254
    6aae:	28 81       	ld	r18, Y
    6ab0:	39 81       	ldd	r19, Y+1	; 0x01
    6ab2:	c5 51       	subi	r28, 0x15	; 21
    6ab4:	d1 40       	sbci	r29, 0x01	; 1
    6ab6:	23 30       	cpi	r18, 0x03	; 3
    6ab8:	31 05       	cpc	r19, r1
    6aba:	a1 f0       	breq	.+40     	; 0x6ae4 <NTRXSetTxIqMatrix+0x9a>
    6abc:	cb 5e       	subi	r28, 0xEB	; 235
    6abe:	de 4f       	sbci	r29, 0xFE	; 254
    6ac0:	88 81       	ld	r24, Y
    6ac2:	99 81       	ldd	r25, Y+1	; 0x01
    6ac4:	c5 51       	subi	r28, 0x15	; 21
    6ac6:	d1 40       	sbci	r29, 0x01	; 1
    6ac8:	81 30       	cpi	r24, 0x01	; 1
    6aca:	91 05       	cpc	r25, r1
    6acc:	09 f0       	breq	.+2      	; 0x6ad0 <NTRXSetTxIqMatrix+0x86>
    6ace:	a6 c1       	rjmp	.+844    	; 0x6e1c <NTRXSetTxIqMatrix+0x3d2>
        {
#			ifdef CONFIG_NTRX_22MHZ_1000NS
            case NA_1us:   ptr = (MyByte8T *)NA5TR1_Tx_22MHz_1000ns; break;
    6ad0:	81 ea       	ldi	r24, 0xA1	; 161
    6ad2:	97 e0       	ldi	r25, 0x07	; 7
    6ad4:	9f 8b       	std	Y+23, r25	; 0x17
    6ad6:	8e 8b       	std	Y+22, r24	; 0x16
    6ad8:	09 c0       	rjmp	.+18     	; 0x6aec <NTRXSetTxIqMatrix+0xa2>
#			endif /* CONFIG_NTRX_22MHZ_1000NS */
#			ifdef CONFIG_NTRX_22MHZ_2000NS
            case NA_2us:   ptr = (MyByte8T *)NA5TR1_Tx_22MHz_2000ns; break;
    6ada:	8a eb       	ldi	r24, 0xBA	; 186
    6adc:	97 e0       	ldi	r25, 0x07	; 7
    6ade:	9f 8b       	std	Y+23, r25	; 0x17
    6ae0:	8e 8b       	std	Y+22, r24	; 0x16
    6ae2:	04 c0       	rjmp	.+8      	; 0x6aec <NTRXSetTxIqMatrix+0xa2>
#			endif /* CONFIG_NTRX_22MHZ_2000NS */
#			ifdef CONFIG_NTRX_22MHZ_4000NS
            case NA_4us:   ptr = (MyByte8T *)NA5TR1_Tx_22MHz_4000ns; break;
    6ae4:	8b ee       	ldi	r24, 0xEB	; 235
    6ae6:	97 e0       	ldi	r25, 0x07	; 7
    6ae8:	9f 8b       	std	Y+23, r25	; 0x17
    6aea:	8e 8b       	std	Y+22, r24	; 0x16
#			endif /* CONFIG_NTRX_22MHZ_4000NS */
            default: return;
        }
    }
    if (bandwidth == NA_80MHz)
    6aec:	fe 01       	movw	r30, r28
    6aee:	ef 5e       	subi	r30, 0xEF	; 239
    6af0:	fe 4f       	sbci	r31, 0xFE	; 254
    6af2:	80 81       	ld	r24, Z
    6af4:	88 23       	and	r24, r24
    6af6:	09 f0       	breq	.+2      	; 0x6afa <NTRXSetTxIqMatrix+0xb0>
    6af8:	4d c0       	rjmp	.+154    	; 0x6b94 <NTRXSetTxIqMatrix+0x14a>
    {
        switch (symbolDur)
    6afa:	fe 01       	movw	r30, r28
    6afc:	ee 5e       	subi	r30, 0xEE	; 238
    6afe:	fe 4f       	sbci	r31, 0xFE	; 254
    6b00:	80 81       	ld	r24, Z
    6b02:	28 2f       	mov	r18, r24
    6b04:	30 e0       	ldi	r19, 0x00	; 0
    6b06:	cd 5e       	subi	r28, 0xED	; 237
    6b08:	de 4f       	sbci	r29, 0xFE	; 254
    6b0a:	39 83       	std	Y+1, r19	; 0x01
    6b0c:	28 83       	st	Y, r18
    6b0e:	c3 51       	subi	r28, 0x13	; 19
    6b10:	d1 40       	sbci	r29, 0x01	; 1
    6b12:	cd 5e       	subi	r28, 0xED	; 237
    6b14:	de 4f       	sbci	r29, 0xFE	; 254
    6b16:	88 81       	ld	r24, Y
    6b18:	99 81       	ldd	r25, Y+1	; 0x01
    6b1a:	c3 51       	subi	r28, 0x13	; 19
    6b1c:	d1 40       	sbci	r29, 0x01	; 1
    6b1e:	81 30       	cpi	r24, 0x01	; 1
    6b20:	91 05       	cpc	r25, r1
    6b22:	51 f1       	breq	.+84     	; 0x6b78 <NTRXSetTxIqMatrix+0x12e>
    6b24:	cd 5e       	subi	r28, 0xED	; 237
    6b26:	de 4f       	sbci	r29, 0xFE	; 254
    6b28:	28 81       	ld	r18, Y
    6b2a:	39 81       	ldd	r19, Y+1	; 0x01
    6b2c:	c3 51       	subi	r28, 0x13	; 19
    6b2e:	d1 40       	sbci	r29, 0x01	; 1
    6b30:	22 30       	cpi	r18, 0x02	; 2
    6b32:	31 05       	cpc	r19, r1
    6b34:	4c f4       	brge	.+18     	; 0x6b48 <NTRXSetTxIqMatrix+0xfe>
    6b36:	cd 5e       	subi	r28, 0xED	; 237
    6b38:	de 4f       	sbci	r29, 0xFE	; 254
    6b3a:	88 81       	ld	r24, Y
    6b3c:	99 81       	ldd	r25, Y+1	; 0x01
    6b3e:	c3 51       	subi	r28, 0x13	; 19
    6b40:	d1 40       	sbci	r29, 0x01	; 1
    6b42:	00 97       	sbiw	r24, 0x00	; 0
    6b44:	a1 f0       	breq	.+40     	; 0x6b6e <NTRXSetTxIqMatrix+0x124>
    6b46:	6a c1       	rjmp	.+724    	; 0x6e1c <NTRXSetTxIqMatrix+0x3d2>
    6b48:	cd 5e       	subi	r28, 0xED	; 237
    6b4a:	de 4f       	sbci	r29, 0xFE	; 254
    6b4c:	28 81       	ld	r18, Y
    6b4e:	39 81       	ldd	r19, Y+1	; 0x01
    6b50:	c3 51       	subi	r28, 0x13	; 19
    6b52:	d1 40       	sbci	r29, 0x01	; 1
    6b54:	22 30       	cpi	r18, 0x02	; 2
    6b56:	31 05       	cpc	r19, r1
    6b58:	a1 f0       	breq	.+40     	; 0x6b82 <NTRXSetTxIqMatrix+0x138>
    6b5a:	cd 5e       	subi	r28, 0xED	; 237
    6b5c:	de 4f       	sbci	r29, 0xFE	; 254
    6b5e:	88 81       	ld	r24, Y
    6b60:	99 81       	ldd	r25, Y+1	; 0x01
    6b62:	c3 51       	subi	r28, 0x13	; 19
    6b64:	d1 40       	sbci	r29, 0x01	; 1
    6b66:	83 30       	cpi	r24, 0x03	; 3
    6b68:	91 05       	cpc	r25, r1
    6b6a:	81 f0       	breq	.+32     	; 0x6b8c <NTRXSetTxIqMatrix+0x142>
    6b6c:	57 c1       	rjmp	.+686    	; 0x6e1c <NTRXSetTxIqMatrix+0x3d2>
        {
#			ifdef CONFIG_NTRX_80MHZ_500NS
            case NA_500ns: ptr = (MyByte8T *)NA5TR1_Tx_80MHz_500ns; break;
    6b6e:	85 ee       	ldi	r24, 0xE5	; 229
    6b70:	91 e0       	ldi	r25, 0x01	; 1
    6b72:	9f 8b       	std	Y+23, r25	; 0x17
    6b74:	8e 8b       	std	Y+22, r24	; 0x16
    6b76:	0e c0       	rjmp	.+28     	; 0x6b94 <NTRXSetTxIqMatrix+0x14a>
#			endif /* CONFIG_NTRX_80MHZ_500NS */
#			ifdef CONFIG_NTRX_80MHZ_1000NS
            case NA_1us:   ptr = (MyByte8T *)NA5TR1_Tx_80MHz_1000ns; break;
    6b78:	8d e9       	ldi	r24, 0x9D	; 157
    6b7a:	92 e0       	ldi	r25, 0x02	; 2
    6b7c:	9f 8b       	std	Y+23, r25	; 0x17
    6b7e:	8e 8b       	std	Y+22, r24	; 0x16
    6b80:	09 c0       	rjmp	.+18     	; 0x6b94 <NTRXSetTxIqMatrix+0x14a>
#			endif /* CONFIG_NTRX_80MHZ_1000NS */
#			ifdef CONFIG_NTRX_80MHZ_2000NS
            case NA_2us:   ptr = (MyByte8T *)NA5TR1_Tx_80MHz_2000ns; break;
    6b82:	85 e5       	ldi	r24, 0x55	; 85
    6b84:	93 e0       	ldi	r25, 0x03	; 3
    6b86:	9f 8b       	std	Y+23, r25	; 0x17
    6b88:	8e 8b       	std	Y+22, r24	; 0x16
    6b8a:	04 c0       	rjmp	.+8      	; 0x6b94 <NTRXSetTxIqMatrix+0x14a>
#			endif /* CONFIG_NTRX_80MHZ_2000NS */
#			ifdef CONFIG_NTRX_80MHZ_4000NS
            case NA_4us:   ptr = (MyByte8T *)NA5TR1_Tx_80MHz_4000ns; break;
    6b8c:	84 ec       	ldi	r24, 0xC4	; 196
    6b8e:	94 e0       	ldi	r25, 0x04	; 4
    6b90:	9f 8b       	std	Y+23, r25	; 0x17
    6b92:	8e 8b       	std	Y+22, r24	; 0x16
#			endif /* CONFIG_NTRX_80MHZ_4000NS */
            default: return;
        }
    }

    len = ReadRomByte (ptr[0]);
    6b94:	8e 89       	ldd	r24, Y+22	; 0x16
    6b96:	9f 89       	ldd	r25, Y+23	; 0x17
    6b98:	9d 8b       	std	Y+21, r25	; 0x15
    6b9a:	8c 8b       	std	Y+20, r24	; 0x14
    6b9c:	ec 89       	ldd	r30, Y+20	; 0x14
    6b9e:	fd 89       	ldd	r31, Y+21	; 0x15
    6ba0:	84 91       	lpm	r24, Z+
    6ba2:	8b 8b       	std	Y+19, r24	; 0x13
    6ba4:	8b 89       	ldd	r24, Y+19	; 0x13
    6ba6:	88 2f       	mov	r24, r24
    6ba8:	90 e0       	ldi	r25, 0x00	; 0
    6baa:	9b 8f       	std	Y+27, r25	; 0x1b
    6bac:	8a 8f       	std	Y+26, r24	; 0x1a

    NTRXSetIndexReg (0x20);
    6bae:	80 e2       	ldi	r24, 0x20	; 32
    6bb0:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>

	NTRXSPIWriteByte (NA_CsqMemAddrInit_O, ntrxShadowReg[NA_CsqMemAddrInit_O] | (1 << NA_CsqMemAddrInit_B));
    6bb4:	80 91 43 0f 	lds	r24, 0x0F43
    6bb8:	98 2f       	mov	r25, r24
    6bba:	90 62       	ori	r25, 0x20	; 32
    6bbc:	8d e3       	ldi	r24, 0x3D	; 61
    6bbe:	69 2f       	mov	r22, r25
    6bc0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    offset = 0;
    6bc4:	19 8e       	std	Y+25, r1	; 0x19
    6bc6:	18 8e       	std	Y+24, r1	; 0x18
    if (len > 128)
    6bc8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6bca:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6bcc:	81 38       	cpi	r24, 0x81	; 129
    6bce:	91 05       	cpc	r25, r1
    6bd0:	f0 f0       	brcs	.+60     	; 0x6c0e <NTRXSetTxIqMatrix+0x1c4>
    {
        len -= 128;
    6bd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6bd4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6bd6:	80 58       	subi	r24, 0x80	; 128
    6bd8:	90 40       	sbci	r25, 0x00	; 0
    6bda:	9b 8f       	std	Y+27, r25	; 0x1b
    6bdc:	8a 8f       	std	Y+26, r24	; 0x1a
        memcpy_P (tmpBuffer, &(ptr[1]), 128);
    6bde:	8e 89       	ldd	r24, Y+22	; 0x16
    6be0:	9f 89       	ldd	r25, Y+23	; 0x17
    6be2:	9c 01       	movw	r18, r24
    6be4:	2f 5f       	subi	r18, 0xFF	; 255
    6be6:	3f 4f       	sbci	r19, 0xFF	; 255
    6be8:	ce 01       	movw	r24, r28
    6bea:	4c 96       	adiw	r24, 0x1c	; 28
    6bec:	b9 01       	movw	r22, r18
    6bee:	40 e8       	ldi	r20, 0x80	; 128
    6bf0:	50 e0       	ldi	r21, 0x00	; 0
    6bf2:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
        NTRXSPIWrite (0x80, tmpBuffer, 128);
    6bf6:	9e 01       	movw	r18, r28
    6bf8:	24 5e       	subi	r18, 0xE4	; 228
    6bfa:	3f 4f       	sbci	r19, 0xFF	; 255
    6bfc:	80 e8       	ldi	r24, 0x80	; 128
    6bfe:	b9 01       	movw	r22, r18
    6c00:	40 e8       	ldi	r20, 0x80	; 128
    6c02:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
        offset = 128;
    6c06:	80 e8       	ldi	r24, 0x80	; 128
    6c08:	90 e0       	ldi	r25, 0x00	; 0
    6c0a:	99 8f       	std	Y+25, r25	; 0x19
    6c0c:	88 8f       	std	Y+24, r24	; 0x18
    }
    memcpy_P (tmpBuffer, &(ptr[1 + offset]), len);
    6c0e:	88 8d       	ldd	r24, Y+24	; 0x18
    6c10:	99 8d       	ldd	r25, Y+25	; 0x19
    6c12:	9c 01       	movw	r18, r24
    6c14:	2f 5f       	subi	r18, 0xFF	; 255
    6c16:	3f 4f       	sbci	r19, 0xFF	; 255
    6c18:	8e 89       	ldd	r24, Y+22	; 0x16
    6c1a:	9f 89       	ldd	r25, Y+23	; 0x17
    6c1c:	ac 01       	movw	r20, r24
    6c1e:	42 0f       	add	r20, r18
    6c20:	53 1f       	adc	r21, r19
    6c22:	ce 01       	movw	r24, r28
    6c24:	4c 96       	adiw	r24, 0x1c	; 28
    6c26:	2a 8d       	ldd	r18, Y+26	; 0x1a
    6c28:	3b 8d       	ldd	r19, Y+27	; 0x1b
    6c2a:	ba 01       	movw	r22, r20
    6c2c:	a9 01       	movw	r20, r18
    6c2e:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSPIWrite (0x80, tmpBuffer, len);
    6c32:	9a 8d       	ldd	r25, Y+26	; 0x1a
    6c34:	9e 01       	movw	r18, r28
    6c36:	24 5e       	subi	r18, 0xE4	; 228
    6c38:	3f 4f       	sbci	r19, 0xFF	; 255
    6c3a:	80 e8       	ldi	r24, 0x80	; 128
    6c3c:	b9 01       	movw	r22, r18
    6c3e:	49 2f       	mov	r20, r25
    6c40:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

	NTRXSPIWriteByte (NA_CsqMemAddrInit_O, ntrxShadowReg[NA_CsqMemAddrInit_O] | (1 << NA_CsqMemAddrInit_B));
    6c44:	80 91 43 0f 	lds	r24, 0x0F43
    6c48:	98 2f       	mov	r25, r24
    6c4a:	90 62       	ori	r25, 0x20	; 32
    6c4c:	8d e3       	ldi	r24, 0x3D	; 61
    6c4e:	69 2f       	mov	r22, r25
    6c50:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    NTRXSetIndexReg (0x21);
    6c54:	81 e2       	ldi	r24, 0x21	; 33
    6c56:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
    offset = 0;
    6c5a:	19 8e       	std	Y+25, r1	; 0x19
    6c5c:	18 8e       	std	Y+24, r1	; 0x18
    len = ReadRomByte (ptr[0]);
    6c5e:	8e 89       	ldd	r24, Y+22	; 0x16
    6c60:	9f 89       	ldd	r25, Y+23	; 0x17
    6c62:	9a 8b       	std	Y+18, r25	; 0x12
    6c64:	89 8b       	std	Y+17, r24	; 0x11
    6c66:	e9 89       	ldd	r30, Y+17	; 0x11
    6c68:	fa 89       	ldd	r31, Y+18	; 0x12
    6c6a:	84 91       	lpm	r24, Z+
    6c6c:	88 8b       	std	Y+16, r24	; 0x10
    6c6e:	88 89       	ldd	r24, Y+16	; 0x10
    6c70:	88 2f       	mov	r24, r24
    6c72:	90 e0       	ldi	r25, 0x00	; 0
    6c74:	9b 8f       	std	Y+27, r25	; 0x1b
    6c76:	8a 8f       	std	Y+26, r24	; 0x1a
    if (len > 128)
    6c78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6c7a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6c7c:	81 38       	cpi	r24, 0x81	; 129
    6c7e:	91 05       	cpc	r25, r1
    6c80:	58 f1       	brcs	.+86     	; 0x6cd8 <NTRXSetTxIqMatrix+0x28e>
    {
        len -= 128;
    6c82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6c84:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6c86:	80 58       	subi	r24, 0x80	; 128
    6c88:	90 40       	sbci	r25, 0x00	; 0
    6c8a:	9b 8f       	std	Y+27, r25	; 0x1b
    6c8c:	8a 8f       	std	Y+26, r24	; 0x1a
        memcpy_P (tmpBuffer, &(ptr[1 + ReadRomByte (ptr[0])]), 128);
    6c8e:	8e 89       	ldd	r24, Y+22	; 0x16
    6c90:	9f 89       	ldd	r25, Y+23	; 0x17
    6c92:	9f 87       	std	Y+15, r25	; 0x0f
    6c94:	8e 87       	std	Y+14, r24	; 0x0e
    6c96:	ee 85       	ldd	r30, Y+14	; 0x0e
    6c98:	ff 85       	ldd	r31, Y+15	; 0x0f
    6c9a:	84 91       	lpm	r24, Z+
    6c9c:	8d 87       	std	Y+13, r24	; 0x0d
    6c9e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ca0:	88 2f       	mov	r24, r24
    6ca2:	90 e0       	ldi	r25, 0x00	; 0
    6ca4:	9c 01       	movw	r18, r24
    6ca6:	2f 5f       	subi	r18, 0xFF	; 255
    6ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    6caa:	8e 89       	ldd	r24, Y+22	; 0x16
    6cac:	9f 89       	ldd	r25, Y+23	; 0x17
    6cae:	28 0f       	add	r18, r24
    6cb0:	39 1f       	adc	r19, r25
    6cb2:	ce 01       	movw	r24, r28
    6cb4:	4c 96       	adiw	r24, 0x1c	; 28
    6cb6:	b9 01       	movw	r22, r18
    6cb8:	40 e8       	ldi	r20, 0x80	; 128
    6cba:	50 e0       	ldi	r21, 0x00	; 0
    6cbc:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
        NTRXSPIWrite (0x80, tmpBuffer, 128);
    6cc0:	9e 01       	movw	r18, r28
    6cc2:	24 5e       	subi	r18, 0xE4	; 228
    6cc4:	3f 4f       	sbci	r19, 0xFF	; 255
    6cc6:	80 e8       	ldi	r24, 0x80	; 128
    6cc8:	b9 01       	movw	r22, r18
    6cca:	40 e8       	ldi	r20, 0x80	; 128
    6ccc:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
        offset = 128;
    6cd0:	80 e8       	ldi	r24, 0x80	; 128
    6cd2:	90 e0       	ldi	r25, 0x00	; 0
    6cd4:	99 8f       	std	Y+25, r25	; 0x19
    6cd6:	88 8f       	std	Y+24, r24	; 0x18
    }
    memcpy_P (tmpBuffer, &(ptr[1 + ReadRomByte (ptr[0]) + offset]), len);
    6cd8:	8e 89       	ldd	r24, Y+22	; 0x16
    6cda:	9f 89       	ldd	r25, Y+23	; 0x17
    6cdc:	9c 87       	std	Y+12, r25	; 0x0c
    6cde:	8b 87       	std	Y+11, r24	; 0x0b
    6ce0:	eb 85       	ldd	r30, Y+11	; 0x0b
    6ce2:	fc 85       	ldd	r31, Y+12	; 0x0c
    6ce4:	84 91       	lpm	r24, Z+
    6ce6:	8a 87       	std	Y+10, r24	; 0x0a
    6ce8:	8a 85       	ldd	r24, Y+10	; 0x0a
    6cea:	28 2f       	mov	r18, r24
    6cec:	30 e0       	ldi	r19, 0x00	; 0
    6cee:	88 8d       	ldd	r24, Y+24	; 0x18
    6cf0:	99 8d       	ldd	r25, Y+25	; 0x19
    6cf2:	82 0f       	add	r24, r18
    6cf4:	93 1f       	adc	r25, r19
    6cf6:	9c 01       	movw	r18, r24
    6cf8:	2f 5f       	subi	r18, 0xFF	; 255
    6cfa:	3f 4f       	sbci	r19, 0xFF	; 255
    6cfc:	8e 89       	ldd	r24, Y+22	; 0x16
    6cfe:	9f 89       	ldd	r25, Y+23	; 0x17
    6d00:	ac 01       	movw	r20, r24
    6d02:	42 0f       	add	r20, r18
    6d04:	53 1f       	adc	r21, r19
    6d06:	ce 01       	movw	r24, r28
    6d08:	4c 96       	adiw	r24, 0x1c	; 28
    6d0a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    6d0c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    6d0e:	ba 01       	movw	r22, r20
    6d10:	a9 01       	movw	r20, r18
    6d12:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSPIWrite (0x80, tmpBuffer, len);
    6d16:	9a 8d       	ldd	r25, Y+26	; 0x1a
    6d18:	9e 01       	movw	r18, r28
    6d1a:	24 5e       	subi	r18, 0xE4	; 228
    6d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    6d1e:	80 e8       	ldi	r24, 0x80	; 128
    6d20:	b9 01       	movw	r22, r18
    6d22:	49 2f       	mov	r20, r25
    6d24:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

	NTRXSPIWriteByte (NA_CsqMemAddrInit_O, ntrxShadowReg[NA_CsqMemAddrInit_O] | (1 << NA_CsqMemAddrInit_B));
    6d28:	80 91 43 0f 	lds	r24, 0x0F43
    6d2c:	98 2f       	mov	r25, r24
    6d2e:	90 62       	ori	r25, 0x20	; 32
    6d30:	8d e3       	ldi	r24, 0x3D	; 61
    6d32:	69 2f       	mov	r22, r25
    6d34:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    NTRXSetIndexReg (0x22);
    6d38:	82 e2       	ldi	r24, 0x22	; 34
    6d3a:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>

    len = ReadRomByte (ptr[0]);
    6d3e:	8e 89       	ldd	r24, Y+22	; 0x16
    6d40:	9f 89       	ldd	r25, Y+23	; 0x17
    6d42:	99 87       	std	Y+9, r25	; 0x09
    6d44:	88 87       	std	Y+8, r24	; 0x08
    6d46:	e8 85       	ldd	r30, Y+8	; 0x08
    6d48:	f9 85       	ldd	r31, Y+9	; 0x09
    6d4a:	84 91       	lpm	r24, Z+
    6d4c:	8f 83       	std	Y+7, r24	; 0x07
    6d4e:	8f 81       	ldd	r24, Y+7	; 0x07
    6d50:	88 2f       	mov	r24, r24
    6d52:	90 e0       	ldi	r25, 0x00	; 0
    6d54:	9b 8f       	std	Y+27, r25	; 0x1b
    6d56:	8a 8f       	std	Y+26, r24	; 0x1a
    offset = 0;
    6d58:	19 8e       	std	Y+25, r1	; 0x19
    6d5a:	18 8e       	std	Y+24, r1	; 0x18
    if (len > 128)
    6d5c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d5e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d60:	81 38       	cpi	r24, 0x81	; 129
    6d62:	91 05       	cpc	r25, r1
    6d64:	68 f1       	brcs	.+90     	; 0x6dc0 <NTRXSetTxIqMatrix+0x376>
    {
         len -= 128;
    6d66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d68:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d6a:	80 58       	subi	r24, 0x80	; 128
    6d6c:	90 40       	sbci	r25, 0x00	; 0
    6d6e:	9b 8f       	std	Y+27, r25	; 0x1b
    6d70:	8a 8f       	std	Y+26, r24	; 0x1a
        memcpy_P (tmpBuffer, &(ptr[1 + (2 * ReadRomByte (ptr[0]))]), 128);
    6d72:	8e 89       	ldd	r24, Y+22	; 0x16
    6d74:	9f 89       	ldd	r25, Y+23	; 0x17
    6d76:	9e 83       	std	Y+6, r25	; 0x06
    6d78:	8d 83       	std	Y+5, r24	; 0x05
    6d7a:	ed 81       	ldd	r30, Y+5	; 0x05
    6d7c:	fe 81       	ldd	r31, Y+6	; 0x06
    6d7e:	84 91       	lpm	r24, Z+
    6d80:	8c 83       	std	Y+4, r24	; 0x04
    6d82:	8c 81       	ldd	r24, Y+4	; 0x04
    6d84:	88 2f       	mov	r24, r24
    6d86:	90 e0       	ldi	r25, 0x00	; 0
    6d88:	88 0f       	add	r24, r24
    6d8a:	99 1f       	adc	r25, r25
    6d8c:	9c 01       	movw	r18, r24
    6d8e:	2f 5f       	subi	r18, 0xFF	; 255
    6d90:	3f 4f       	sbci	r19, 0xFF	; 255
    6d92:	8e 89       	ldd	r24, Y+22	; 0x16
    6d94:	9f 89       	ldd	r25, Y+23	; 0x17
    6d96:	28 0f       	add	r18, r24
    6d98:	39 1f       	adc	r19, r25
    6d9a:	ce 01       	movw	r24, r28
    6d9c:	4c 96       	adiw	r24, 0x1c	; 28
    6d9e:	b9 01       	movw	r22, r18
    6da0:	40 e8       	ldi	r20, 0x80	; 128
    6da2:	50 e0       	ldi	r21, 0x00	; 0
    6da4:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
        NTRXSPIWrite (0x80, tmpBuffer, 128);
    6da8:	9e 01       	movw	r18, r28
    6daa:	24 5e       	subi	r18, 0xE4	; 228
    6dac:	3f 4f       	sbci	r19, 0xFF	; 255
    6dae:	80 e8       	ldi	r24, 0x80	; 128
    6db0:	b9 01       	movw	r22, r18
    6db2:	40 e8       	ldi	r20, 0x80	; 128
    6db4:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
        offset = 128;
    6db8:	80 e8       	ldi	r24, 0x80	; 128
    6dba:	90 e0       	ldi	r25, 0x00	; 0
    6dbc:	99 8f       	std	Y+25, r25	; 0x19
    6dbe:	88 8f       	std	Y+24, r24	; 0x18
    }
    memcpy_P (tmpBuffer, &(ptr[1 + (2 * ReadRomByte (ptr[0])) + offset]), len);
    6dc0:	8e 89       	ldd	r24, Y+22	; 0x16
    6dc2:	9f 89       	ldd	r25, Y+23	; 0x17
    6dc4:	9b 83       	std	Y+3, r25	; 0x03
    6dc6:	8a 83       	std	Y+2, r24	; 0x02
    6dc8:	ea 81       	ldd	r30, Y+2	; 0x02
    6dca:	fb 81       	ldd	r31, Y+3	; 0x03
    6dcc:	84 91       	lpm	r24, Z+
    6dce:	89 83       	std	Y+1, r24	; 0x01
    6dd0:	89 81       	ldd	r24, Y+1	; 0x01
    6dd2:	88 2f       	mov	r24, r24
    6dd4:	90 e0       	ldi	r25, 0x00	; 0
    6dd6:	88 0f       	add	r24, r24
    6dd8:	99 1f       	adc	r25, r25
    6dda:	9c 01       	movw	r18, r24
    6ddc:	88 8d       	ldd	r24, Y+24	; 0x18
    6dde:	99 8d       	ldd	r25, Y+25	; 0x19
    6de0:	82 0f       	add	r24, r18
    6de2:	93 1f       	adc	r25, r19
    6de4:	9c 01       	movw	r18, r24
    6de6:	2f 5f       	subi	r18, 0xFF	; 255
    6de8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dea:	8e 89       	ldd	r24, Y+22	; 0x16
    6dec:	9f 89       	ldd	r25, Y+23	; 0x17
    6dee:	ac 01       	movw	r20, r24
    6df0:	42 0f       	add	r20, r18
    6df2:	53 1f       	adc	r21, r19
    6df4:	ce 01       	movw	r24, r28
    6df6:	4c 96       	adiw	r24, 0x1c	; 28
    6df8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    6dfa:	3b 8d       	ldd	r19, Y+27	; 0x1b
    6dfc:	ba 01       	movw	r22, r20
    6dfe:	a9 01       	movw	r20, r18
    6e00:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSPIWrite (0x80, tmpBuffer, len);
    6e04:	9a 8d       	ldd	r25, Y+26	; 0x1a
    6e06:	9e 01       	movw	r18, r28
    6e08:	24 5e       	subi	r18, 0xE4	; 228
    6e0a:	3f 4f       	sbci	r19, 0xFF	; 255
    6e0c:	80 e8       	ldi	r24, 0x80	; 128
    6e0e:	b9 01       	movw	r22, r18
    6e10:	49 2f       	mov	r20, r25
    6e12:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>

    NTRXSetIndexReg (0x00);
    6e16:	80 e0       	ldi	r24, 0x00	; 0
    6e18:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
}
    6e1c:	ca 5e       	subi	r28, 0xEA	; 234
    6e1e:	de 4f       	sbci	r29, 0xFE	; 254
    6e20:	0f b6       	in	r0, 0x3f	; 63
    6e22:	f8 94       	cli
    6e24:	de bf       	out	0x3e, r29	; 62
    6e26:	0f be       	out	0x3f, r0	; 63
    6e28:	cd bf       	out	0x3d, r28	; 61
    6e2a:	cf 91       	pop	r28
    6e2c:	df 91       	pop	r29
    6e2e:	08 95       	ret

00006e30 <NTRXSetAgcValues>:
 *
 * This function initializes the agc values for a specific mode.
 *
 */
void NTRXSetAgcValues (MyByte8T bandwidth, MyByte8T symbolDur, MyByte8T symbolRate)
{
    6e30:	df 93       	push	r29
    6e32:	cf 93       	push	r28
    6e34:	00 d0       	rcall	.+0      	; 0x6e36 <NTRXSetAgcValues+0x6>
    6e36:	0f 92       	push	r0
    6e38:	cd b7       	in	r28, 0x3d	; 61
    6e3a:	de b7       	in	r29, 0x3e	; 62
    6e3c:	89 83       	std	Y+1, r24	; 0x01
    6e3e:	6a 83       	std	Y+2, r22	; 0x02
    6e40:	4b 83       	std	Y+3, r20	; 0x03
    if (bandwidth == NA_80MHz)
    6e42:	89 81       	ldd	r24, Y+1	; 0x01
    6e44:	88 23       	and	r24, r24
    6e46:	d9 f4       	brne	.+54     	; 0x6e7e <NTRXSetAgcValues+0x4e>
    {
		ntrxShadowReg[NA_FdmaEnable_O] &= ~(1 << NA_FdmaEnable_B);
    6e48:	80 91 50 0f 	lds	r24, 0x0F50
    6e4c:	8f 7e       	andi	r24, 0xEF	; 239
    6e4e:	80 93 50 0f 	sts	0x0F50, r24
		NTRXSPIWriteByte (NA_FdmaEnable_O, ntrxShadowReg[NA_FdmaEnable_O]);
    6e52:	90 91 50 0f 	lds	r25, 0x0F50
    6e56:	8a e4       	ldi	r24, 0x4A	; 74
    6e58:	69 2f       	mov	r22, r25
    6e5a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_PulseDetDelay_O] &= ~(0x3f << NA_PulseDetDelay_LSB);
    6e5e:	80 91 62 0f 	lds	r24, 0x0F62
    6e62:	80 7c       	andi	r24, 0xC0	; 192
    6e64:	80 93 62 0f 	sts	0x0F62, r24
		ntrxShadowReg[NA_PulseDetDelay_O] |= (4 << NA_PulseDetDelay_LSB);
    6e68:	80 91 62 0f 	lds	r24, 0x0F62
    6e6c:	84 60       	ori	r24, 0x04	; 4
    6e6e:	80 93 62 0f 	sts	0x0F62, r24
		NTRXSPIWriteByte (NA_PulseDetDelay_O, ntrxShadowReg[NA_PulseDetDelay_O]);
    6e72:	90 91 62 0f 	lds	r25, 0x0F62
    6e76:	8c e5       	ldi	r24, 0x5C	; 92
    6e78:	69 2f       	mov	r22, r25
    6e7a:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    }
	ntrxShadowReg[NA_AgcHold_O] |= (1 << NA_AgcHold_B);
    6e7e:	80 91 2b 0f 	lds	r24, 0x0F2B
    6e82:	80 68       	ori	r24, 0x80	; 128
    6e84:	80 93 2b 0f 	sts	0x0F2B, r24
	NTRXSPIWriteByte (NA_AgcHold_O, ntrxShadowReg[NA_AgcHold_O]);
    6e88:	90 91 2b 0f 	lds	r25, 0x0F2B
    6e8c:	85 e2       	ldi	r24, 0x25	; 37
    6e8e:	69 2f       	mov	r22, r25
    6e90:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_AgcDefaultEn_O] |= (1 << NA_AgcDefaultEn_B);
    6e94:	80 91 2b 0f 	lds	r24, 0x0F2B
    6e98:	80 64       	ori	r24, 0x40	; 64
    6e9a:	80 93 2b 0f 	sts	0x0F2B, r24
	NTRXSPIWriteByte (NA_AgcDefaultEn_O, ntrxShadowReg[NA_AgcDefaultEn_O]);
    6e9e:	90 91 2b 0f 	lds	r25, 0x0F2B
    6ea2:	85 e2       	ldi	r24, 0x25	; 37
    6ea4:	69 2f       	mov	r22, r25
    6ea6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_AgcValue_O] &= ~(0x3f << NA_AgcValue_LSB);
    6eaa:	80 91 2b 0f 	lds	r24, 0x0F2B
    6eae:	80 7c       	andi	r24, 0xC0	; 192
    6eb0:	80 93 2b 0f 	sts	0x0F2B, r24
	ntrxShadowReg[NA_AgcValue_O] |= (35 << NA_AgcValue_LSB);
    6eb4:	80 91 2b 0f 	lds	r24, 0x0F2B
    6eb8:	83 62       	ori	r24, 0x23	; 35
    6eba:	80 93 2b 0f 	sts	0x0F2B, r24
	NTRXSPIWriteByte (NA_AgcValue_O, ntrxShadowReg[NA_AgcValue_O]);
    6ebe:	90 91 2b 0f 	lds	r25, 0x0F2B
    6ec2:	85 e2       	ldi	r24, 0x25	; 37
    6ec4:	69 2f       	mov	r22, r25
    6ec6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_AgcRangeOffset_O] &= ~(0x0f << NA_AgcRangeOffset_LSB);
    6eca:	80 91 6a 0f 	lds	r24, 0x0F6A
    6ece:	80 7f       	andi	r24, 0xF0	; 240
    6ed0:	80 93 6a 0f 	sts	0x0F6A, r24
	ntrxShadowReg[NA_AgcRangeOffset_O] |= (12 << NA_AgcRangeOffset_LSB);
    6ed4:	80 91 6a 0f 	lds	r24, 0x0F6A
    6ed8:	8c 60       	ori	r24, 0x0C	; 12
    6eda:	80 93 6a 0f 	sts	0x0F6A, r24
	NTRXSPIWriteByte (NA_AgcRangeOffset_O, ntrxShadowReg[NA_AgcRangeOffset_O]);
    6ede:	90 91 6a 0f 	lds	r25, 0x0F6A
    6ee2:	84 e6       	ldi	r24, 0x64	; 100
    6ee4:	69 2f       	mov	r22, r25
    6ee6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    if (bandwidth == NA_22MHz)
    6eea:	89 81       	ldd	r24, Y+1	; 0x01
    6eec:	81 30       	cpi	r24, 0x01	; 1
    6eee:	d9 f4       	brne	.+54     	; 0x6f26 <NTRXSetAgcValues+0xf6>
    {
		ntrxShadowReg[NA_FdmaEnable_O] |= (1 << NA_FdmaEnable_B);
    6ef0:	80 91 50 0f 	lds	r24, 0x0F50
    6ef4:	80 61       	ori	r24, 0x10	; 16
    6ef6:	80 93 50 0f 	sts	0x0F50, r24
		NTRXSPIWriteByte (NA_FdmaEnable_O, ntrxShadowReg[NA_FdmaEnable_O]);
    6efa:	90 91 50 0f 	lds	r25, 0x0F50
    6efe:	8a e4       	ldi	r24, 0x4A	; 74
    6f00:	69 2f       	mov	r22, r25
    6f02:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

		ntrxShadowReg[NA_PulseDetDelay_O] &= ~(0x1f << NA_PulseDetDelay_LSB);
    6f06:	80 91 62 0f 	lds	r24, 0x0F62
    6f0a:	80 7e       	andi	r24, 0xE0	; 224
    6f0c:	80 93 62 0f 	sts	0x0F62, r24
		ntrxShadowReg[NA_PulseDetDelay_O] |= (2 << NA_PulseDetDelay_LSB);
    6f10:	80 91 62 0f 	lds	r24, 0x0F62
    6f14:	82 60       	ori	r24, 0x02	; 2
    6f16:	80 93 62 0f 	sts	0x0F62, r24
		NTRXSPIWriteByte (NA_PulseDetDelay_O, ntrxShadowReg[NA_PulseDetDelay_O]);
    6f1a:	90 91 62 0f 	lds	r25, 0x0F62
    6f1e:	8c e5       	ldi	r24, 0x5C	; 92
    6f20:	69 2f       	mov	r22, r25
    6f22:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>
    }

	ntrxShadowReg[NA_LnaFreqAdjust_O] &= ~(0x03 << NA_LnaFreqAdjust_LSB);
    6f26:	80 91 49 0f 	lds	r24, 0x0F49
    6f2a:	8c 7f       	andi	r24, 0xFC	; 252
    6f2c:	80 93 49 0f 	sts	0x0F49, r24
	NTRXSPIWriteByte (NA_LnaFreqAdjust_O, ntrxShadowReg[NA_LnaFreqAdjust_O]);
    6f30:	90 91 49 0f 	lds	r25, 0x0F49
    6f34:	83 e4       	ldi	r24, 0x43	; 67
    6f36:	69 2f       	mov	r22, r25
    6f38:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_GateSizeFramesync_O] &= ~(0x03 << NA_GateSizeFramesync_LSB);
    6f3c:	80 91 64 0f 	lds	r24, 0x0F64
    6f40:	8f 7c       	andi	r24, 0xCF	; 207
    6f42:	80 93 64 0f 	sts	0x0F64, r24
	ntrxShadowReg[NA_GateSizeFramesync_O] |= (NA_GateSize5Slots_VC_C << NA_GateSizeFramesync_LSB);
    6f46:	80 91 64 0f 	lds	r24, 0x0F64
    6f4a:	80 61       	ori	r24, 0x10	; 16
    6f4c:	80 93 64 0f 	sts	0x0F64, r24
	NTRXSPIWriteByte (NA_GateSizeFramesync_O, ntrxShadowReg[NA_GateSizeFramesync_O]);
    6f50:	90 91 64 0f 	lds	r25, 0x0F64
    6f54:	8e e5       	ldi	r24, 0x5E	; 94
    6f56:	69 2f       	mov	r22, r25
    6f58:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

    /*select 0: MAP (maximum a posteriori) mode (peak detection)
     *    or 1: FIX mode (threshold detection)
     */
	ntrxShadowReg[NA_D3lFixnMap_O] &= ~(1 << NA_D3lFixnMap_B);
    6f5c:	80 91 45 0f 	lds	r24, 0x0F45
    6f60:	8e 7f       	andi	r24, 0xFE	; 254
    6f62:	80 93 45 0f 	sts	0x0F45, r24
	ntrxShadowReg[NA_D3lFixnMap_O] |= (modeSet.fixnmap << NA_D3lFixnMap_B);
    6f66:	90 91 45 0f 	lds	r25, 0x0F45
    6f6a:	80 91 f5 0e 	lds	r24, 0x0EF5
    6f6e:	89 2b       	or	r24, r25
    6f70:	80 93 45 0f 	sts	0x0F45, r24
	NTRXSPIWriteByte (NA_D3lFixnMap_O, ntrxShadowReg[NA_D3lFixnMap_O]);
    6f74:	90 91 45 0f 	lds	r25, 0x0F45
    6f78:	8f e3       	ldi	r24, 0x3F	; 63
    6f7a:	69 2f       	mov	r22, r25
    6f7c:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

	ntrxShadowReg[NA_SymbolDur_O] &= ~((0x07 << NA_SymbolDur_LSB) | (0x07 << NA_SymbolRate_LSB));
    6f80:	80 91 4e 0f 	lds	r24, 0x0F4E
    6f84:	88 78       	andi	r24, 0x88	; 136
    6f86:	80 93 4e 0f 	sts	0x0F4E, r24
	ntrxShadowReg[NA_SymbolDur_O] |= ((symbolDur << NA_SymbolDur_LSB) | (symbolRate << NA_SymbolRate_LSB));
    6f8a:	80 91 4e 0f 	lds	r24, 0x0F4E
    6f8e:	28 2f       	mov	r18, r24
    6f90:	8b 81       	ldd	r24, Y+3	; 0x03
    6f92:	88 2f       	mov	r24, r24
    6f94:	90 e0       	ldi	r25, 0x00	; 0
    6f96:	82 95       	swap	r24
    6f98:	92 95       	swap	r25
    6f9a:	90 7f       	andi	r25, 0xF0	; 240
    6f9c:	98 27       	eor	r25, r24
    6f9e:	80 7f       	andi	r24, 0xF0	; 240
    6fa0:	98 27       	eor	r25, r24
    6fa2:	98 2f       	mov	r25, r24
    6fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    6fa6:	89 2b       	or	r24, r25
    6fa8:	82 2b       	or	r24, r18
    6faa:	80 93 4e 0f 	sts	0x0F4E, r24
	NTRXSPIWriteByte (NA_SymbolDur_O, ntrxShadowReg[NA_SymbolDur_O]);
    6fae:	90 91 4e 0f 	lds	r25, 0x0F4E
    6fb2:	88 e4       	ldi	r24, 0x48	; 72
    6fb4:	69 2f       	mov	r22, r25
    6fb6:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <NTRXSPIWriteByte>

}
    6fba:	0f 90       	pop	r0
    6fbc:	0f 90       	pop	r0
    6fbe:	0f 90       	pop	r0
    6fc0:	cf 91       	pop	r28
    6fc2:	df 91       	pop	r29
    6fc4:	08 95       	ret

00006fc6 <NTRXSetCorrThreshold>:
 *
 */
/**************************************************************************/
void NTRXSetCorrThreshold (MyByte8T bandwidth, MyByte8T symbolDur)
/**************************************************************************/
{
    6fc6:	df 93       	push	r29
    6fc8:	cf 93       	push	r28
    6fca:	cd b7       	in	r28, 0x3d	; 61
    6fcc:	de b7       	in	r29, 0x3e	; 62
    6fce:	2d 97       	sbiw	r28, 0x0d	; 13
    6fd0:	0f b6       	in	r0, 0x3f	; 63
    6fd2:	f8 94       	cli
    6fd4:	de bf       	out	0x3e, r29	; 62
    6fd6:	0f be       	out	0x3f, r0	; 63
    6fd8:	cd bf       	out	0x3d, r28	; 61
    6fda:	88 87       	std	Y+8, r24	; 0x08
    6fdc:	69 87       	std	Y+9, r22	; 0x09
    MyByte8T threshold[5];
    MyByte8T *ptr = NULL;
    6fde:	1a 82       	std	Y+2, r1	; 0x02
    6fe0:	19 82       	std	Y+1, r1	; 0x01

    NTRXSetIndexReg (0x32);
    6fe2:	82 e3       	ldi	r24, 0x32	; 50
    6fe4:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <NTRXSetIndexReg>
    if (bandwidth == NA_80MHz)
    6fe8:	88 85       	ldd	r24, Y+8	; 0x08
    6fea:	88 23       	and	r24, r24
    6fec:	91 f5       	brne	.+100    	; 0x7052 <NTRXSetCorrThreshold+0x8c>
    {
        switch (symbolDur)
    6fee:	89 85       	ldd	r24, Y+9	; 0x09
    6ff0:	28 2f       	mov	r18, r24
    6ff2:	30 e0       	ldi	r19, 0x00	; 0
    6ff4:	3d 87       	std	Y+13, r19	; 0x0d
    6ff6:	2c 87       	std	Y+12, r18	; 0x0c
    6ff8:	8c 85       	ldd	r24, Y+12	; 0x0c
    6ffa:	9d 85       	ldd	r25, Y+13	; 0x0d
    6ffc:	81 30       	cpi	r24, 0x01	; 1
    6ffe:	91 05       	cpc	r25, r1
    7000:	d1 f0       	breq	.+52     	; 0x7036 <NTRXSetCorrThreshold+0x70>
    7002:	2c 85       	ldd	r18, Y+12	; 0x0c
    7004:	3d 85       	ldd	r19, Y+13	; 0x0d
    7006:	22 30       	cpi	r18, 0x02	; 2
    7008:	31 05       	cpc	r19, r1
    700a:	2c f4       	brge	.+10     	; 0x7016 <NTRXSetCorrThreshold+0x50>
    700c:	8c 85       	ldd	r24, Y+12	; 0x0c
    700e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7010:	00 97       	sbiw	r24, 0x00	; 0
    7012:	61 f0       	breq	.+24     	; 0x702c <NTRXSetCorrThreshold+0x66>
    7014:	54 c0       	rjmp	.+168    	; 0x70be <NTRXSetCorrThreshold+0xf8>
    7016:	2c 85       	ldd	r18, Y+12	; 0x0c
    7018:	3d 85       	ldd	r19, Y+13	; 0x0d
    701a:	22 30       	cpi	r18, 0x02	; 2
    701c:	31 05       	cpc	r19, r1
    701e:	81 f0       	breq	.+32     	; 0x7040 <NTRXSetCorrThreshold+0x7a>
    7020:	8c 85       	ldd	r24, Y+12	; 0x0c
    7022:	9d 85       	ldd	r25, Y+13	; 0x0d
    7024:	83 30       	cpi	r24, 0x03	; 3
    7026:	91 05       	cpc	r25, r1
    7028:	81 f0       	breq	.+32     	; 0x704a <NTRXSetCorrThreshold+0x84>
    702a:	49 c0       	rjmp	.+146    	; 0x70be <NTRXSetCorrThreshold+0xf8>
        {
#			ifdef CONFIG_NTRX_80MHZ_500NS
            case NA_500ns:  ptr = (MyByte8T *)NA5TR1_THRES_80MHz_500ns; break;
    702c:	8c e4       	ldi	r24, 0x4C	; 76
    702e:	98 e0       	ldi	r25, 0x08	; 8
    7030:	9a 83       	std	Y+2, r25	; 0x02
    7032:	89 83       	std	Y+1, r24	; 0x01
    7034:	0e c0       	rjmp	.+28     	; 0x7052 <NTRXSetCorrThreshold+0x8c>
#			endif /* CONFIG_NTRX_80MHZ_500NS */
#			ifdef CONFIG_NTRX_80MHZ_1000NS
            case NA_1us:    ptr = (MyByte8T *)NA5TR1_THRES_80MHz_1000ns; break;
    7036:	81 e5       	ldi	r24, 0x51	; 81
    7038:	98 e0       	ldi	r25, 0x08	; 8
    703a:	9a 83       	std	Y+2, r25	; 0x02
    703c:	89 83       	std	Y+1, r24	; 0x01
    703e:	09 c0       	rjmp	.+18     	; 0x7052 <NTRXSetCorrThreshold+0x8c>
#			endif /* CONFIG_NTRX_80MHZ_1000NS */
#			ifdef CONFIG_NTRX_80MHZ_2000NS
            case NA_2us:    ptr = (MyByte8T *)NA5TR1_THRES_80MHz_2000ns; break;
    7040:	86 e5       	ldi	r24, 0x56	; 86
    7042:	98 e0       	ldi	r25, 0x08	; 8
    7044:	9a 83       	std	Y+2, r25	; 0x02
    7046:	89 83       	std	Y+1, r24	; 0x01
    7048:	04 c0       	rjmp	.+8      	; 0x7052 <NTRXSetCorrThreshold+0x8c>
#			endif /* CONFIG_NTRX_80MHZ_2000NS */
#			ifdef CONFIG_NTRX_80MHZ_4000NS
            case NA_4us:    ptr = (MyByte8T *)NA5TR1_THRES_80MHz_4000ns; break;
    704a:	8b e5       	ldi	r24, 0x5B	; 91
    704c:	98 e0       	ldi	r25, 0x08	; 8
    704e:	9a 83       	std	Y+2, r25	; 0x02
    7050:	89 83       	std	Y+1, r24	; 0x01
#			endif /* NTRX_80MHZ_4000NS */
            default:        return;
        }
    }

    if (bandwidth == NA_22MHz)
    7052:	88 85       	ldd	r24, Y+8	; 0x08
    7054:	81 30       	cpi	r24, 0x01	; 1
    7056:	11 f5       	brne	.+68     	; 0x709c <NTRXSetCorrThreshold+0xd6>
    {
        switch (symbolDur)
    7058:	89 85       	ldd	r24, Y+9	; 0x09
    705a:	28 2f       	mov	r18, r24
    705c:	30 e0       	ldi	r19, 0x00	; 0
    705e:	3b 87       	std	Y+11, r19	; 0x0b
    7060:	2a 87       	std	Y+10, r18	; 0x0a
    7062:	8a 85       	ldd	r24, Y+10	; 0x0a
    7064:	9b 85       	ldd	r25, Y+11	; 0x0b
    7066:	82 30       	cpi	r24, 0x02	; 2
    7068:	91 05       	cpc	r25, r1
    706a:	79 f0       	breq	.+30     	; 0x708a <NTRXSetCorrThreshold+0xc4>
    706c:	2a 85       	ldd	r18, Y+10	; 0x0a
    706e:	3b 85       	ldd	r19, Y+11	; 0x0b
    7070:	23 30       	cpi	r18, 0x03	; 3
    7072:	31 05       	cpc	r19, r1
    7074:	79 f0       	breq	.+30     	; 0x7094 <NTRXSetCorrThreshold+0xce>
    7076:	8a 85       	ldd	r24, Y+10	; 0x0a
    7078:	9b 85       	ldd	r25, Y+11	; 0x0b
    707a:	81 30       	cpi	r24, 0x01	; 1
    707c:	91 05       	cpc	r25, r1
    707e:	f9 f4       	brne	.+62     	; 0x70be <NTRXSetCorrThreshold+0xf8>
        {
#			ifdef CONFIG_NTRX_22MHZ_1000NS
            case NA_1us:    ptr = (MyByte8T *)NA5TR1_THRES_22MHz_1000ns; break;
    7080:	80 e6       	ldi	r24, 0x60	; 96
    7082:	98 e0       	ldi	r25, 0x08	; 8
    7084:	9a 83       	std	Y+2, r25	; 0x02
    7086:	89 83       	std	Y+1, r24	; 0x01
    7088:	09 c0       	rjmp	.+18     	; 0x709c <NTRXSetCorrThreshold+0xd6>
#			endif /* NTRX_22MHZ_1000NS */
#			ifdef CONFIG_NTRX_22MHZ_2000NS
            case NA_2us:    ptr = (MyByte8T *)NA5TR1_THRES_22MHz_2000ns; break;
    708a:	85 e6       	ldi	r24, 0x65	; 101
    708c:	98 e0       	ldi	r25, 0x08	; 8
    708e:	9a 83       	std	Y+2, r25	; 0x02
    7090:	89 83       	std	Y+1, r24	; 0x01
    7092:	04 c0       	rjmp	.+8      	; 0x709c <NTRXSetCorrThreshold+0xd6>
#			endif /* CONFIG_NTRX_22MHZ_2000NS */
#			ifdef CONFIG_NTRX_22MHZ_4000NS
            case NA_4us:    ptr = (MyByte8T *)NA5TR1_THRES_22MHz_4000ns; break;
    7094:	8a e6       	ldi	r24, 0x6A	; 106
    7096:	98 e0       	ldi	r25, 0x08	; 8
    7098:	9a 83       	std	Y+2, r25	; 0x02
    709a:	89 83       	std	Y+1, r24	; 0x01
#			endif /* CONFIG_NTRX_22MHZ_4000NS */
            default:        return;
        }
    }

    memcpy_P (threshold, ptr, 5);
    709c:	ce 01       	movw	r24, r28
    709e:	03 96       	adiw	r24, 0x03	; 3
    70a0:	29 81       	ldd	r18, Y+1	; 0x01
    70a2:	3a 81       	ldd	r19, Y+2	; 0x02
    70a4:	b9 01       	movw	r22, r18
    70a6:	45 e0       	ldi	r20, 0x05	; 5
    70a8:	50 e0       	ldi	r21, 0x00	; 0
    70aa:	0e 94 ba 44 	call	0x8974	; 0x8974 <memcpy_P>
    NTRXSPIWrite (0x80, threshold, 5);
    70ae:	9e 01       	movw	r18, r28
    70b0:	2d 5f       	subi	r18, 0xFD	; 253
    70b2:	3f 4f       	sbci	r19, 0xFF	; 255
    70b4:	80 e8       	ldi	r24, 0x80	; 128
    70b6:	b9 01       	movw	r22, r18
    70b8:	45 e0       	ldi	r20, 0x05	; 5
    70ba:	0e 94 4d 1c 	call	0x389a	; 0x389a <NTRXSPIWrite>
}
    70be:	2d 96       	adiw	r28, 0x0d	; 13
    70c0:	0f b6       	in	r0, 0x3f	; 63
    70c2:	f8 94       	cli
    70c4:	de bf       	out	0x3e, r29	; 62
    70c6:	0f be       	out	0x3f, r0	; 63
    70c8:	cd bf       	out	0x3d, r28	; 61
    70ca:	cf 91       	pop	r28
    70cc:	df 91       	pop	r29
    70ce:	08 95       	ret

000070d0 <RangingCallback_Rx>:
 *
 * the functions is automaticly called in NTRXReceive
 *
 */
void RangingCallback_Rx(MyByte8T *payload, MyByte8T len)
{
    70d0:	df 93       	push	r29
    70d2:	cf 93       	push	r28
    70d4:	00 d0       	rcall	.+0      	; 0x70d6 <RangingCallback_Rx+0x6>
    70d6:	00 d0       	rcall	.+0      	; 0x70d8 <RangingCallback_Rx+0x8>
    70d8:	00 d0       	rcall	.+0      	; 0x70da <RangingCallback_Rx+0xa>
    70da:	cd b7       	in	r28, 0x3d	; 61
    70dc:	de b7       	in	r29, 0x3e	; 62
    70de:	9b 83       	std	Y+3, r25	; 0x03
    70e0:	8a 83       	std	Y+2, r24	; 0x02
    70e2:	6c 83       	std	Y+4, r22	; 0x04
	MyByte8T	ToaOffsetMeanDataValid;

	lrv[ACTTXID]=0x00;
    70e4:	10 92 34 10 	sts	0x1034, r1

	/* Read Rx Ranging Registers */
	NTRXSPIReadByte (NA_ToaOffsetMeanDataValid_O, &ToaOffsetMeanDataValid);
    70e8:	80 e3       	ldi	r24, 0x30	; 48
    70ea:	9e 01       	movw	r18, r28
    70ec:	2f 5f       	subi	r18, 0xFF	; 255
    70ee:	3f 4f       	sbci	r19, 0xFF	; 255
    70f0:	b9 01       	movw	r22, r18
    70f2:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
	ToaOffsetMeanDataValid &= (0x01 << NA_ToaOffsetMeanDataValid_B);
    70f6:	89 81       	ldd	r24, Y+1	; 0x01
    70f8:	80 78       	andi	r24, 0x80	; 128
    70fa:	89 83       	std	Y+1, r24	; 0x01
	ToaOffsetMeanDataValid = ToaOffsetMeanDataValid>>NA_ToaOffsetMeanDataValid_B;
    70fc:	89 81       	ldd	r24, Y+1	; 0x01
    70fe:	88 1f       	adc	r24, r24
    7100:	88 27       	eor	r24, r24
    7102:	88 1f       	adc	r24, r24
    7104:	89 83       	std	Y+1, r24	; 0x01


	if(ToaOffsetMeanDataValid != 1)
    7106:	89 81       	ldd	r24, Y+1	; 0x01
    7108:	81 30       	cpi	r24, 0x01	; 1
    710a:	81 f0       	breq	.+32     	; 0x712c <RangingCallback_Rx+0x5c>
	{
		if(rrv[ACTTXID] == 1)
    710c:	80 91 40 10 	lds	r24, 0x1040
    7110:	81 30       	cpi	r24, 0x01	; 1
    7112:	31 f4       	brne	.+12     	; 0x7120 <RangingCallback_Rx+0x50>
		{
			rangingPIB.error |= STAT_PACKET_ERROR_RX1;
    7114:	80 91 8c 0f 	lds	r24, 0x0F8C
    7118:	80 62       	ori	r24, 0x20	; 32
    711a:	80 93 8c 0f 	sts	0x0F8C, r24
    711e:	a4 c0       	rjmp	.+328    	; 0x7268 <RangingCallback_Rx+0x198>
		}
		else
		{
			rangingPIB.error |= STAT_PACKET_ERROR_RX2;
    7120:	80 91 8c 0f 	lds	r24, 0x0F8C
    7124:	80 64       	ori	r24, 0x40	; 64
    7126:	80 93 8c 0f 	sts	0x0F8C, r24
    712a:	9e c0       	rjmp	.+316    	; 0x7268 <RangingCallback_Rx+0x198>
		}
	}
	else
	{

		if (len==ARRYLEN)
    712c:	8c 81       	ldd	r24, Y+4	; 0x04
    712e:	8c 30       	cpi	r24, 0x0C	; 12
    7130:	09 f0       	breq	.+2      	; 0x7134 <RangingCallback_Rx+0x64>
    7132:	9a c0       	rjmp	.+308    	; 0x7268 <RangingCallback_Rx+0x198>
		{
			/* Get the remote ranging values */
			memcpy(rrv,payload,ARRYLEN);
    7134:	86 e3       	ldi	r24, 0x36	; 54
    7136:	90 e1       	ldi	r25, 0x10	; 16
    7138:	2a 81       	ldd	r18, Y+2	; 0x02
    713a:	3b 81       	ldd	r19, Y+3	; 0x03
    713c:	b9 01       	movw	r22, r18
    713e:	4c e0       	ldi	r20, 0x0C	; 12
    7140:	50 e0       	ldi	r21, 0x00	; 0
    7142:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>

			NTRXSPIReadByte (NA_AgcGain_O, &lrv[RSSI]);
    7146:	25 e3       	ldi	r18, 0x35	; 53
    7148:	30 e1       	ldi	r19, 0x10	; 16
    714a:	86 e2       	ldi	r24, 0x26	; 38
    714c:	b9 01       	movw	r22, r18
    714e:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
			lrv[RSSI] &= (0x3F << NA_AgcGain_LSB);
    7152:	80 91 35 10 	lds	r24, 0x1035
    7156:	8f 73       	andi	r24, 0x3F	; 63
    7158:	80 93 35 10 	sts	0x1035, r24
			lrv[RSSI] = lrv[RSSI] >> NA_AgcGain_LSB;
    715c:	80 91 35 10 	lds	r24, 0x1035
    7160:	80 93 35 10 	sts	0x1035, r24
			lrv[RSSI] = 0x3F - lrv[RSSI];
    7164:	90 91 35 10 	lds	r25, 0x1035
    7168:	8f e3       	ldi	r24, 0x3F	; 63
    716a:	89 1b       	sub	r24, r25
    716c:	80 93 35 10 	sts	0x1035, r24

			/* Check what matches our local values */
			switch(rrv[ACTTXID])
    7170:	80 91 40 10 	lds	r24, 0x1040
    7174:	28 2f       	mov	r18, r24
    7176:	30 e0       	ldi	r19, 0x00	; 0
    7178:	3e 83       	std	Y+6, r19	; 0x06
    717a:	2d 83       	std	Y+5, r18	; 0x05
    717c:	8d 81       	ldd	r24, Y+5	; 0x05
    717e:	9e 81       	ldd	r25, Y+6	; 0x06
    7180:	81 30       	cpi	r24, 0x01	; 1
    7182:	91 05       	cpc	r25, r1
    7184:	31 f0       	breq	.+12     	; 0x7192 <RangingCallback_Rx+0xc2>
    7186:	2d 81       	ldd	r18, Y+5	; 0x05
    7188:	3e 81       	ldd	r19, Y+6	; 0x06
    718a:	22 30       	cpi	r18, 0x02	; 2
    718c:	31 05       	cpc	r19, r1
    718e:	51 f1       	breq	.+84     	; 0x71e4 <RangingCallback_Rx+0x114>
    7190:	4a c0       	rjmp	.+148    	; 0x7226 <RangingCallback_Rx+0x156>
			{
				case 1 :
					/* combine data for locally initiated round trip */
					set1[PHASEOFFSETACK]=lrv[PHASEOFFSETACK];
    7192:	80 91 2a 10 	lds	r24, 0x102A
    7196:	80 93 42 10 	sts	0x1042, r24
					set1[TOAOFFSETMEANACK_H]=lrv[TOAOFFSETMEANACK_H];
    719a:	80 91 2c 10 	lds	r24, 0x102C
    719e:	80 93 44 10 	sts	0x1044, r24
					set1[TOAOFFSETMEANACK_L]=lrv[TOAOFFSETMEANACK_L];
    71a2:	80 91 2b 10 	lds	r24, 0x102B
    71a6:	80 93 43 10 	sts	0x1043, r24
					set1[TXRESPTIME_H]=lrv[TXRESPTIME_H];
    71aa:	80 91 2e 10 	lds	r24, 0x102E
    71ae:	80 93 46 10 	sts	0x1046, r24
					set1[TXRESPTIME_L]=lrv[TXRESPTIME_L];
    71b2:	80 91 2d 10 	lds	r24, 0x102D
    71b6:	80 93 45 10 	sts	0x1045, r24

					set1[PHASEOFFSETDATA]=rrv[PHASEOFFSETDATA];
    71ba:	80 91 3b 10 	lds	r24, 0x103B
    71be:	80 93 47 10 	sts	0x1047, r24
					set1[TOAOFFSETMEANDATA_H]=rrv[TOAOFFSETMEANDATA_H];
    71c2:	80 91 3d 10 	lds	r24, 0x103D
    71c6:	80 93 49 10 	sts	0x1049, r24
					set1[TOAOFFSETMEANDATA_L]=rrv[TOAOFFSETMEANDATA_L];
    71ca:	80 91 3c 10 	lds	r24, 0x103C
    71ce:	80 93 48 10 	sts	0x1048, r24

					set1[RSSI]=rrv[RSSI];
    71d2:	80 91 41 10 	lds	r24, 0x1041
    71d6:	80 93 4d 10 	sts	0x104D, r24
					set2[RSSI]=lrv[RSSI];
    71da:	80 91 35 10 	lds	r24, 0x1035
    71de:	80 93 59 10 	sts	0x1059, r24
    71e2:	21 c0       	rjmp	.+66     	; 0x7226 <RangingCallback_Rx+0x156>

					break;
				case 2 :
					/* combine data for remotely initiated round trip */
					set2[PHASEOFFSETACK]=rrv[PHASEOFFSETACK];
    71e4:	80 91 36 10 	lds	r24, 0x1036
    71e8:	80 93 4e 10 	sts	0x104E, r24
					set2[TOAOFFSETMEANACK_H]=rrv[TOAOFFSETMEANACK_H];
    71ec:	80 91 38 10 	lds	r24, 0x1038
    71f0:	80 93 50 10 	sts	0x1050, r24
					set2[TOAOFFSETMEANACK_L]=rrv[TOAOFFSETMEANACK_L];
    71f4:	80 91 37 10 	lds	r24, 0x1037
    71f8:	80 93 4f 10 	sts	0x104F, r24
					set2[TXRESPTIME_H]=rrv[TXRESPTIME_H];
    71fc:	80 91 3a 10 	lds	r24, 0x103A
    7200:	80 93 52 10 	sts	0x1052, r24
					set2[TXRESPTIME_L]=rrv[TXRESPTIME_L];
    7204:	80 91 39 10 	lds	r24, 0x1039
    7208:	80 93 51 10 	sts	0x1051, r24

					set2[PHASEOFFSETDATA]=lrv[PHASEOFFSETDATA];
    720c:	80 91 2f 10 	lds	r24, 0x102F
    7210:	80 93 53 10 	sts	0x1053, r24
					set2[TOAOFFSETMEANDATA_H]=lrv[TOAOFFSETMEANDATA_H];
    7214:	80 91 31 10 	lds	r24, 0x1031
    7218:	80 93 55 10 	sts	0x1055, r24
					set2[TOAOFFSETMEANDATA_L]=lrv[TOAOFFSETMEANDATA_L];
    721c:	80 91 30 10 	lds	r24, 0x1030
    7220:	80 93 54 10 	sts	0x1054, r24
    7224:	21 c0       	rjmp	.+66     	; 0x7268 <RangingCallback_Rx+0x198>
				default:
					break;
			}

			/* now we can update our local ranging values */
			lrv[PREVRXID]=rrv[ACTTXID];
    7226:	80 91 40 10 	lds	r24, 0x1040
    722a:	80 93 32 10 	sts	0x1032, r24

			NTRXSPIReadByte (NA_PhaseOffsetData_O, &lrv[PHASEOFFSETDATA]);
    722e:	2f e2       	ldi	r18, 0x2F	; 47
    7230:	30 e1       	ldi	r19, 0x10	; 16
    7232:	8e e2       	ldi	r24, 0x2E	; 46
    7234:	b9 01       	movw	r22, r18
    7236:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
			lrv[PHASEOFFSETDATA] &= (0x07 << NA_PhaseOffsetData_LSB);
    723a:	80 91 2f 10 	lds	r24, 0x102F
    723e:	80 77       	andi	r24, 0x70	; 112
    7240:	80 93 2f 10 	sts	0x102F, r24
			lrv[PHASEOFFSETDATA] = (lrv[PHASEOFFSETDATA] >> NA_PhaseOffsetData_LSB);
    7244:	80 91 2f 10 	lds	r24, 0x102F
    7248:	82 95       	swap	r24
    724a:	8f 70       	andi	r24, 0x0F	; 15
    724c:	80 93 2f 10 	sts	0x102F, r24

			NTRXSPIRead (NA_ToaOffsetMeanData_O, &lrv[TOAOFFSETMEANDATA_L], 2);
    7250:	20 e3       	ldi	r18, 0x30	; 48
    7252:	30 e1       	ldi	r19, 0x10	; 16
    7254:	8f e2       	ldi	r24, 0x2F	; 47
    7256:	b9 01       	movw	r22, r18
    7258:	42 e0       	ldi	r20, 0x02	; 2
    725a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
			lrv[TOAOFFSETMEANDATA_H] &= 0x1f;
    725e:	80 91 31 10 	lds	r24, 0x1031
    7262:	8f 71       	andi	r24, 0x1F	; 31
    7264:	80 93 31 10 	sts	0x1031, r24
		}
	}
}
    7268:	26 96       	adiw	r28, 0x06	; 6
    726a:	0f b6       	in	r0, 0x3f	; 63
    726c:	f8 94       	cli
    726e:	de bf       	out	0x3e, r29	; 62
    7270:	0f be       	out	0x3f, r0	; 63
    7272:	cd bf       	out	0x3d, r28	; 61
    7274:	cf 91       	pop	r28
    7276:	df 91       	pop	r29
    7278:	08 95       	ret

0000727a <RangingCallback_Ack>:
 *
 * the functions is automaticly called in NTRXTxEnd
 *
 */
void RangingCallback_Ack(MyByte8T arqCount)
{
    727a:	df 93       	push	r29
    727c:	cf 93       	push	r28
    727e:	00 d0       	rcall	.+0      	; 0x7280 <RangingCallback_Ack+0x6>
    7280:	cd b7       	in	r28, 0x3d	; 61
    7282:	de b7       	in	r29, 0x3e	; 62
    7284:	8a 83       	std	Y+2, r24	; 0x02
	MyByte8T	ToaOffsetMeanAckValid;
	/* Read Tx Ranging Registers */
    NTRXSPIReadByte (NA_ToaOffsetMeanAckValid_O, &ToaOffsetMeanAckValid);
    7286:	8b e2       	ldi	r24, 0x2B	; 43
    7288:	9e 01       	movw	r18, r28
    728a:	2f 5f       	subi	r18, 0xFF	; 255
    728c:	3f 4f       	sbci	r19, 0xFF	; 255
    728e:	b9 01       	movw	r22, r18
    7290:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
	ToaOffsetMeanAckValid &= (0x01 << NA_ToaOffsetMeanAckValid_B);
    7294:	89 81       	ldd	r24, Y+1	; 0x01
    7296:	80 78       	andi	r24, 0x80	; 128
    7298:	89 83       	std	Y+1, r24	; 0x01
	ToaOffsetMeanAckValid = ToaOffsetMeanAckValid>>NA_ToaOffsetMeanAckValid_B;
    729a:	89 81       	ldd	r24, Y+1	; 0x01
    729c:	88 1f       	adc	r24, r24
    729e:	88 27       	eor	r24, r24
    72a0:	88 1f       	adc	r24, r24
    72a2:	89 83       	std	Y+1, r24	; 0x01

	if(ToaOffsetMeanAckValid != 1)
    72a4:	89 81       	ldd	r24, Y+1	; 0x01
    72a6:	81 30       	cpi	r24, 0x01	; 1
    72a8:	31 f0       	breq	.+12     	; 0x72b6 <RangingCallback_Ack+0x3c>
	{
		rangingPIB.error |= STAT_PACKET_ERROR_TX;
    72aa:	80 91 8c 0f 	lds	r24, 0x0F8C
    72ae:	80 61       	ori	r24, 0x10	; 16
    72b0:	80 93 8c 0f 	sts	0x0F8C, r24
    72b4:	22 c0       	rjmp	.+68     	; 0x72fa <RangingCallback_Ack+0x80>
	}
	else
	{
		NTRXSPIReadByte (NA_PhaseOffsetAck_O, &lrv[PHASEOFFSETACK]);
    72b6:	2a e2       	ldi	r18, 0x2A	; 42
    72b8:	30 e1       	ldi	r19, 0x10	; 16
    72ba:	8e e2       	ldi	r24, 0x2E	; 46
    72bc:	b9 01       	movw	r22, r18
    72be:	0e 94 aa 1c 	call	0x3954	; 0x3954 <NTRXSPIReadByte>
		lrv[PHASEOFFSETACK] &= (0x07 << NA_PhaseOffsetAck_LSB);
    72c2:	80 91 2a 10 	lds	r24, 0x102A
    72c6:	87 70       	andi	r24, 0x07	; 7
    72c8:	80 93 2a 10 	sts	0x102A, r24
		lrv[PHASEOFFSETACK] = lrv[PHASEOFFSETACK]>>NA_PhaseOffsetAck_LSB;
    72cc:	80 91 2a 10 	lds	r24, 0x102A
    72d0:	80 93 2a 10 	sts	0x102A, r24

		NTRXSPIRead (NA_ToaOffsetMeanAck_O, &lrv[TOAOFFSETMEANACK_L], 2);
    72d4:	2b e2       	ldi	r18, 0x2B	; 43
    72d6:	30 e1       	ldi	r19, 0x10	; 16
    72d8:	8a e2       	ldi	r24, 0x2A	; 42
    72da:	b9 01       	movw	r22, r18
    72dc:	42 e0       	ldi	r20, 0x02	; 2
    72de:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
		lrv[TOAOFFSETMEANACK_H] &= 0x1f;
    72e2:	80 91 2c 10 	lds	r24, 0x102C
    72e6:	8f 71       	andi	r24, 0x1F	; 31
    72e8:	80 93 2c 10 	sts	0x102C, r24

        NTRXSPIRead ( NA_TxRespTime_O, &lrv[TXRESPTIME_L], 2);
    72ec:	2d e2       	ldi	r18, 0x2D	; 45
    72ee:	30 e1       	ldi	r19, 0x10	; 16
    72f0:	8c e2       	ldi	r24, 0x2C	; 44
    72f2:	b9 01       	movw	r22, r18
    72f4:	42 e0       	ldi	r20, 0x02	; 2
    72f6:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <NTRXSPIRead>
	}

	lrv[PREVTXID]=lrv[ACTTXID];
    72fa:	80 91 34 10 	lds	r24, 0x1034
    72fe:	80 93 33 10 	sts	0x1033, r24

	if ( 	(rangeMsg.prim == PD_RANGING_ANSWER2_EXECUTE) ||
    7302:	80 91 92 0f 	lds	r24, 0x0F92
    7306:	81 31       	cpi	r24, 0x11	; 17
    7308:	21 f0       	breq	.+8      	; 0x7312 <RangingCallback_Ack+0x98>
    730a:	80 91 92 0f 	lds	r24, 0x0F92
    730e:	86 31       	cpi	r24, 0x16	; 22
    7310:	01 f5       	brne	.+64     	; 0x7352 <RangingCallback_Ack+0xd8>
			(rangeMsg.prim == PD_RANGING_FAST_ANSWER1_EXECUTE)	)
	{
		memset(lrv,'\0',ARRYLEN);
    7312:	8a e2       	ldi	r24, 0x2A	; 42
    7314:	90 e1       	ldi	r25, 0x10	; 16
    7316:	60 e0       	ldi	r22, 0x00	; 0
    7318:	70 e0       	ldi	r23, 0x00	; 0
    731a:	4c e0       	ldi	r20, 0x0C	; 12
    731c:	50 e0       	ldi	r21, 0x00	; 0
    731e:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
		memset(rrv,'\0',ARRYLEN);
    7322:	86 e3       	ldi	r24, 0x36	; 54
    7324:	90 e1       	ldi	r25, 0x10	; 16
    7326:	60 e0       	ldi	r22, 0x00	; 0
    7328:	70 e0       	ldi	r23, 0x00	; 0
    732a:	4c e0       	ldi	r20, 0x0C	; 12
    732c:	50 e0       	ldi	r21, 0x00	; 0
    732e:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
		memset(set1,'\0',ARRYLEN);
    7332:	82 e4       	ldi	r24, 0x42	; 66
    7334:	90 e1       	ldi	r25, 0x10	; 16
    7336:	60 e0       	ldi	r22, 0x00	; 0
    7338:	70 e0       	ldi	r23, 0x00	; 0
    733a:	4c e0       	ldi	r20, 0x0C	; 12
    733c:	50 e0       	ldi	r21, 0x00	; 0
    733e:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
		memset(set2,'\0',ARRYLEN);
    7342:	8e e4       	ldi	r24, 0x4E	; 78
    7344:	90 e1       	ldi	r25, 0x10	; 16
    7346:	60 e0       	ldi	r22, 0x00	; 0
    7348:	70 e0       	ldi	r23, 0x00	; 0
    734a:	4c e0       	ldi	r20, 0x0C	; 12
    734c:	50 e0       	ldi	r21, 0x00	; 0
    734e:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
	}
	
}
    7352:	0f 90       	pop	r0
    7354:	0f 90       	pop	r0
    7356:	cf 91       	pop	r28
    7358:	df 91       	pop	r29
    735a:	08 95       	ret

0000735c <RangingMode>:
 *
 * RangingAnswer handles the start and continue of ranging at all.
 *
 */
void RangingMode(MyByte8T cmd, MyAddrT dest)
{
    735c:	df 93       	push	r29
    735e:	cf 93       	push	r28
    7360:	00 d0       	rcall	.+0      	; 0x7362 <RangingMode+0x6>
    7362:	00 d0       	rcall	.+0      	; 0x7364 <RangingMode+0x8>
    7364:	0f 92       	push	r0
    7366:	cd b7       	in	r28, 0x3d	; 61
    7368:	de b7       	in	r29, 0x3e	; 62
    736a:	89 83       	std	Y+1, r24	; 0x01
    736c:	7b 83       	std	Y+3, r23	; 0x03
    736e:	6a 83       	std	Y+2, r22	; 0x02
	lrv[ACTTXID]++;
    7370:	80 91 34 10 	lds	r24, 0x1034
    7374:	8f 5f       	subi	r24, 0xFF	; 255
    7376:	80 93 34 10 	sts	0x1034, r24

	memcpy (rangeMsg.addr, dest, 6);
    737a:	83 e9       	ldi	r24, 0x93	; 147
    737c:	9f e0       	ldi	r25, 0x0F	; 15
    737e:	2a 81       	ldd	r18, Y+2	; 0x02
    7380:	3b 81       	ldd	r19, Y+3	; 0x03
    7382:	b9 01       	movw	r22, r18
    7384:	46 e0       	ldi	r20, 0x06	; 6
    7386:	50 e0       	ldi	r21, 0x00	; 0
    7388:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>
	memcpy (rangeMsg.data, lrv, ARRYLEN);
    738c:	8a e9       	ldi	r24, 0x9A	; 154
    738e:	9f e0       	ldi	r25, 0x0F	; 15
    7390:	2a e2       	ldi	r18, 0x2A	; 42
    7392:	30 e1       	ldi	r19, 0x10	; 16
    7394:	b9 01       	movw	r22, r18
    7396:	4c e0       	ldi	r20, 0x0C	; 12
    7398:	50 e0       	ldi	r21, 0x00	; 0
    739a:	0e 94 db 44 	call	0x89b6	; 0x89b6 <memcpy>

	switch(cmd)
    739e:	89 81       	ldd	r24, Y+1	; 0x01
    73a0:	28 2f       	mov	r18, r24
    73a2:	30 e0       	ldi	r19, 0x00	; 0
    73a4:	3d 83       	std	Y+5, r19	; 0x05
    73a6:	2c 83       	std	Y+4, r18	; 0x04
    73a8:	8c 81       	ldd	r24, Y+4	; 0x04
    73aa:	9d 81       	ldd	r25, Y+5	; 0x05
    73ac:	83 30       	cpi	r24, 0x03	; 3
    73ae:	91 05       	cpc	r25, r1
    73b0:	09 f4       	brne	.+2      	; 0x73b4 <RangingMode+0x58>
    73b2:	47 c0       	rjmp	.+142    	; 0x7442 <RangingMode+0xe6>
    73b4:	2c 81       	ldd	r18, Y+4	; 0x04
    73b6:	3d 81       	ldd	r19, Y+5	; 0x05
    73b8:	24 30       	cpi	r18, 0x04	; 4
    73ba:	31 05       	cpc	r19, r1
    73bc:	5c f4       	brge	.+22     	; 0x73d4 <RangingMode+0x78>
    73be:	8c 81       	ldd	r24, Y+4	; 0x04
    73c0:	9d 81       	ldd	r25, Y+5	; 0x05
    73c2:	81 30       	cpi	r24, 0x01	; 1
    73c4:	91 05       	cpc	r25, r1
    73c6:	91 f0       	breq	.+36     	; 0x73ec <RangingMode+0x90>
    73c8:	2c 81       	ldd	r18, Y+4	; 0x04
    73ca:	3d 81       	ldd	r19, Y+5	; 0x05
    73cc:	22 30       	cpi	r18, 0x02	; 2
    73ce:	31 05       	cpc	r19, r1
    73d0:	a1 f1       	breq	.+104    	; 0x743a <RangingMode+0xde>
    73d2:	65 c0       	rjmp	.+202    	; 0x749e <RangingMode+0x142>
    73d4:	8c 81       	ldd	r24, Y+4	; 0x04
    73d6:	9d 81       	ldd	r25, Y+5	; 0x05
    73d8:	84 30       	cpi	r24, 0x04	; 4
    73da:	91 05       	cpc	r25, r1
    73dc:	b1 f1       	breq	.+108    	; 0x744a <RangingMode+0xee>
    73de:	2c 81       	ldd	r18, Y+4	; 0x04
    73e0:	3d 81       	ldd	r19, Y+5	; 0x05
    73e2:	25 30       	cpi	r18, 0x05	; 5
    73e4:	31 05       	cpc	r19, r1
    73e6:	09 f4       	brne	.+2      	; 0x73ea <RangingMode+0x8e>
    73e8:	57 c0       	rjmp	.+174    	; 0x7498 <RangingMode+0x13c>
    73ea:	59 c0       	rjmp	.+178    	; 0x749e <RangingMode+0x142>
	{
		case RANGING_START :
			memset(lrv,'\0',ARRYLEN);
    73ec:	8a e2       	ldi	r24, 0x2A	; 42
    73ee:	90 e1       	ldi	r25, 0x10	; 16
    73f0:	60 e0       	ldi	r22, 0x00	; 0
    73f2:	70 e0       	ldi	r23, 0x00	; 0
    73f4:	4c e0       	ldi	r20, 0x0C	; 12
    73f6:	50 e0       	ldi	r21, 0x00	; 0
    73f8:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(rrv,'\0',ARRYLEN);
    73fc:	86 e3       	ldi	r24, 0x36	; 54
    73fe:	90 e1       	ldi	r25, 0x10	; 16
    7400:	60 e0       	ldi	r22, 0x00	; 0
    7402:	70 e0       	ldi	r23, 0x00	; 0
    7404:	4c e0       	ldi	r20, 0x0C	; 12
    7406:	50 e0       	ldi	r21, 0x00	; 0
    7408:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(set1,'\0',ARRYLEN);
    740c:	82 e4       	ldi	r24, 0x42	; 66
    740e:	90 e1       	ldi	r25, 0x10	; 16
    7410:	60 e0       	ldi	r22, 0x00	; 0
    7412:	70 e0       	ldi	r23, 0x00	; 0
    7414:	4c e0       	ldi	r20, 0x0C	; 12
    7416:	50 e0       	ldi	r21, 0x00	; 0
    7418:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(set2,'\0',ARRYLEN);
    741c:	8e e4       	ldi	r24, 0x4E	; 78
    741e:	90 e1       	ldi	r25, 0x10	; 16
    7420:	60 e0       	ldi	r22, 0x00	; 0
    7422:	70 e0       	ldi	r23, 0x00	; 0
    7424:	4c e0       	ldi	r20, 0x0C	; 12
    7426:	50 e0       	ldi	r21, 0x00	; 0
    7428:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			rangeMsg.prim = PD_RANGING_REQUEST_EXECUTE;
    742c:	8f e0       	ldi	r24, 0x0F	; 15
    742e:	80 93 92 0f 	sts	0x0F92, r24
			rangingLastCmd = RANGING_START;
    7432:	81 e0       	ldi	r24, 0x01	; 1
    7434:	80 93 a4 07 	sts	0x07A4, r24
    7438:	32 c0       	rjmp	.+100    	; 0x749e <RangingMode+0x142>
			break;
		case RANGING_ANSWER1 : rangeMsg.prim = PD_RANGING_ANSWER1_EXECUTE; break;
    743a:	80 e1       	ldi	r24, 0x10	; 16
    743c:	80 93 92 0f 	sts	0x0F92, r24
    7440:	2e c0       	rjmp	.+92     	; 0x749e <RangingMode+0x142>
		case RANGING_ANSWER2 : rangeMsg.prim = PD_RANGING_ANSWER2_EXECUTE; break;
    7442:	81 e1       	ldi	r24, 0x11	; 17
    7444:	80 93 92 0f 	sts	0x0F92, r24
    7448:	2a c0       	rjmp	.+84     	; 0x749e <RangingMode+0x142>
		case RANGING_FAST_START : 
			memset(lrv,'\0',ARRYLEN);
    744a:	8a e2       	ldi	r24, 0x2A	; 42
    744c:	90 e1       	ldi	r25, 0x10	; 16
    744e:	60 e0       	ldi	r22, 0x00	; 0
    7450:	70 e0       	ldi	r23, 0x00	; 0
    7452:	4c e0       	ldi	r20, 0x0C	; 12
    7454:	50 e0       	ldi	r21, 0x00	; 0
    7456:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(rrv,'\0',ARRYLEN);
    745a:	86 e3       	ldi	r24, 0x36	; 54
    745c:	90 e1       	ldi	r25, 0x10	; 16
    745e:	60 e0       	ldi	r22, 0x00	; 0
    7460:	70 e0       	ldi	r23, 0x00	; 0
    7462:	4c e0       	ldi	r20, 0x0C	; 12
    7464:	50 e0       	ldi	r21, 0x00	; 0
    7466:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(set1,'\0',ARRYLEN);
    746a:	82 e4       	ldi	r24, 0x42	; 66
    746c:	90 e1       	ldi	r25, 0x10	; 16
    746e:	60 e0       	ldi	r22, 0x00	; 0
    7470:	70 e0       	ldi	r23, 0x00	; 0
    7472:	4c e0       	ldi	r20, 0x0C	; 12
    7474:	50 e0       	ldi	r21, 0x00	; 0
    7476:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			memset(set2,'\0',ARRYLEN);
    747a:	8e e4       	ldi	r24, 0x4E	; 78
    747c:	90 e1       	ldi	r25, 0x10	; 16
    747e:	60 e0       	ldi	r22, 0x00	; 0
    7480:	70 e0       	ldi	r23, 0x00	; 0
    7482:	4c e0       	ldi	r20, 0x0C	; 12
    7484:	50 e0       	ldi	r21, 0x00	; 0
    7486:	0e 94 e4 44 	call	0x89c8	; 0x89c8 <memset>
			rangeMsg.prim = PD_RANGING_FAST_REQUEST_EXECUTE;
    748a:	85 e1       	ldi	r24, 0x15	; 21
    748c:	80 93 92 0f 	sts	0x0F92, r24
			rangingLastCmd = RANGING_FAST_START;
    7490:	84 e0       	ldi	r24, 0x04	; 4
    7492:	80 93 a4 07 	sts	0x07A4, r24
    7496:	03 c0       	rjmp	.+6      	; 0x749e <RangingMode+0x142>
			break;
		case RANGING_FAST_ANSWER1 : rangeMsg.prim = PD_RANGING_FAST_ANSWER1_EXECUTE; break;
    7498:	86 e1       	ldi	r24, 0x16	; 22
    749a:	80 93 92 0f 	sts	0x0F92, r24
	}

	rangeMsg.len = ARRYLEN;
    749e:	8c e0       	ldi	r24, 0x0C	; 12
    74a0:	80 93 99 0f 	sts	0x0F99, r24
	PDSap (&rangeMsg);
    74a4:	82 e9       	ldi	r24, 0x92	; 146
    74a6:	9f e0       	ldi	r25, 0x0F	; 15
    74a8:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <PDSap>
}
    74ac:	0f 90       	pop	r0
    74ae:	0f 90       	pop	r0
    74b0:	0f 90       	pop	r0
    74b2:	0f 90       	pop	r0
    74b4:	0f 90       	pop	r0
    74b6:	cf 91       	pop	r28
    74b8:	df 91       	pop	r29
    74ba:	08 95       	ret

000074bc <getDistance>:
 *
 * getDistance calculates indirecty the distance.
 *
 */
MyDouble32T getDistance(void)
{
    74bc:	df 93       	push	r29
    74be:	cf 93       	push	r28
    74c0:	00 d0       	rcall	.+0      	; 0x74c2 <getDistance+0x6>
    74c2:	00 d0       	rcall	.+0      	; 0x74c4 <getDistance+0x8>
    74c4:	cd b7       	in	r28, 0x3d	; 61
    74c6:	de b7       	in	r29, 0x3e	; 62
	MyDouble32T distance;

	distance = dist(&set1[0],&set2[0]);
    74c8:	82 e4       	ldi	r24, 0x42	; 66
    74ca:	90 e1       	ldi	r25, 0x10	; 16
    74cc:	2e e4       	ldi	r18, 0x4E	; 78
    74ce:	30 e1       	ldi	r19, 0x10	; 16
    74d0:	b9 01       	movw	r22, r18
    74d2:	0e 94 a1 3a 	call	0x7542	; 0x7542 <dist>
    74d6:	dc 01       	movw	r26, r24
    74d8:	cb 01       	movw	r24, r22
    74da:	89 83       	std	Y+1, r24	; 0x01
    74dc:	9a 83       	std	Y+2, r25	; 0x02
    74de:	ab 83       	std	Y+3, r26	; 0x03
    74e0:	bc 83       	std	Y+4, r27	; 0x04

	/* measurements between 0.00[m] and -0.99[m] will changed to 0.0[m]
	 * measurements below -0.99[m] will changed to -1.0[m] (ERROR) */
	return distance;
    74e2:	89 81       	ldd	r24, Y+1	; 0x01
    74e4:	9a 81       	ldd	r25, Y+2	; 0x02
    74e6:	ab 81       	ldd	r26, Y+3	; 0x03
    74e8:	bc 81       	ldd	r27, Y+4	; 0x04
}
    74ea:	bc 01       	movw	r22, r24
    74ec:	cd 01       	movw	r24, r26
    74ee:	0f 90       	pop	r0
    74f0:	0f 90       	pop	r0
    74f2:	0f 90       	pop	r0
    74f4:	0f 90       	pop	r0
    74f6:	cf 91       	pop	r28
    74f8:	df 91       	pop	r29
    74fa:	08 95       	ret

000074fc <getRSSI>:
 *
 * getRSSI returns the measured RSSI value
 *
 */
MyByte8T getRSSI(void)
{
    74fc:	df 93       	push	r29
    74fe:	cf 93       	push	r28
    7500:	00 d0       	rcall	.+0      	; 0x7502 <getRSSI+0x6>
    7502:	cd b7       	in	r28, 0x3d	; 61
    7504:	de b7       	in	r29, 0x3e	; 62
	return ( set1[RSSI] + set2[RSSI] ) / 2;
    7506:	80 91 4d 10 	lds	r24, 0x104D
    750a:	28 2f       	mov	r18, r24
    750c:	30 e0       	ldi	r19, 0x00	; 0
    750e:	80 91 59 10 	lds	r24, 0x1059
    7512:	88 2f       	mov	r24, r24
    7514:	90 e0       	ldi	r25, 0x00	; 0
    7516:	82 0f       	add	r24, r18
    7518:	93 1f       	adc	r25, r19
    751a:	9a 83       	std	Y+2, r25	; 0x02
    751c:	89 83       	std	Y+1, r24	; 0x01
    751e:	89 81       	ldd	r24, Y+1	; 0x01
    7520:	9a 81       	ldd	r25, Y+2	; 0x02
    7522:	99 23       	and	r25, r25
    7524:	2c f4       	brge	.+10     	; 0x7530 <getRSSI+0x34>
    7526:	89 81       	ldd	r24, Y+1	; 0x01
    7528:	9a 81       	ldd	r25, Y+2	; 0x02
    752a:	01 96       	adiw	r24, 0x01	; 1
    752c:	9a 83       	std	Y+2, r25	; 0x02
    752e:	89 83       	std	Y+1, r24	; 0x01
    7530:	89 81       	ldd	r24, Y+1	; 0x01
    7532:	9a 81       	ldd	r25, Y+2	; 0x02
    7534:	95 95       	asr	r25
    7536:	87 95       	ror	r24
}
    7538:	0f 90       	pop	r0
    753a:	0f 90       	pop	r0
    753c:	cf 91       	pop	r28
    753e:	df 91       	pop	r29
    7540:	08 95       	ret

00007542 <dist>:
 *
 * dist calculates the distance.
 *
 */
MyDouble32T dist(MyByte8T *p1, MyByte8T *p2)
{
    7542:	df 93       	push	r29
    7544:	cf 93       	push	r28
    7546:	cd b7       	in	r28, 0x3d	; 61
    7548:	de b7       	in	r29, 0x3e	; 62
    754a:	64 97       	sbiw	r28, 0x14	; 20
    754c:	0f b6       	in	r0, 0x3f	; 63
    754e:	f8 94       	cli
    7550:	de bf       	out	0x3e, r29	; 62
    7552:	0f be       	out	0x3f, r0	; 63
    7554:	cd bf       	out	0x3d, r28	; 61
    7556:	9a 8b       	std	Y+18, r25	; 0x12
    7558:	89 8b       	std	Y+17, r24	; 0x11
    755a:	7c 8b       	std	Y+20, r23	; 0x14
    755c:	6b 8b       	std	Y+19, r22	; 0x13
	MyDouble32T avg = -1.0;
    755e:	80 e0       	ldi	r24, 0x00	; 0
    7560:	90 e0       	ldi	r25, 0x00	; 0
    7562:	a0 e8       	ldi	r26, 0x80	; 128
    7564:	bf eb       	ldi	r27, 0xBF	; 191
    7566:	8d 87       	std	Y+13, r24	; 0x0d
    7568:	9e 87       	std	Y+14, r25	; 0x0e
    756a:	af 87       	std	Y+15, r26	; 0x0f
    756c:	b8 8b       	std	Y+16, r27	; 0x10
	MyDouble32T speedofmedium = SPEED_OF_AIR;
    756e:	8f e6       	ldi	r24, 0x6F	; 111
    7570:	95 ee       	ldi	r25, 0xE5	; 229
    7572:	a5 e9       	ldi	r26, 0x95	; 149
    7574:	b3 e4       	ldi	r27, 0x43	; 67
    7576:	89 87       	std	Y+9, r24	; 0x09
    7578:	9a 87       	std	Y+10, r25	; 0x0a
    757a:	ab 87       	std	Y+11, r26	; 0x0b
    757c:	bc 87       	std	Y+12, r27	; 0x0c

	/* calculate the one way airtime for local station */
	MyDouble32T distanceD2R = delay(p1);
    757e:	89 89       	ldd	r24, Y+17	; 0x11
    7580:	9a 89       	ldd	r25, Y+18	; 0x12
    7582:	0e 94 82 3b 	call	0x7704	; 0x7704 <delay>
    7586:	dc 01       	movw	r26, r24
    7588:	cb 01       	movw	r24, r22
    758a:	8d 83       	std	Y+5, r24	; 0x05
    758c:	9e 83       	std	Y+6, r25	; 0x06
    758e:	af 83       	std	Y+7, r26	; 0x07
    7590:	b8 87       	std	Y+8, r27	; 0x08
	MyDouble32T distanceR2D = 0.0;
    7592:	80 e0       	ldi	r24, 0x00	; 0
    7594:	90 e0       	ldi	r25, 0x00	; 0
    7596:	a0 e0       	ldi	r26, 0x00	; 0
    7598:	b0 e0       	ldi	r27, 0x00	; 0
    759a:	89 83       	std	Y+1, r24	; 0x01
    759c:	9a 83       	std	Y+2, r25	; 0x02
    759e:	ab 83       	std	Y+3, r26	; 0x03
    75a0:	bc 83       	std	Y+4, r27	; 0x04

	/* calculate the distance in [m] for local station */
	distanceD2R *=(speedofmedium);
    75a2:	6d 81       	ldd	r22, Y+5	; 0x05
    75a4:	7e 81       	ldd	r23, Y+6	; 0x06
    75a6:	8f 81       	ldd	r24, Y+7	; 0x07
    75a8:	98 85       	ldd	r25, Y+8	; 0x08
    75aa:	29 85       	ldd	r18, Y+9	; 0x09
    75ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    75ae:	4b 85       	ldd	r20, Y+11	; 0x0b
    75b0:	5c 85       	ldd	r21, Y+12	; 0x0c
    75b2:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    75b6:	dc 01       	movw	r26, r24
    75b8:	cb 01       	movw	r24, r22
    75ba:	8d 83       	std	Y+5, r24	; 0x05
    75bc:	9e 83       	std	Y+6, r25	; 0x06
    75be:	af 83       	std	Y+7, r26	; 0x07
    75c0:	b8 87       	std	Y+8, r27	; 0x08

	/* second set is empty if its FAST ranging */
	if (rangingLastCmd == RANGING_START)
    75c2:	80 91 a4 07 	lds	r24, 0x07A4
    75c6:	81 30       	cpi	r24, 0x01	; 1
    75c8:	09 f0       	breq	.+2      	; 0x75cc <dist+0x8a>
    75ca:	78 c0       	rjmp	.+240    	; 0x76bc <dist+0x17a>
	{
		/* calculate the one way airtime for remote station */
		distanceR2D = delay(p2);
    75cc:	8b 89       	ldd	r24, Y+19	; 0x13
    75ce:	9c 89       	ldd	r25, Y+20	; 0x14
    75d0:	0e 94 82 3b 	call	0x7704	; 0x7704 <delay>
    75d4:	dc 01       	movw	r26, r24
    75d6:	cb 01       	movw	r24, r22
    75d8:	89 83       	std	Y+1, r24	; 0x01
    75da:	9a 83       	std	Y+2, r25	; 0x02
    75dc:	ab 83       	std	Y+3, r26	; 0x03
    75de:	bc 83       	std	Y+4, r27	; 0x04

		/* calculate the distance in [m] for remote station */
		distanceR2D *=(speedofmedium);
    75e0:	69 81       	ldd	r22, Y+1	; 0x01
    75e2:	7a 81       	ldd	r23, Y+2	; 0x02
    75e4:	8b 81       	ldd	r24, Y+3	; 0x03
    75e6:	9c 81       	ldd	r25, Y+4	; 0x04
    75e8:	29 85       	ldd	r18, Y+9	; 0x09
    75ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    75ec:	4b 85       	ldd	r20, Y+11	; 0x0b
    75ee:	5c 85       	ldd	r21, Y+12	; 0x0c
    75f0:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    75f4:	dc 01       	movw	r26, r24
    75f6:	cb 01       	movw	r24, r22
    75f8:	89 83       	std	Y+1, r24	; 0x01
    75fa:	9a 83       	std	Y+2, r25	; 0x02
    75fc:	ab 83       	std	Y+3, r26	; 0x03
    75fe:	bc 83       	std	Y+4, r27	; 0x04


		/* the difference between the measurement results from local-
		* and remote station should not be to large */
		if(distanceR2D>distanceD2R)
    7600:	69 81       	ldd	r22, Y+1	; 0x01
    7602:	7a 81       	ldd	r23, Y+2	; 0x02
    7604:	8b 81       	ldd	r24, Y+3	; 0x03
    7606:	9c 81       	ldd	r25, Y+4	; 0x04
    7608:	2d 81       	ldd	r18, Y+5	; 0x05
    760a:	3e 81       	ldd	r19, Y+6	; 0x06
    760c:	4f 81       	ldd	r20, Y+7	; 0x07
    760e:	58 85       	ldd	r21, Y+8	; 0x08
    7610:	0e 94 04 43 	call	0x8608	; 0x8608 <__gesf2>
    7614:	18 16       	cp	r1, r24
    7616:	e4 f4       	brge	.+56     	; 0x7650 <dist+0x10e>
		{
			if((distanceR2D-distanceD2R)>MAX_DIFF_ALLOWED) rangingPIB.error |= STAT_RANGING_VALUE_ERROR;
    7618:	69 81       	ldd	r22, Y+1	; 0x01
    761a:	7a 81       	ldd	r23, Y+2	; 0x02
    761c:	8b 81       	ldd	r24, Y+3	; 0x03
    761e:	9c 81       	ldd	r25, Y+4	; 0x04
    7620:	2d 81       	ldd	r18, Y+5	; 0x05
    7622:	3e 81       	ldd	r19, Y+6	; 0x06
    7624:	4f 81       	ldd	r20, Y+7	; 0x07
    7626:	58 85       	ldd	r21, Y+8	; 0x08
    7628:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    762c:	dc 01       	movw	r26, r24
    762e:	cb 01       	movw	r24, r22
    7630:	bc 01       	movw	r22, r24
    7632:	cd 01       	movw	r24, r26
    7634:	20 e0       	ldi	r18, 0x00	; 0
    7636:	30 e0       	ldi	r19, 0x00	; 0
    7638:	40 ec       	ldi	r20, 0xC0	; 192
    763a:	50 e4       	ldi	r21, 0x40	; 64
    763c:	0e 94 04 43 	call	0x8608	; 0x8608 <__gesf2>
    7640:	18 16       	cp	r1, r24
    7642:	0c f5       	brge	.+66     	; 0x7686 <dist+0x144>
    7644:	80 91 8c 0f 	lds	r24, 0x0F8C
    7648:	80 68       	ori	r24, 0x80	; 128
    764a:	80 93 8c 0f 	sts	0x0F8C, r24
    764e:	1b c0       	rjmp	.+54     	; 0x7686 <dist+0x144>
		}else{
			if((distanceD2R-distanceR2D)>MAX_DIFF_ALLOWED) rangingPIB.error |= STAT_RANGING_VALUE_ERROR;
    7650:	6d 81       	ldd	r22, Y+5	; 0x05
    7652:	7e 81       	ldd	r23, Y+6	; 0x06
    7654:	8f 81       	ldd	r24, Y+7	; 0x07
    7656:	98 85       	ldd	r25, Y+8	; 0x08
    7658:	29 81       	ldd	r18, Y+1	; 0x01
    765a:	3a 81       	ldd	r19, Y+2	; 0x02
    765c:	4b 81       	ldd	r20, Y+3	; 0x03
    765e:	5c 81       	ldd	r21, Y+4	; 0x04
    7660:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    7664:	dc 01       	movw	r26, r24
    7666:	cb 01       	movw	r24, r22
    7668:	bc 01       	movw	r22, r24
    766a:	cd 01       	movw	r24, r26
    766c:	20 e0       	ldi	r18, 0x00	; 0
    766e:	30 e0       	ldi	r19, 0x00	; 0
    7670:	40 ec       	ldi	r20, 0xC0	; 192
    7672:	50 e4       	ldi	r21, 0x40	; 64
    7674:	0e 94 04 43 	call	0x8608	; 0x8608 <__gesf2>
    7678:	18 16       	cp	r1, r24
    767a:	2c f4       	brge	.+10     	; 0x7686 <dist+0x144>
    767c:	80 91 8c 0f 	lds	r24, 0x0F8C
    7680:	80 68       	ori	r24, 0x80	; 128
    7682:	80 93 8c 0f 	sts	0x0F8C, r24
		}

		avg  = ((distanceR2D + distanceD2R )/2.0); /* [m] */
    7686:	69 81       	ldd	r22, Y+1	; 0x01
    7688:	7a 81       	ldd	r23, Y+2	; 0x02
    768a:	8b 81       	ldd	r24, Y+3	; 0x03
    768c:	9c 81       	ldd	r25, Y+4	; 0x04
    768e:	2d 81       	ldd	r18, Y+5	; 0x05
    7690:	3e 81       	ldd	r19, Y+6	; 0x06
    7692:	4f 81       	ldd	r20, Y+7	; 0x07
    7694:	58 85       	ldd	r21, Y+8	; 0x08
    7696:	0e 94 56 41 	call	0x82ac	; 0x82ac <__addsf3>
    769a:	dc 01       	movw	r26, r24
    769c:	cb 01       	movw	r24, r22
    769e:	bc 01       	movw	r22, r24
    76a0:	cd 01       	movw	r24, r26
    76a2:	20 e0       	ldi	r18, 0x00	; 0
    76a4:	30 e0       	ldi	r19, 0x00	; 0
    76a6:	40 e0       	ldi	r20, 0x00	; 0
    76a8:	50 e4       	ldi	r21, 0x40	; 64
    76aa:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    76ae:	dc 01       	movw	r26, r24
    76b0:	cb 01       	movw	r24, r22
    76b2:	8d 87       	std	Y+13, r24	; 0x0d
    76b4:	9e 87       	std	Y+14, r25	; 0x0e
    76b6:	af 87       	std	Y+15, r26	; 0x0f
    76b8:	b8 8b       	std	Y+16, r27	; 0x10
    76ba:	15 c0       	rjmp	.+42     	; 0x76e6 <dist+0x1a4>
	}
	else if (rangingLastCmd == RANGING_FAST_START)
    76bc:	80 91 a4 07 	lds	r24, 0x07A4
    76c0:	84 30       	cpi	r24, 0x04	; 4
    76c2:	49 f4       	brne	.+18     	; 0x76d6 <dist+0x194>
	{
		avg = distanceD2R;
    76c4:	8d 81       	ldd	r24, Y+5	; 0x05
    76c6:	9e 81       	ldd	r25, Y+6	; 0x06
    76c8:	af 81       	ldd	r26, Y+7	; 0x07
    76ca:	b8 85       	ldd	r27, Y+8	; 0x08
    76cc:	8d 87       	std	Y+13, r24	; 0x0d
    76ce:	9e 87       	std	Y+14, r25	; 0x0e
    76d0:	af 87       	std	Y+15, r26	; 0x0f
    76d2:	b8 8b       	std	Y+16, r27	; 0x10
    76d4:	08 c0       	rjmp	.+16     	; 0x76e6 <dist+0x1a4>
	}
	else
	{
		/* should not occure */
		avg = 0.0;
    76d6:	80 e0       	ldi	r24, 0x00	; 0
    76d8:	90 e0       	ldi	r25, 0x00	; 0
    76da:	a0 e0       	ldi	r26, 0x00	; 0
    76dc:	b0 e0       	ldi	r27, 0x00	; 0
    76de:	8d 87       	std	Y+13, r24	; 0x0d
    76e0:	9e 87       	std	Y+14, r25	; 0x0e
    76e2:	af 87       	std	Y+15, r26	; 0x0f
    76e4:	b8 8b       	std	Y+16, r27	; 0x10
	}

	return avg;
    76e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    76e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    76ea:	af 85       	ldd	r26, Y+15	; 0x0f
    76ec:	b8 89       	ldd	r27, Y+16	; 0x10
}
    76ee:	bc 01       	movw	r22, r24
    76f0:	cd 01       	movw	r24, r26
    76f2:	64 96       	adiw	r28, 0x14	; 20
    76f4:	0f b6       	in	r0, 0x3f	; 63
    76f6:	f8 94       	cli
    76f8:	de bf       	out	0x3e, r29	; 62
    76fa:	0f be       	out	0x3f, r0	; 63
    76fc:	cd bf       	out	0x3d, r28	; 61
    76fe:	cf 91       	pop	r28
    7700:	df 91       	pop	r29
    7702:	08 95       	ret

00007704 <delay>:
 * Delay calculates the airtime of packet WITHOUT processing time in chip.
 * Its a helper function for dist(..,..);
 *
 */
MyDouble32T delay(MyByte8T *p)
{
    7704:	af 92       	push	r10
    7706:	bf 92       	push	r11
    7708:	cf 92       	push	r12
    770a:	df 92       	push	r13
    770c:	ef 92       	push	r14
    770e:	ff 92       	push	r15
    7710:	0f 93       	push	r16
    7712:	1f 93       	push	r17
    7714:	df 93       	push	r29
    7716:	cf 93       	push	r28
    7718:	cd b7       	in	r28, 0x3d	; 61
    771a:	de b7       	in	r29, 0x3e	; 62
    771c:	e8 97       	sbiw	r28, 0x38	; 56
    771e:	0f b6       	in	r0, 0x3f	; 63
    7720:	f8 94       	cli
    7722:	de bf       	out	0x3e, r29	; 62
    7724:	0f be       	out	0x3f, r0	; 63
    7726:	cd bf       	out	0x3d, r28	; 61
    7728:	9c a7       	std	Y+44, r25	; 0x2c
    772a:	8b a7       	std	Y+43, r24	; 0x2b
	/* clock period [MHz] */
	const MyDouble32T clk_4MHz  = 4;
    772c:	80 e0       	ldi	r24, 0x00	; 0
    772e:	90 e0       	ldi	r25, 0x00	; 0
    7730:	a0 e8       	ldi	r26, 0x80	; 128
    7732:	b0 e4       	ldi	r27, 0x40	; 64
    7734:	8f a3       	std	Y+39, r24	; 0x27
    7736:	98 a7       	std	Y+40, r25	; 0x28
    7738:	a9 a7       	std	Y+41, r26	; 0x29
    773a:	ba a7       	std	Y+42, r27	; 0x2a
	const MyDouble32T clk_32MHz = 32;
    773c:	80 e0       	ldi	r24, 0x00	; 0
    773e:	90 e0       	ldi	r25, 0x00	; 0
    7740:	a0 e0       	ldi	r26, 0x00	; 0
    7742:	b2 e4       	ldi	r27, 0x42	; 66
    7744:	8b a3       	std	Y+35, r24	; 0x23
    7746:	9c a3       	std	Y+36, r25	; 0x24
    7748:	ad a3       	std	Y+37, r26	; 0x25
    774a:	be a3       	std	Y+38, r27	; 0x26
	/* Scaled 1:20 divider's clock period [MHz] */
	const MyDouble32T clk_lod20 = (2000.0/244175);
    774c:	87 ee       	ldi	r24, 0xE7	; 231
    774e:	92 e3       	ldi	r25, 0x32	; 50
    7750:	a6 e0       	ldi	r26, 0x06	; 6
    7752:	bc e3       	ldi	r27, 0x3C	; 60
    7754:	8f 8f       	std	Y+31, r24	; 0x1f
    7756:	98 a3       	std	Y+32, r25	; 0x20
    7758:	a9 a3       	std	Y+33, r26	; 0x21
    775a:	ba a3       	std	Y+34, r27	; 0x22

	const MyWord16T PulseDetUcMax = 5;
    775c:	85 e0       	ldi	r24, 0x05	; 5
    775e:	90 e0       	ldi	r25, 0x00	; 0
    7760:	9e 8f       	std	Y+30, r25	; 0x1e
    7762:	8d 8f       	std	Y+29, r24	; 0x1d
	const MyWord16T PulseDetUcMax_table[16] = {1, 2, 4, 8, 16, 24, 32, 40, 48, 56, 64, 1, 1, 1, 1, 1};

	MyDouble32T res;

	MyDword32T TxRespTime = (p[TXRESPTIME_H]        << 8) | (p[TXRESPTIME_L]);
    7764:	8b a5       	ldd	r24, Y+43	; 0x2b
    7766:	9c a5       	ldd	r25, Y+44	; 0x2c
    7768:	fc 01       	movw	r30, r24
    776a:	34 96       	adiw	r30, 0x04	; 4
    776c:	80 81       	ld	r24, Z
    776e:	88 2f       	mov	r24, r24
    7770:	90 e0       	ldi	r25, 0x00	; 0
    7772:	38 2f       	mov	r19, r24
    7774:	22 27       	eor	r18, r18
    7776:	8b a5       	ldd	r24, Y+43	; 0x2b
    7778:	9c a5       	ldd	r25, Y+44	; 0x2c
    777a:	fc 01       	movw	r30, r24
    777c:	33 96       	adiw	r30, 0x03	; 3
    777e:	80 81       	ld	r24, Z
    7780:	88 2f       	mov	r24, r24
    7782:	90 e0       	ldi	r25, 0x00	; 0
    7784:	82 2b       	or	r24, r18
    7786:	93 2b       	or	r25, r19
    7788:	aa 27       	eor	r26, r26
    778a:	97 fd       	sbrc	r25, 7
    778c:	a0 95       	com	r26
    778e:	ba 2f       	mov	r27, r26
    7790:	8d 8b       	std	Y+21, r24	; 0x15
    7792:	9e 8b       	std	Y+22, r25	; 0x16
    7794:	af 8b       	std	Y+23, r26	; 0x17
    7796:	b8 8f       	std	Y+24, r27	; 0x18
	MyLong32T  RxUcSum    = (p[TOAOFFSETMEANACK_H]  << 8) | (p[TOAOFFSETMEANACK_L]);
    7798:	8b a5       	ldd	r24, Y+43	; 0x2b
    779a:	9c a5       	ldd	r25, Y+44	; 0x2c
    779c:	fc 01       	movw	r30, r24
    779e:	32 96       	adiw	r30, 0x02	; 2
    77a0:	80 81       	ld	r24, Z
    77a2:	88 2f       	mov	r24, r24
    77a4:	90 e0       	ldi	r25, 0x00	; 0
    77a6:	38 2f       	mov	r19, r24
    77a8:	22 27       	eor	r18, r18
    77aa:	8b a5       	ldd	r24, Y+43	; 0x2b
    77ac:	9c a5       	ldd	r25, Y+44	; 0x2c
    77ae:	fc 01       	movw	r30, r24
    77b0:	31 96       	adiw	r30, 0x01	; 1
    77b2:	80 81       	ld	r24, Z
    77b4:	88 2f       	mov	r24, r24
    77b6:	90 e0       	ldi	r25, 0x00	; 0
    77b8:	82 2b       	or	r24, r18
    77ba:	93 2b       	or	r25, r19
    77bc:	aa 27       	eor	r26, r26
    77be:	97 fd       	sbrc	r25, 7
    77c0:	a0 95       	com	r26
    77c2:	ba 2f       	mov	r27, r26
    77c4:	89 8b       	std	Y+17, r24	; 0x11
    77c6:	9a 8b       	std	Y+18, r25	; 0x12
    77c8:	ab 8b       	std	Y+19, r26	; 0x13
    77ca:	bc 8b       	std	Y+20, r27	; 0x14
	MyLong32T  TxUcSum    = (p[TOAOFFSETMEANDATA_H] << 8) | (p[TOAOFFSETMEANDATA_L]);
    77cc:	8b a5       	ldd	r24, Y+43	; 0x2b
    77ce:	9c a5       	ldd	r25, Y+44	; 0x2c
    77d0:	fc 01       	movw	r30, r24
    77d2:	37 96       	adiw	r30, 0x07	; 7
    77d4:	80 81       	ld	r24, Z
    77d6:	88 2f       	mov	r24, r24
    77d8:	90 e0       	ldi	r25, 0x00	; 0
    77da:	38 2f       	mov	r19, r24
    77dc:	22 27       	eor	r18, r18
    77de:	8b a5       	ldd	r24, Y+43	; 0x2b
    77e0:	9c a5       	ldd	r25, Y+44	; 0x2c
    77e2:	fc 01       	movw	r30, r24
    77e4:	36 96       	adiw	r30, 0x06	; 6
    77e6:	80 81       	ld	r24, Z
    77e8:	88 2f       	mov	r24, r24
    77ea:	90 e0       	ldi	r25, 0x00	; 0
    77ec:	82 2b       	or	r24, r18
    77ee:	93 2b       	or	r25, r19
    77f0:	aa 27       	eor	r26, r26
    77f2:	97 fd       	sbrc	r25, 7
    77f4:	a0 95       	com	r26
    77f6:	ba 2f       	mov	r27, r26
    77f8:	8d 87       	std	Y+13, r24	; 0x0d
    77fa:	9e 87       	std	Y+14, r25	; 0x0e
    77fc:	af 87       	std	Y+15, r26	; 0x0f
    77fe:	b8 8b       	std	Y+16, r27	; 0x10

	MyLong32T  RxGateOff  = p[PHASEOFFSETACK]  == 7 ? 7 : 6 - p[PHASEOFFSETACK];
    7800:	eb a5       	ldd	r30, Y+43	; 0x2b
    7802:	fc a5       	ldd	r31, Y+44	; 0x2c
    7804:	80 81       	ld	r24, Z
    7806:	87 30       	cpi	r24, 0x07	; 7
    7808:	99 f0       	breq	.+38     	; 0x7830 <delay+0x12c>
    780a:	eb a5       	ldd	r30, Y+43	; 0x2b
    780c:	fc a5       	ldd	r31, Y+44	; 0x2c
    780e:	80 81       	ld	r24, Z
    7810:	28 2f       	mov	r18, r24
    7812:	30 e0       	ldi	r19, 0x00	; 0
    7814:	86 e0       	ldi	r24, 0x06	; 6
    7816:	90 e0       	ldi	r25, 0x00	; 0
    7818:	82 1b       	sub	r24, r18
    781a:	93 0b       	sbc	r25, r19
    781c:	9c 01       	movw	r18, r24
    781e:	44 27       	eor	r20, r20
    7820:	37 fd       	sbrc	r19, 7
    7822:	40 95       	com	r20
    7824:	54 2f       	mov	r21, r20
    7826:	2d ab       	std	Y+53, r18	; 0x35
    7828:	3e ab       	std	Y+54, r19	; 0x36
    782a:	4f ab       	std	Y+55, r20	; 0x37
    782c:	58 af       	std	Y+56, r21	; 0x38
    782e:	08 c0       	rjmp	.+16     	; 0x7840 <delay+0x13c>
    7830:	87 e0       	ldi	r24, 0x07	; 7
    7832:	90 e0       	ldi	r25, 0x00	; 0
    7834:	a0 e0       	ldi	r26, 0x00	; 0
    7836:	b0 e0       	ldi	r27, 0x00	; 0
    7838:	8d ab       	std	Y+53, r24	; 0x35
    783a:	9e ab       	std	Y+54, r25	; 0x36
    783c:	af ab       	std	Y+55, r26	; 0x37
    783e:	b8 af       	std	Y+56, r27	; 0x38
    7840:	2d a9       	ldd	r18, Y+53	; 0x35
    7842:	3e a9       	ldd	r19, Y+54	; 0x36
    7844:	4f a9       	ldd	r20, Y+55	; 0x37
    7846:	58 ad       	ldd	r21, Y+56	; 0x38
    7848:	29 87       	std	Y+9, r18	; 0x09
    784a:	3a 87       	std	Y+10, r19	; 0x0a
    784c:	4b 87       	std	Y+11, r20	; 0x0b
    784e:	5c 87       	std	Y+12, r21	; 0x0c
	MyLong32T  TxGateOff  = p[PHASEOFFSETDATA] == 7 ? 7 : 6 - p[PHASEOFFSETDATA];
    7850:	8b a5       	ldd	r24, Y+43	; 0x2b
    7852:	9c a5       	ldd	r25, Y+44	; 0x2c
    7854:	fc 01       	movw	r30, r24
    7856:	35 96       	adiw	r30, 0x05	; 5
    7858:	80 81       	ld	r24, Z
    785a:	87 30       	cpi	r24, 0x07	; 7
    785c:	a9 f0       	breq	.+42     	; 0x7888 <delay+0x184>
    785e:	8b a5       	ldd	r24, Y+43	; 0x2b
    7860:	9c a5       	ldd	r25, Y+44	; 0x2c
    7862:	fc 01       	movw	r30, r24
    7864:	35 96       	adiw	r30, 0x05	; 5
    7866:	80 81       	ld	r24, Z
    7868:	28 2f       	mov	r18, r24
    786a:	30 e0       	ldi	r19, 0x00	; 0
    786c:	86 e0       	ldi	r24, 0x06	; 6
    786e:	90 e0       	ldi	r25, 0x00	; 0
    7870:	82 1b       	sub	r24, r18
    7872:	93 0b       	sbc	r25, r19
    7874:	9c 01       	movw	r18, r24
    7876:	44 27       	eor	r20, r20
    7878:	37 fd       	sbrc	r19, 7
    787a:	40 95       	com	r20
    787c:	54 2f       	mov	r21, r20
    787e:	29 ab       	std	Y+49, r18	; 0x31
    7880:	3a ab       	std	Y+50, r19	; 0x32
    7882:	4b ab       	std	Y+51, r20	; 0x33
    7884:	5c ab       	std	Y+52, r21	; 0x34
    7886:	08 c0       	rjmp	.+16     	; 0x7898 <delay+0x194>
    7888:	87 e0       	ldi	r24, 0x07	; 7
    788a:	90 e0       	ldi	r25, 0x00	; 0
    788c:	a0 e0       	ldi	r26, 0x00	; 0
    788e:	b0 e0       	ldi	r27, 0x00	; 0
    7890:	89 ab       	std	Y+49, r24	; 0x31
    7892:	9a ab       	std	Y+50, r25	; 0x32
    7894:	ab ab       	std	Y+51, r26	; 0x33
    7896:	bc ab       	std	Y+52, r27	; 0x34
    7898:	29 a9       	ldd	r18, Y+49	; 0x31
    789a:	3a a9       	ldd	r19, Y+50	; 0x32
    789c:	4b a9       	ldd	r20, Y+51	; 0x33
    789e:	5c a9       	ldd	r21, Y+52	; 0x34
    78a0:	2d 83       	std	Y+5, r18	; 0x05
    78a2:	3e 83       	std	Y+6, r19	; 0x06
    78a4:	4f 83       	std	Y+7, r20	; 0x07
    78a6:	58 87       	std	Y+8, r21	; 0x08

	MyDouble32T rangingConst = (modeSet.fec) ? modeSet.rangingConst_FECon : modeSet.rangingConst_FECoff;
    78a8:	80 91 f6 0e 	lds	r24, 0x0EF6
    78ac:	88 23       	and	r24, r24
    78ae:	69 f0       	breq	.+26     	; 0x78ca <delay+0x1c6>
    78b0:	80 91 f7 0e 	lds	r24, 0x0EF7
    78b4:	90 91 f8 0e 	lds	r25, 0x0EF8
    78b8:	a0 91 f9 0e 	lds	r26, 0x0EF9
    78bc:	b0 91 fa 0e 	lds	r27, 0x0EFA
    78c0:	8d a7       	std	Y+45, r24	; 0x2d
    78c2:	9e a7       	std	Y+46, r25	; 0x2e
    78c4:	af a7       	std	Y+47, r26	; 0x2f
    78c6:	b8 ab       	std	Y+48, r27	; 0x30
    78c8:	0c c0       	rjmp	.+24     	; 0x78e2 <delay+0x1de>
    78ca:	20 91 fb 0e 	lds	r18, 0x0EFB
    78ce:	30 91 fc 0e 	lds	r19, 0x0EFC
    78d2:	40 91 fd 0e 	lds	r20, 0x0EFD
    78d6:	50 91 fe 0e 	lds	r21, 0x0EFE
    78da:	2d a7       	std	Y+45, r18	; 0x2d
    78dc:	3e a7       	std	Y+46, r19	; 0x2e
    78de:	4f a7       	std	Y+47, r20	; 0x2f
    78e0:	58 ab       	std	Y+48, r21	; 0x30
    78e2:	8d a5       	ldd	r24, Y+45	; 0x2d
    78e4:	9e a5       	ldd	r25, Y+46	; 0x2e
    78e6:	af a5       	ldd	r26, Y+47	; 0x2f
    78e8:	b8 a9       	ldd	r27, Y+48	; 0x30
    78ea:	89 83       	std	Y+1, r24	; 0x01
    78ec:	9a 83       	std	Y+2, r25	; 0x02
    78ee:	ab 83       	std	Y+3, r26	; 0x03
    78f0:	bc 83       	std	Y+4, r27	; 0x04

	if (modeSet.fdma == 0)
    78f2:	80 91 f4 0e 	lds	r24, 0x0EF4
    78f6:	88 23       	and	r24, r24
    78f8:	09 f0       	breq	.+2      	; 0x78fc <delay+0x1f8>
    78fa:	9d c0       	rjmp	.+314    	; 0x7a36 <delay+0x332>
	{
		res = ((TxRespTime)/clk_4MHz
    78fc:	6d 89       	ldd	r22, Y+21	; 0x15
    78fe:	7e 89       	ldd	r23, Y+22	; 0x16
    7900:	8f 89       	ldd	r24, Y+23	; 0x17
    7902:	98 8d       	ldd	r25, Y+24	; 0x18
    7904:	0e 94 52 42 	call	0x84a4	; 0x84a4 <__floatunsisf>
    7908:	dc 01       	movw	r26, r24
    790a:	cb 01       	movw	r24, r22
    790c:	bc 01       	movw	r22, r24
    790e:	cd 01       	movw	r24, r26
    7910:	2f a1       	ldd	r18, Y+39	; 0x27
    7912:	38 a5       	ldd	r19, Y+40	; 0x28
    7914:	49 a5       	ldd	r20, Y+41	; 0x29
    7916:	5a a5       	ldd	r21, Y+42	; 0x2a
    7918:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    791c:	dc 01       	movw	r26, r24
    791e:	cb 01       	movw	r24, r22
    7920:	7c 01       	movw	r14, r24
    7922:	8d 01       	movw	r16, r26
    7924:	2d 81       	ldd	r18, Y+5	; 0x05
    7926:	3e 81       	ldd	r19, Y+6	; 0x06
    7928:	4f 81       	ldd	r20, Y+7	; 0x07
    792a:	58 85       	ldd	r21, Y+8	; 0x08
    792c:	89 85       	ldd	r24, Y+9	; 0x09
    792e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7930:	ab 85       	ldd	r26, Y+11	; 0x0b
    7932:	bc 85       	ldd	r27, Y+12	; 0x0c
    7934:	82 0f       	add	r24, r18
    7936:	93 1f       	adc	r25, r19
    7938:	a4 1f       	adc	r26, r20
    793a:	b5 1f       	adc	r27, r21
    793c:	bc 01       	movw	r22, r24
    793e:	cd 01       	movw	r24, r26
    7940:	0e 94 54 42 	call	0x84a8	; 0x84a8 <__floatsisf>
    7944:	dc 01       	movw	r26, r24
    7946:	cb 01       	movw	r24, r22
    7948:	bc 01       	movw	r22, r24
    794a:	cd 01       	movw	r24, r26
    794c:	2b a1       	ldd	r18, Y+35	; 0x23
    794e:	3c a1       	ldd	r19, Y+36	; 0x24
    7950:	4d a1       	ldd	r20, Y+37	; 0x25
    7952:	5e a1       	ldd	r21, Y+38	; 0x26
    7954:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7958:	dc 01       	movw	r26, r24
    795a:	cb 01       	movw	r24, r22
    795c:	9c 01       	movw	r18, r24
    795e:	ad 01       	movw	r20, r26
    7960:	c8 01       	movw	r24, r16
    7962:	b7 01       	movw	r22, r14
    7964:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    7968:	dc 01       	movw	r26, r24
    796a:	cb 01       	movw	r24, r22
    796c:	5c 01       	movw	r10, r24
    796e:	6d 01       	movw	r12, r26
    7970:	2d 85       	ldd	r18, Y+13	; 0x0d
    7972:	3e 85       	ldd	r19, Y+14	; 0x0e
    7974:	4f 85       	ldd	r20, Y+15	; 0x0f
    7976:	58 89       	ldd	r21, Y+16	; 0x10
    7978:	89 89       	ldd	r24, Y+17	; 0x11
    797a:	9a 89       	ldd	r25, Y+18	; 0x12
    797c:	ab 89       	ldd	r26, Y+19	; 0x13
    797e:	bc 89       	ldd	r27, Y+20	; 0x14
    7980:	82 0f       	add	r24, r18
    7982:	93 1f       	adc	r25, r19
    7984:	a4 1f       	adc	r26, r20
    7986:	b5 1f       	adc	r27, r21
    7988:	bc 01       	movw	r22, r24
    798a:	cd 01       	movw	r24, r26
    798c:	0e 94 54 42 	call	0x84a8	; 0x84a8 <__floatsisf>
    7990:	dc 01       	movw	r26, r24
    7992:	cb 01       	movw	r24, r22
    7994:	bc 01       	movw	r22, r24
    7996:	cd 01       	movw	r24, r26
    7998:	2f 8d       	ldd	r18, Y+31	; 0x1f
    799a:	38 a1       	ldd	r19, Y+32	; 0x20
    799c:	49 a1       	ldd	r20, Y+33	; 0x21
    799e:	5a a1       	ldd	r21, Y+34	; 0x22
    79a0:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    79a4:	dc 01       	movw	r26, r24
    79a6:	cb 01       	movw	r24, r22
    79a8:	7c 01       	movw	r14, r24
    79aa:	8d 01       	movw	r16, r26
    79ac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    79ae:	9e 8d       	ldd	r25, Y+30	; 0x1e
    79b0:	88 0f       	add	r24, r24
    79b2:	99 1f       	adc	r25, r25
    79b4:	fc 01       	movw	r30, r24
    79b6:	eb 55       	subi	r30, 0x5B	; 91
    79b8:	f8 4f       	sbci	r31, 0xF8	; 248
    79ba:	80 81       	ld	r24, Z
    79bc:	91 81       	ldd	r25, Z+1	; 0x01
    79be:	cc 01       	movw	r24, r24
    79c0:	a0 e0       	ldi	r26, 0x00	; 0
    79c2:	b0 e0       	ldi	r27, 0x00	; 0
    79c4:	bc 01       	movw	r22, r24
    79c6:	cd 01       	movw	r24, r26
    79c8:	0e 94 52 42 	call	0x84a4	; 0x84a4 <__floatunsisf>
    79cc:	dc 01       	movw	r26, r24
    79ce:	cb 01       	movw	r24, r22
    79d0:	bc 01       	movw	r22, r24
    79d2:	cd 01       	movw	r24, r26
    79d4:	20 e0       	ldi	r18, 0x00	; 0
    79d6:	30 e0       	ldi	r19, 0x00	; 0
    79d8:	40 e0       	ldi	r20, 0x00	; 0
    79da:	50 ec       	ldi	r21, 0xC0	; 192
    79dc:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    79e0:	dc 01       	movw	r26, r24
    79e2:	cb 01       	movw	r24, r22
    79e4:	9c 01       	movw	r18, r24
    79e6:	ad 01       	movw	r20, r26
    79e8:	c8 01       	movw	r24, r16
    79ea:	b7 01       	movw	r22, r14
    79ec:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    79f0:	dc 01       	movw	r26, r24
    79f2:	cb 01       	movw	r24, r22
    79f4:	9c 01       	movw	r18, r24
    79f6:	ad 01       	movw	r20, r26
    79f8:	c6 01       	movw	r24, r12
    79fa:	b5 01       	movw	r22, r10
    79fc:	0e 94 56 41 	call	0x82ac	; 0x82ac <__addsf3>
    7a00:	dc 01       	movw	r26, r24
    7a02:	cb 01       	movw	r24, r22
    7a04:	bc 01       	movw	r22, r24
    7a06:	cd 01       	movw	r24, r26
    7a08:	20 e0       	ldi	r18, 0x00	; 0
    7a0a:	30 e0       	ldi	r19, 0x00	; 0
    7a0c:	40 e0       	ldi	r20, 0x00	; 0
    7a0e:	50 e4       	ldi	r21, 0x40	; 64
    7a10:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7a14:	dc 01       	movw	r26, r24
    7a16:	cb 01       	movw	r24, r22
    7a18:	bc 01       	movw	r22, r24
    7a1a:	cd 01       	movw	r24, r26
    7a1c:	29 81       	ldd	r18, Y+1	; 0x01
    7a1e:	3a 81       	ldd	r19, Y+2	; 0x02
    7a20:	4b 81       	ldd	r20, Y+3	; 0x03
    7a22:	5c 81       	ldd	r21, Y+4	; 0x04
    7a24:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    7a28:	dc 01       	movw	r26, r24
    7a2a:	cb 01       	movw	r24, r22
    7a2c:	89 8f       	std	Y+25, r24	; 0x19
    7a2e:	9a 8f       	std	Y+26, r25	; 0x1a
    7a30:	ab 8f       	std	Y+27, r26	; 0x1b
    7a32:	bc 8f       	std	Y+28, r27	; 0x1c
    7a34:	9c c0       	rjmp	.+312    	; 0x7b6e <delay+0x46a>
        	 	- ((TxGateOff+RxGateOff))/clk_32MHz
			- (TxUcSum+RxUcSum)*clk_lod20/(2.0*PulseDetUcMax_table[PulseDetUcMax]))/2.0
			- rangingConst;
	}else{
		res = (TxRespTime/clk_4MHz - (TxGateOff+RxGateOff)/clk_32MHz
    7a36:	6d 89       	ldd	r22, Y+21	; 0x15
    7a38:	7e 89       	ldd	r23, Y+22	; 0x16
    7a3a:	8f 89       	ldd	r24, Y+23	; 0x17
    7a3c:	98 8d       	ldd	r25, Y+24	; 0x18
    7a3e:	0e 94 52 42 	call	0x84a4	; 0x84a4 <__floatunsisf>
    7a42:	dc 01       	movw	r26, r24
    7a44:	cb 01       	movw	r24, r22
    7a46:	bc 01       	movw	r22, r24
    7a48:	cd 01       	movw	r24, r26
    7a4a:	2f a1       	ldd	r18, Y+39	; 0x27
    7a4c:	38 a5       	ldd	r19, Y+40	; 0x28
    7a4e:	49 a5       	ldd	r20, Y+41	; 0x29
    7a50:	5a a5       	ldd	r21, Y+42	; 0x2a
    7a52:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7a56:	dc 01       	movw	r26, r24
    7a58:	cb 01       	movw	r24, r22
    7a5a:	7c 01       	movw	r14, r24
    7a5c:	8d 01       	movw	r16, r26
    7a5e:	2d 81       	ldd	r18, Y+5	; 0x05
    7a60:	3e 81       	ldd	r19, Y+6	; 0x06
    7a62:	4f 81       	ldd	r20, Y+7	; 0x07
    7a64:	58 85       	ldd	r21, Y+8	; 0x08
    7a66:	89 85       	ldd	r24, Y+9	; 0x09
    7a68:	9a 85       	ldd	r25, Y+10	; 0x0a
    7a6a:	ab 85       	ldd	r26, Y+11	; 0x0b
    7a6c:	bc 85       	ldd	r27, Y+12	; 0x0c
    7a6e:	82 0f       	add	r24, r18
    7a70:	93 1f       	adc	r25, r19
    7a72:	a4 1f       	adc	r26, r20
    7a74:	b5 1f       	adc	r27, r21
    7a76:	bc 01       	movw	r22, r24
    7a78:	cd 01       	movw	r24, r26
    7a7a:	0e 94 54 42 	call	0x84a8	; 0x84a8 <__floatsisf>
    7a7e:	dc 01       	movw	r26, r24
    7a80:	cb 01       	movw	r24, r22
    7a82:	bc 01       	movw	r22, r24
    7a84:	cd 01       	movw	r24, r26
    7a86:	2b a1       	ldd	r18, Y+35	; 0x23
    7a88:	3c a1       	ldd	r19, Y+36	; 0x24
    7a8a:	4d a1       	ldd	r20, Y+37	; 0x25
    7a8c:	5e a1       	ldd	r21, Y+38	; 0x26
    7a8e:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7a92:	dc 01       	movw	r26, r24
    7a94:	cb 01       	movw	r24, r22
    7a96:	9c 01       	movw	r18, r24
    7a98:	ad 01       	movw	r20, r26
    7a9a:	c8 01       	movw	r24, r16
    7a9c:	b7 01       	movw	r22, r14
    7a9e:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    7aa2:	dc 01       	movw	r26, r24
    7aa4:	cb 01       	movw	r24, r22
    7aa6:	5c 01       	movw	r10, r24
    7aa8:	6d 01       	movw	r12, r26
    7aaa:	2d 85       	ldd	r18, Y+13	; 0x0d
    7aac:	3e 85       	ldd	r19, Y+14	; 0x0e
    7aae:	4f 85       	ldd	r20, Y+15	; 0x0f
    7ab0:	58 89       	ldd	r21, Y+16	; 0x10
    7ab2:	89 89       	ldd	r24, Y+17	; 0x11
    7ab4:	9a 89       	ldd	r25, Y+18	; 0x12
    7ab6:	ab 89       	ldd	r26, Y+19	; 0x13
    7ab8:	bc 89       	ldd	r27, Y+20	; 0x14
    7aba:	82 0f       	add	r24, r18
    7abc:	93 1f       	adc	r25, r19
    7abe:	a4 1f       	adc	r26, r20
    7ac0:	b5 1f       	adc	r27, r21
    7ac2:	bc 01       	movw	r22, r24
    7ac4:	cd 01       	movw	r24, r26
    7ac6:	0e 94 54 42 	call	0x84a8	; 0x84a8 <__floatsisf>
    7aca:	dc 01       	movw	r26, r24
    7acc:	cb 01       	movw	r24, r22
    7ace:	bc 01       	movw	r22, r24
    7ad0:	cd 01       	movw	r24, r26
    7ad2:	2b a1       	ldd	r18, Y+35	; 0x23
    7ad4:	3c a1       	ldd	r19, Y+36	; 0x24
    7ad6:	4d a1       	ldd	r20, Y+37	; 0x25
    7ad8:	5e a1       	ldd	r21, Y+38	; 0x26
    7ada:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7ade:	dc 01       	movw	r26, r24
    7ae0:	cb 01       	movw	r24, r22
    7ae2:	7c 01       	movw	r14, r24
    7ae4:	8d 01       	movw	r16, r26
    7ae6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7ae8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7aea:	88 0f       	add	r24, r24
    7aec:	99 1f       	adc	r25, r25
    7aee:	fc 01       	movw	r30, r24
    7af0:	eb 55       	subi	r30, 0x5B	; 91
    7af2:	f8 4f       	sbci	r31, 0xF8	; 248
    7af4:	80 81       	ld	r24, Z
    7af6:	91 81       	ldd	r25, Z+1	; 0x01
    7af8:	cc 01       	movw	r24, r24
    7afa:	a0 e0       	ldi	r26, 0x00	; 0
    7afc:	b0 e0       	ldi	r27, 0x00	; 0
    7afe:	bc 01       	movw	r22, r24
    7b00:	cd 01       	movw	r24, r26
    7b02:	0e 94 52 42 	call	0x84a4	; 0x84a4 <__floatunsisf>
    7b06:	dc 01       	movw	r26, r24
    7b08:	cb 01       	movw	r24, r22
    7b0a:	bc 01       	movw	r22, r24
    7b0c:	cd 01       	movw	r24, r26
    7b0e:	20 e0       	ldi	r18, 0x00	; 0
    7b10:	30 e0       	ldi	r19, 0x00	; 0
    7b12:	40 e0       	ldi	r20, 0x00	; 0
    7b14:	50 ec       	ldi	r21, 0xC0	; 192
    7b16:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    7b1a:	dc 01       	movw	r26, r24
    7b1c:	cb 01       	movw	r24, r22
    7b1e:	9c 01       	movw	r18, r24
    7b20:	ad 01       	movw	r20, r26
    7b22:	c8 01       	movw	r24, r16
    7b24:	b7 01       	movw	r22, r14
    7b26:	0e 94 08 43 	call	0x8610	; 0x8610 <__mulsf3>
    7b2a:	dc 01       	movw	r26, r24
    7b2c:	cb 01       	movw	r24, r22
    7b2e:	9c 01       	movw	r18, r24
    7b30:	ad 01       	movw	r20, r26
    7b32:	c6 01       	movw	r24, r12
    7b34:	b5 01       	movw	r22, r10
    7b36:	0e 94 56 41 	call	0x82ac	; 0x82ac <__addsf3>
    7b3a:	dc 01       	movw	r26, r24
    7b3c:	cb 01       	movw	r24, r22
    7b3e:	bc 01       	movw	r22, r24
    7b40:	cd 01       	movw	r24, r26
    7b42:	20 e0       	ldi	r18, 0x00	; 0
    7b44:	30 e0       	ldi	r19, 0x00	; 0
    7b46:	40 e0       	ldi	r20, 0x00	; 0
    7b48:	50 e4       	ldi	r21, 0x40	; 64
    7b4a:	0e 94 be 41 	call	0x837c	; 0x837c <__divsf3>
    7b4e:	dc 01       	movw	r26, r24
    7b50:	cb 01       	movw	r24, r22
    7b52:	bc 01       	movw	r22, r24
    7b54:	cd 01       	movw	r24, r26
    7b56:	29 81       	ldd	r18, Y+1	; 0x01
    7b58:	3a 81       	ldd	r19, Y+2	; 0x02
    7b5a:	4b 81       	ldd	r20, Y+3	; 0x03
    7b5c:	5c 81       	ldd	r21, Y+4	; 0x04
    7b5e:	0e 94 55 41 	call	0x82aa	; 0x82aa <__subsf3>
    7b62:	dc 01       	movw	r26, r24
    7b64:	cb 01       	movw	r24, r22
    7b66:	89 8f       	std	Y+25, r24	; 0x19
    7b68:	9a 8f       	std	Y+26, r25	; 0x1a
    7b6a:	ab 8f       	std	Y+27, r26	; 0x1b
    7b6c:	bc 8f       	std	Y+28, r27	; 0x1c
			-(TxUcSum+RxUcSum)/clk_32MHz*(2.0*PulseDetUcMax_table[PulseDetUcMax]))/2.0
			- rangingConst;
	}

	return res;
    7b6e:	89 8d       	ldd	r24, Y+25	; 0x19
    7b70:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7b72:	ab 8d       	ldd	r26, Y+27	; 0x1b
    7b74:	bc 8d       	ldd	r27, Y+28	; 0x1c
}
    7b76:	bc 01       	movw	r22, r24
    7b78:	cd 01       	movw	r24, r26
    7b7a:	e8 96       	adiw	r28, 0x38	; 56
    7b7c:	0f b6       	in	r0, 0x3f	; 63
    7b7e:	f8 94       	cli
    7b80:	de bf       	out	0x3e, r29	; 62
    7b82:	0f be       	out	0x3f, r0	; 63
    7b84:	cd bf       	out	0x3d, r28	; 61
    7b86:	cf 91       	pop	r28
    7b88:	df 91       	pop	r29
    7b8a:	1f 91       	pop	r17
    7b8c:	0f 91       	pop	r16
    7b8e:	ff 90       	pop	r15
    7b90:	ef 90       	pop	r14
    7b92:	df 90       	pop	r13
    7b94:	cf 90       	pop	r12
    7b96:	bf 90       	pop	r11
    7b98:	af 90       	pop	r10
    7b9a:	08 95       	ret

00007b9c <vfprintf>:
    7b9c:	a1 e1       	ldi	r26, 0x11	; 17
    7b9e:	b0 e0       	ldi	r27, 0x00	; 0
    7ba0:	e4 ed       	ldi	r30, 0xD4	; 212
    7ba2:	fd e3       	ldi	r31, 0x3D	; 61
    7ba4:	0c 94 8d 43 	jmp	0x871a	; 0x871a <__prologue_saves__>
    7ba8:	3c 01       	movw	r6, r24
    7baa:	7f 87       	std	Y+15, r23	; 0x0f
    7bac:	6e 87       	std	Y+14, r22	; 0x0e
    7bae:	6a 01       	movw	r12, r20
    7bb0:	fc 01       	movw	r30, r24
    7bb2:	17 82       	std	Z+7, r1	; 0x07
    7bb4:	16 82       	std	Z+6, r1	; 0x06
    7bb6:	83 81       	ldd	r24, Z+3	; 0x03
    7bb8:	81 fd       	sbrc	r24, 1
    7bba:	03 c0       	rjmp	.+6      	; 0x7bc2 <vfprintf+0x26>
    7bbc:	6f ef       	ldi	r22, 0xFF	; 255
    7bbe:	7f ef       	ldi	r23, 0xFF	; 255
    7bc0:	6f c3       	rjmp	.+1758   	; 0x82a0 <vfprintf+0x704>
    7bc2:	9e 01       	movw	r18, r28
    7bc4:	2f 5f       	subi	r18, 0xFF	; 255
    7bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    7bc8:	39 8b       	std	Y+17, r19	; 0x11
    7bca:	28 8b       	std	Y+16, r18	; 0x10
    7bcc:	f3 01       	movw	r30, r6
    7bce:	23 81       	ldd	r18, Z+3	; 0x03
    7bd0:	ee 85       	ldd	r30, Y+14	; 0x0e
    7bd2:	ff 85       	ldd	r31, Y+15	; 0x0f
    7bd4:	23 fd       	sbrc	r18, 3
    7bd6:	85 91       	lpm	r24, Z+
    7bd8:	23 ff       	sbrs	r18, 3
    7bda:	81 91       	ld	r24, Z+
    7bdc:	ff 87       	std	Y+15, r31	; 0x0f
    7bde:	ee 87       	std	Y+14, r30	; 0x0e
    7be0:	88 23       	and	r24, r24
    7be2:	09 f4       	brne	.+2      	; 0x7be6 <vfprintf+0x4a>
    7be4:	5a c3       	rjmp	.+1716   	; 0x829a <vfprintf+0x6fe>
    7be6:	85 32       	cpi	r24, 0x25	; 37
    7be8:	51 f4       	brne	.+20     	; 0x7bfe <vfprintf+0x62>
    7bea:	ee 85       	ldd	r30, Y+14	; 0x0e
    7bec:	ff 85       	ldd	r31, Y+15	; 0x0f
    7bee:	23 fd       	sbrc	r18, 3
    7bf0:	85 91       	lpm	r24, Z+
    7bf2:	23 ff       	sbrs	r18, 3
    7bf4:	81 91       	ld	r24, Z+
    7bf6:	ff 87       	std	Y+15, r31	; 0x0f
    7bf8:	ee 87       	std	Y+14, r30	; 0x0e
    7bfa:	85 32       	cpi	r24, 0x25	; 37
    7bfc:	29 f4       	brne	.+10     	; 0x7c08 <vfprintf+0x6c>
    7bfe:	90 e0       	ldi	r25, 0x00	; 0
    7c00:	b3 01       	movw	r22, r6
    7c02:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7c06:	e2 cf       	rjmp	.-60     	; 0x7bcc <vfprintf+0x30>
    7c08:	98 2f       	mov	r25, r24
    7c0a:	10 e0       	ldi	r17, 0x00	; 0
    7c0c:	88 24       	eor	r8, r8
    7c0e:	99 24       	eor	r9, r9
    7c10:	10 32       	cpi	r17, 0x20	; 32
    7c12:	b0 f4       	brcc	.+44     	; 0x7c40 <vfprintf+0xa4>
    7c14:	9b 32       	cpi	r25, 0x2B	; 43
    7c16:	69 f0       	breq	.+26     	; 0x7c32 <vfprintf+0x96>
    7c18:	9c 32       	cpi	r25, 0x2C	; 44
    7c1a:	28 f4       	brcc	.+10     	; 0x7c26 <vfprintf+0x8a>
    7c1c:	90 32       	cpi	r25, 0x20	; 32
    7c1e:	51 f0       	breq	.+20     	; 0x7c34 <vfprintf+0x98>
    7c20:	93 32       	cpi	r25, 0x23	; 35
    7c22:	71 f4       	brne	.+28     	; 0x7c40 <vfprintf+0xa4>
    7c24:	0b c0       	rjmp	.+22     	; 0x7c3c <vfprintf+0xa0>
    7c26:	9d 32       	cpi	r25, 0x2D	; 45
    7c28:	39 f0       	breq	.+14     	; 0x7c38 <vfprintf+0x9c>
    7c2a:	90 33       	cpi	r25, 0x30	; 48
    7c2c:	49 f4       	brne	.+18     	; 0x7c40 <vfprintf+0xa4>
    7c2e:	11 60       	ori	r17, 0x01	; 1
    7c30:	28 c0       	rjmp	.+80     	; 0x7c82 <vfprintf+0xe6>
    7c32:	12 60       	ori	r17, 0x02	; 2
    7c34:	14 60       	ori	r17, 0x04	; 4
    7c36:	25 c0       	rjmp	.+74     	; 0x7c82 <vfprintf+0xe6>
    7c38:	18 60       	ori	r17, 0x08	; 8
    7c3a:	23 c0       	rjmp	.+70     	; 0x7c82 <vfprintf+0xe6>
    7c3c:	10 61       	ori	r17, 0x10	; 16
    7c3e:	21 c0       	rjmp	.+66     	; 0x7c82 <vfprintf+0xe6>
    7c40:	17 fd       	sbrc	r17, 7
    7c42:	2a c0       	rjmp	.+84     	; 0x7c98 <vfprintf+0xfc>
    7c44:	89 2f       	mov	r24, r25
    7c46:	80 53       	subi	r24, 0x30	; 48
    7c48:	8a 30       	cpi	r24, 0x0A	; 10
    7c4a:	78 f4       	brcc	.+30     	; 0x7c6a <vfprintf+0xce>
    7c4c:	16 ff       	sbrs	r17, 6
    7c4e:	06 c0       	rjmp	.+12     	; 0x7c5c <vfprintf+0xc0>
    7c50:	fa e0       	ldi	r31, 0x0A	; 10
    7c52:	9f 9e       	mul	r9, r31
    7c54:	90 2c       	mov	r9, r0
    7c56:	11 24       	eor	r1, r1
    7c58:	98 0e       	add	r9, r24
    7c5a:	13 c0       	rjmp	.+38     	; 0x7c82 <vfprintf+0xe6>
    7c5c:	3a e0       	ldi	r19, 0x0A	; 10
    7c5e:	83 9e       	mul	r8, r19
    7c60:	80 2c       	mov	r8, r0
    7c62:	11 24       	eor	r1, r1
    7c64:	88 0e       	add	r8, r24
    7c66:	10 62       	ori	r17, 0x20	; 32
    7c68:	0c c0       	rjmp	.+24     	; 0x7c82 <vfprintf+0xe6>
    7c6a:	9e 32       	cpi	r25, 0x2E	; 46
    7c6c:	21 f4       	brne	.+8      	; 0x7c76 <vfprintf+0xda>
    7c6e:	16 fd       	sbrc	r17, 6
    7c70:	14 c3       	rjmp	.+1576   	; 0x829a <vfprintf+0x6fe>
    7c72:	10 64       	ori	r17, 0x40	; 64
    7c74:	06 c0       	rjmp	.+12     	; 0x7c82 <vfprintf+0xe6>
    7c76:	9c 36       	cpi	r25, 0x6C	; 108
    7c78:	11 f4       	brne	.+4      	; 0x7c7e <vfprintf+0xe2>
    7c7a:	10 68       	ori	r17, 0x80	; 128
    7c7c:	02 c0       	rjmp	.+4      	; 0x7c82 <vfprintf+0xe6>
    7c7e:	98 36       	cpi	r25, 0x68	; 104
    7c80:	59 f4       	brne	.+22     	; 0x7c98 <vfprintf+0xfc>
    7c82:	ee 85       	ldd	r30, Y+14	; 0x0e
    7c84:	ff 85       	ldd	r31, Y+15	; 0x0f
    7c86:	23 fd       	sbrc	r18, 3
    7c88:	95 91       	lpm	r25, Z+
    7c8a:	23 ff       	sbrs	r18, 3
    7c8c:	91 91       	ld	r25, Z+
    7c8e:	ff 87       	std	Y+15, r31	; 0x0f
    7c90:	ee 87       	std	Y+14, r30	; 0x0e
    7c92:	99 23       	and	r25, r25
    7c94:	09 f0       	breq	.+2      	; 0x7c98 <vfprintf+0xfc>
    7c96:	bc cf       	rjmp	.-136    	; 0x7c10 <vfprintf+0x74>
    7c98:	89 2f       	mov	r24, r25
    7c9a:	85 54       	subi	r24, 0x45	; 69
    7c9c:	83 30       	cpi	r24, 0x03	; 3
    7c9e:	20 f4       	brcc	.+8      	; 0x7ca8 <vfprintf+0x10c>
    7ca0:	81 2f       	mov	r24, r17
    7ca2:	80 61       	ori	r24, 0x10	; 16
    7ca4:	90 5e       	subi	r25, 0xE0	; 224
    7ca6:	07 c0       	rjmp	.+14     	; 0x7cb6 <vfprintf+0x11a>
    7ca8:	89 2f       	mov	r24, r25
    7caa:	85 56       	subi	r24, 0x65	; 101
    7cac:	83 30       	cpi	r24, 0x03	; 3
    7cae:	08 f0       	brcs	.+2      	; 0x7cb2 <vfprintf+0x116>
    7cb0:	9f c1       	rjmp	.+830    	; 0x7ff0 <vfprintf+0x454>
    7cb2:	81 2f       	mov	r24, r17
    7cb4:	8f 7e       	andi	r24, 0xEF	; 239
    7cb6:	86 fd       	sbrc	r24, 6
    7cb8:	02 c0       	rjmp	.+4      	; 0x7cbe <vfprintf+0x122>
    7cba:	76 e0       	ldi	r23, 0x06	; 6
    7cbc:	97 2e       	mov	r9, r23
    7cbe:	6f e3       	ldi	r22, 0x3F	; 63
    7cc0:	f6 2e       	mov	r15, r22
    7cc2:	f8 22       	and	r15, r24
    7cc4:	95 36       	cpi	r25, 0x65	; 101
    7cc6:	19 f4       	brne	.+6      	; 0x7cce <vfprintf+0x132>
    7cc8:	f0 e4       	ldi	r31, 0x40	; 64
    7cca:	ff 2a       	or	r15, r31
    7ccc:	07 c0       	rjmp	.+14     	; 0x7cdc <vfprintf+0x140>
    7cce:	96 36       	cpi	r25, 0x66	; 102
    7cd0:	19 f4       	brne	.+6      	; 0x7cd8 <vfprintf+0x13c>
    7cd2:	20 e8       	ldi	r18, 0x80	; 128
    7cd4:	f2 2a       	or	r15, r18
    7cd6:	02 c0       	rjmp	.+4      	; 0x7cdc <vfprintf+0x140>
    7cd8:	91 10       	cpse	r9, r1
    7cda:	9a 94       	dec	r9
    7cdc:	f7 fe       	sbrs	r15, 7
    7cde:	0a c0       	rjmp	.+20     	; 0x7cf4 <vfprintf+0x158>
    7ce0:	3b e3       	ldi	r19, 0x3B	; 59
    7ce2:	39 15       	cp	r19, r9
    7ce4:	18 f4       	brcc	.+6      	; 0x7cec <vfprintf+0x150>
    7ce6:	5c e3       	ldi	r21, 0x3C	; 60
    7ce8:	b5 2e       	mov	r11, r21
    7cea:	02 c0       	rjmp	.+4      	; 0x7cf0 <vfprintf+0x154>
    7cec:	b9 2c       	mov	r11, r9
    7cee:	b3 94       	inc	r11
    7cf0:	27 e0       	ldi	r18, 0x07	; 7
    7cf2:	09 c0       	rjmp	.+18     	; 0x7d06 <vfprintf+0x16a>
    7cf4:	47 e0       	ldi	r20, 0x07	; 7
    7cf6:	49 15       	cp	r20, r9
    7cf8:	20 f4       	brcc	.+8      	; 0x7d02 <vfprintf+0x166>
    7cfa:	bb 24       	eor	r11, r11
    7cfc:	47 e0       	ldi	r20, 0x07	; 7
    7cfe:	94 2e       	mov	r9, r20
    7d00:	f7 cf       	rjmp	.-18     	; 0x7cf0 <vfprintf+0x154>
    7d02:	29 2d       	mov	r18, r9
    7d04:	bb 24       	eor	r11, r11
    7d06:	c6 01       	movw	r24, r12
    7d08:	04 96       	adiw	r24, 0x04	; 4
    7d0a:	9d 87       	std	Y+13, r25	; 0x0d
    7d0c:	8c 87       	std	Y+12, r24	; 0x0c
    7d0e:	f6 01       	movw	r30, r12
    7d10:	60 81       	ld	r22, Z
    7d12:	71 81       	ldd	r23, Z+1	; 0x01
    7d14:	82 81       	ldd	r24, Z+2	; 0x02
    7d16:	93 81       	ldd	r25, Z+3	; 0x03
    7d18:	ae 01       	movw	r20, r28
    7d1a:	4f 5f       	subi	r20, 0xFF	; 255
    7d1c:	5f 4f       	sbci	r21, 0xFF	; 255
    7d1e:	0b 2d       	mov	r16, r11
    7d20:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <__ftoa_engine>
    7d24:	6c 01       	movw	r12, r24
    7d26:	09 81       	ldd	r16, Y+1	; 0x01
    7d28:	20 2e       	mov	r2, r16
    7d2a:	33 24       	eor	r3, r3
    7d2c:	00 ff       	sbrs	r16, 0
    7d2e:	04 c0       	rjmp	.+8      	; 0x7d38 <vfprintf+0x19c>
    7d30:	03 fd       	sbrc	r16, 3
    7d32:	02 c0       	rjmp	.+4      	; 0x7d38 <vfprintf+0x19c>
    7d34:	1d e2       	ldi	r17, 0x2D	; 45
    7d36:	09 c0       	rjmp	.+18     	; 0x7d4a <vfprintf+0x1ae>
    7d38:	f1 fe       	sbrs	r15, 1
    7d3a:	02 c0       	rjmp	.+4      	; 0x7d40 <vfprintf+0x1a4>
    7d3c:	1b e2       	ldi	r17, 0x2B	; 43
    7d3e:	05 c0       	rjmp	.+10     	; 0x7d4a <vfprintf+0x1ae>
    7d40:	f2 fc       	sbrc	r15, 2
    7d42:	02 c0       	rjmp	.+4      	; 0x7d48 <vfprintf+0x1ac>
    7d44:	10 e0       	ldi	r17, 0x00	; 0
    7d46:	01 c0       	rjmp	.+2      	; 0x7d4a <vfprintf+0x1ae>
    7d48:	10 e2       	ldi	r17, 0x20	; 32
    7d4a:	c1 01       	movw	r24, r2
    7d4c:	8c 70       	andi	r24, 0x0C	; 12
    7d4e:	90 70       	andi	r25, 0x00	; 0
    7d50:	89 2b       	or	r24, r25
    7d52:	b9 f1       	breq	.+110    	; 0x7dc2 <vfprintf+0x226>
    7d54:	11 23       	and	r17, r17
    7d56:	11 f4       	brne	.+4      	; 0x7d5c <vfprintf+0x1c0>
    7d58:	83 e0       	ldi	r24, 0x03	; 3
    7d5a:	01 c0       	rjmp	.+2      	; 0x7d5e <vfprintf+0x1c2>
    7d5c:	84 e0       	ldi	r24, 0x04	; 4
    7d5e:	88 15       	cp	r24, r8
    7d60:	10 f0       	brcs	.+4      	; 0x7d66 <vfprintf+0x1ca>
    7d62:	88 24       	eor	r8, r8
    7d64:	0a c0       	rjmp	.+20     	; 0x7d7a <vfprintf+0x1de>
    7d66:	88 1a       	sub	r8, r24
    7d68:	f3 fc       	sbrc	r15, 3
    7d6a:	07 c0       	rjmp	.+14     	; 0x7d7a <vfprintf+0x1de>
    7d6c:	80 e2       	ldi	r24, 0x20	; 32
    7d6e:	90 e0       	ldi	r25, 0x00	; 0
    7d70:	b3 01       	movw	r22, r6
    7d72:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7d76:	8a 94       	dec	r8
    7d78:	c9 f7       	brne	.-14     	; 0x7d6c <vfprintf+0x1d0>
    7d7a:	11 23       	and	r17, r17
    7d7c:	29 f0       	breq	.+10     	; 0x7d88 <vfprintf+0x1ec>
    7d7e:	81 2f       	mov	r24, r17
    7d80:	90 e0       	ldi	r25, 0x00	; 0
    7d82:	b3 01       	movw	r22, r6
    7d84:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7d88:	23 fe       	sbrs	r2, 3
    7d8a:	03 c0       	rjmp	.+6      	; 0x7d92 <vfprintf+0x1f6>
    7d8c:	00 e7       	ldi	r16, 0x70	; 112
    7d8e:	10 e0       	ldi	r17, 0x00	; 0
    7d90:	0e c0       	rjmp	.+28     	; 0x7dae <vfprintf+0x212>
    7d92:	04 e7       	ldi	r16, 0x74	; 116
    7d94:	10 e0       	ldi	r17, 0x00	; 0
    7d96:	0b c0       	rjmp	.+22     	; 0x7dae <vfprintf+0x212>
    7d98:	e1 14       	cp	r14, r1
    7d9a:	f1 04       	cpc	r15, r1
    7d9c:	09 f0       	breq	.+2      	; 0x7da0 <vfprintf+0x204>
    7d9e:	80 52       	subi	r24, 0x20	; 32
    7da0:	90 e0       	ldi	r25, 0x00	; 0
    7da2:	b3 01       	movw	r22, r6
    7da4:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7da8:	0f 5f       	subi	r16, 0xFF	; 255
    7daa:	1f 4f       	sbci	r17, 0xFF	; 255
    7dac:	05 c0       	rjmp	.+10     	; 0x7db8 <vfprintf+0x21c>
    7dae:	ef 2c       	mov	r14, r15
    7db0:	ff 24       	eor	r15, r15
    7db2:	f0 e1       	ldi	r31, 0x10	; 16
    7db4:	ef 22       	and	r14, r31
    7db6:	ff 24       	eor	r15, r15
    7db8:	f8 01       	movw	r30, r16
    7dba:	84 91       	lpm	r24, Z+
    7dbc:	88 23       	and	r24, r24
    7dbe:	61 f7       	brne	.-40     	; 0x7d98 <vfprintf+0x1fc>
    7dc0:	14 c1       	rjmp	.+552    	; 0x7fea <vfprintf+0x44e>
    7dc2:	f7 fe       	sbrs	r15, 7
    7dc4:	12 c0       	rjmp	.+36     	; 0x7dea <vfprintf+0x24e>
    7dc6:	bc 0c       	add	r11, r12
    7dc8:	24 fe       	sbrs	r2, 4
    7dca:	04 c0       	rjmp	.+8      	; 0x7dd4 <vfprintf+0x238>
    7dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    7dce:	81 33       	cpi	r24, 0x31	; 49
    7dd0:	09 f4       	brne	.+2      	; 0x7dd4 <vfprintf+0x238>
    7dd2:	ba 94       	dec	r11
    7dd4:	1b 14       	cp	r1, r11
    7dd6:	1c f0       	brlt	.+6      	; 0x7dde <vfprintf+0x242>
    7dd8:	bb 24       	eor	r11, r11
    7dda:	b3 94       	inc	r11
    7ddc:	2d c0       	rjmp	.+90     	; 0x7e38 <vfprintf+0x29c>
    7dde:	f8 e0       	ldi	r31, 0x08	; 8
    7de0:	fb 15       	cp	r31, r11
    7de2:	50 f5       	brcc	.+84     	; 0x7e38 <vfprintf+0x29c>
    7de4:	38 e0       	ldi	r19, 0x08	; 8
    7de6:	b3 2e       	mov	r11, r19
    7de8:	27 c0       	rjmp	.+78     	; 0x7e38 <vfprintf+0x29c>
    7dea:	f6 fc       	sbrc	r15, 6
    7dec:	25 c0       	rjmp	.+74     	; 0x7e38 <vfprintf+0x29c>
    7dee:	89 2d       	mov	r24, r9
    7df0:	90 e0       	ldi	r25, 0x00	; 0
    7df2:	8c 15       	cp	r24, r12
    7df4:	9d 05       	cpc	r25, r13
    7df6:	4c f0       	brlt	.+18     	; 0x7e0a <vfprintf+0x26e>
    7df8:	2c ef       	ldi	r18, 0xFC	; 252
    7dfa:	c2 16       	cp	r12, r18
    7dfc:	2f ef       	ldi	r18, 0xFF	; 255
    7dfe:	d2 06       	cpc	r13, r18
    7e00:	24 f0       	brlt	.+8      	; 0x7e0a <vfprintf+0x26e>
    7e02:	30 e8       	ldi	r19, 0x80	; 128
    7e04:	f3 2a       	or	r15, r19
    7e06:	01 c0       	rjmp	.+2      	; 0x7e0a <vfprintf+0x26e>
    7e08:	9a 94       	dec	r9
    7e0a:	99 20       	and	r9, r9
    7e0c:	49 f0       	breq	.+18     	; 0x7e20 <vfprintf+0x284>
    7e0e:	e2 e0       	ldi	r30, 0x02	; 2
    7e10:	f0 e0       	ldi	r31, 0x00	; 0
    7e12:	ec 0f       	add	r30, r28
    7e14:	fd 1f       	adc	r31, r29
    7e16:	e9 0d       	add	r30, r9
    7e18:	f1 1d       	adc	r31, r1
    7e1a:	80 81       	ld	r24, Z
    7e1c:	80 33       	cpi	r24, 0x30	; 48
    7e1e:	a1 f3       	breq	.-24     	; 0x7e08 <vfprintf+0x26c>
    7e20:	f7 fe       	sbrs	r15, 7
    7e22:	0a c0       	rjmp	.+20     	; 0x7e38 <vfprintf+0x29c>
    7e24:	b9 2c       	mov	r11, r9
    7e26:	b3 94       	inc	r11
    7e28:	89 2d       	mov	r24, r9
    7e2a:	90 e0       	ldi	r25, 0x00	; 0
    7e2c:	c8 16       	cp	r12, r24
    7e2e:	d9 06       	cpc	r13, r25
    7e30:	14 f0       	brlt	.+4      	; 0x7e36 <vfprintf+0x29a>
    7e32:	99 24       	eor	r9, r9
    7e34:	01 c0       	rjmp	.+2      	; 0x7e38 <vfprintf+0x29c>
    7e36:	9c 18       	sub	r9, r12
    7e38:	f7 fc       	sbrc	r15, 7
    7e3a:	03 c0       	rjmp	.+6      	; 0x7e42 <vfprintf+0x2a6>
    7e3c:	25 e0       	ldi	r18, 0x05	; 5
    7e3e:	30 e0       	ldi	r19, 0x00	; 0
    7e40:	09 c0       	rjmp	.+18     	; 0x7e54 <vfprintf+0x2b8>
    7e42:	1c 14       	cp	r1, r12
    7e44:	1d 04       	cpc	r1, r13
    7e46:	1c f0       	brlt	.+6      	; 0x7e4e <vfprintf+0x2b2>
    7e48:	21 e0       	ldi	r18, 0x01	; 1
    7e4a:	30 e0       	ldi	r19, 0x00	; 0
    7e4c:	03 c0       	rjmp	.+6      	; 0x7e54 <vfprintf+0x2b8>
    7e4e:	96 01       	movw	r18, r12
    7e50:	2f 5f       	subi	r18, 0xFF	; 255
    7e52:	3f 4f       	sbci	r19, 0xFF	; 255
    7e54:	11 23       	and	r17, r17
    7e56:	11 f0       	breq	.+4      	; 0x7e5c <vfprintf+0x2c0>
    7e58:	2f 5f       	subi	r18, 0xFF	; 255
    7e5a:	3f 4f       	sbci	r19, 0xFF	; 255
    7e5c:	99 20       	and	r9, r9
    7e5e:	29 f0       	breq	.+10     	; 0x7e6a <vfprintf+0x2ce>
    7e60:	89 2d       	mov	r24, r9
    7e62:	90 e0       	ldi	r25, 0x00	; 0
    7e64:	01 96       	adiw	r24, 0x01	; 1
    7e66:	28 0f       	add	r18, r24
    7e68:	39 1f       	adc	r19, r25
    7e6a:	88 2d       	mov	r24, r8
    7e6c:	90 e0       	ldi	r25, 0x00	; 0
    7e6e:	28 17       	cp	r18, r24
    7e70:	39 07       	cpc	r19, r25
    7e72:	14 f0       	brlt	.+4      	; 0x7e78 <vfprintf+0x2dc>
    7e74:	88 24       	eor	r8, r8
    7e76:	01 c0       	rjmp	.+2      	; 0x7e7a <vfprintf+0x2de>
    7e78:	82 1a       	sub	r8, r18
    7e7a:	4f 2c       	mov	r4, r15
    7e7c:	55 24       	eor	r5, r5
    7e7e:	c2 01       	movw	r24, r4
    7e80:	89 70       	andi	r24, 0x09	; 9
    7e82:	90 70       	andi	r25, 0x00	; 0
    7e84:	89 2b       	or	r24, r25
    7e86:	39 f0       	breq	.+14     	; 0x7e96 <vfprintf+0x2fa>
    7e88:	08 c0       	rjmp	.+16     	; 0x7e9a <vfprintf+0x2fe>
    7e8a:	80 e2       	ldi	r24, 0x20	; 32
    7e8c:	90 e0       	ldi	r25, 0x00	; 0
    7e8e:	b3 01       	movw	r22, r6
    7e90:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7e94:	8a 94       	dec	r8
    7e96:	88 20       	and	r8, r8
    7e98:	c1 f7       	brne	.-16     	; 0x7e8a <vfprintf+0x2ee>
    7e9a:	11 23       	and	r17, r17
    7e9c:	29 f0       	breq	.+10     	; 0x7ea8 <vfprintf+0x30c>
    7e9e:	81 2f       	mov	r24, r17
    7ea0:	90 e0       	ldi	r25, 0x00	; 0
    7ea2:	b3 01       	movw	r22, r6
    7ea4:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7ea8:	43 fe       	sbrs	r4, 3
    7eaa:	07 c0       	rjmp	.+14     	; 0x7eba <vfprintf+0x31e>
    7eac:	08 c0       	rjmp	.+16     	; 0x7ebe <vfprintf+0x322>
    7eae:	80 e3       	ldi	r24, 0x30	; 48
    7eb0:	90 e0       	ldi	r25, 0x00	; 0
    7eb2:	b3 01       	movw	r22, r6
    7eb4:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7eb8:	8a 94       	dec	r8
    7eba:	88 20       	and	r8, r8
    7ebc:	c1 f7       	brne	.-16     	; 0x7eae <vfprintf+0x312>
    7ebe:	f7 fe       	sbrs	r15, 7
    7ec0:	46 c0       	rjmp	.+140    	; 0x7f4e <vfprintf+0x3b2>
    7ec2:	86 01       	movw	r16, r12
    7ec4:	d7 fe       	sbrs	r13, 7
    7ec6:	02 c0       	rjmp	.+4      	; 0x7ecc <vfprintf+0x330>
    7ec8:	00 e0       	ldi	r16, 0x00	; 0
    7eca:	10 e0       	ldi	r17, 0x00	; 0
    7ecc:	76 01       	movw	r14, r12
    7ece:	08 94       	sec
    7ed0:	e1 1c       	adc	r14, r1
    7ed2:	f1 1c       	adc	r15, r1
    7ed4:	e0 1a       	sub	r14, r16
    7ed6:	f1 0a       	sbc	r15, r17
    7ed8:	41 e0       	ldi	r20, 0x01	; 1
    7eda:	50 e0       	ldi	r21, 0x00	; 0
    7edc:	4c 0f       	add	r20, r28
    7ede:	5d 1f       	adc	r21, r29
    7ee0:	e4 0e       	add	r14, r20
    7ee2:	f5 1e       	adc	r15, r21
    7ee4:	26 01       	movw	r4, r12
    7ee6:	4b 18       	sub	r4, r11
    7ee8:	51 08       	sbc	r5, r1
    7eea:	89 2d       	mov	r24, r9
    7eec:	90 e0       	ldi	r25, 0x00	; 0
    7eee:	aa 24       	eor	r10, r10
    7ef0:	bb 24       	eor	r11, r11
    7ef2:	a8 1a       	sub	r10, r24
    7ef4:	b9 0a       	sbc	r11, r25
    7ef6:	5f ef       	ldi	r21, 0xFF	; 255
    7ef8:	0f 3f       	cpi	r16, 0xFF	; 255
    7efa:	15 07       	cpc	r17, r21
    7efc:	29 f4       	brne	.+10     	; 0x7f08 <vfprintf+0x36c>
    7efe:	8e e2       	ldi	r24, 0x2E	; 46
    7f00:	90 e0       	ldi	r25, 0x00	; 0
    7f02:	b3 01       	movw	r22, r6
    7f04:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f08:	c0 16       	cp	r12, r16
    7f0a:	d1 06       	cpc	r13, r17
    7f0c:	34 f0       	brlt	.+12     	; 0x7f1a <vfprintf+0x37e>
    7f0e:	40 16       	cp	r4, r16
    7f10:	51 06       	cpc	r5, r17
    7f12:	1c f4       	brge	.+6      	; 0x7f1a <vfprintf+0x37e>
    7f14:	f7 01       	movw	r30, r14
    7f16:	80 81       	ld	r24, Z
    7f18:	01 c0       	rjmp	.+2      	; 0x7f1c <vfprintf+0x380>
    7f1a:	80 e3       	ldi	r24, 0x30	; 48
    7f1c:	01 50       	subi	r16, 0x01	; 1
    7f1e:	10 40       	sbci	r17, 0x00	; 0
    7f20:	08 94       	sec
    7f22:	e1 1c       	adc	r14, r1
    7f24:	f1 1c       	adc	r15, r1
    7f26:	0a 15       	cp	r16, r10
    7f28:	1b 05       	cpc	r17, r11
    7f2a:	2c f0       	brlt	.+10     	; 0x7f36 <vfprintf+0x39a>
    7f2c:	90 e0       	ldi	r25, 0x00	; 0
    7f2e:	b3 01       	movw	r22, r6
    7f30:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f34:	e0 cf       	rjmp	.-64     	; 0x7ef6 <vfprintf+0x35a>
    7f36:	0c 15       	cp	r16, r12
    7f38:	1d 05       	cpc	r17, r13
    7f3a:	39 f4       	brne	.+14     	; 0x7f4a <vfprintf+0x3ae>
    7f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f3e:	96 33       	cpi	r25, 0x36	; 54
    7f40:	18 f4       	brcc	.+6      	; 0x7f48 <vfprintf+0x3ac>
    7f42:	95 33       	cpi	r25, 0x35	; 53
    7f44:	11 f4       	brne	.+4      	; 0x7f4a <vfprintf+0x3ae>
    7f46:	24 fe       	sbrs	r2, 4
    7f48:	81 e3       	ldi	r24, 0x31	; 49
    7f4a:	90 e0       	ldi	r25, 0x00	; 0
    7f4c:	4b c0       	rjmp	.+150    	; 0x7fe4 <vfprintf+0x448>
    7f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    7f50:	81 33       	cpi	r24, 0x31	; 49
    7f52:	09 f0       	breq	.+2      	; 0x7f56 <vfprintf+0x3ba>
    7f54:	0f 7e       	andi	r16, 0xEF	; 239
    7f56:	90 e0       	ldi	r25, 0x00	; 0
    7f58:	b3 01       	movw	r22, r6
    7f5a:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f5e:	99 20       	and	r9, r9
    7f60:	a1 f0       	breq	.+40     	; 0x7f8a <vfprintf+0x3ee>
    7f62:	8e e2       	ldi	r24, 0x2E	; 46
    7f64:	90 e0       	ldi	r25, 0x00	; 0
    7f66:	b3 01       	movw	r22, r6
    7f68:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f6c:	12 e0       	ldi	r17, 0x02	; 2
    7f6e:	e1 e0       	ldi	r30, 0x01	; 1
    7f70:	f0 e0       	ldi	r31, 0x00	; 0
    7f72:	ec 0f       	add	r30, r28
    7f74:	fd 1f       	adc	r31, r29
    7f76:	e1 0f       	add	r30, r17
    7f78:	f1 1d       	adc	r31, r1
    7f7a:	1f 5f       	subi	r17, 0xFF	; 255
    7f7c:	80 81       	ld	r24, Z
    7f7e:	90 e0       	ldi	r25, 0x00	; 0
    7f80:	b3 01       	movw	r22, r6
    7f82:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f86:	9a 94       	dec	r9
    7f88:	91 f7       	brne	.-28     	; 0x7f6e <vfprintf+0x3d2>
    7f8a:	44 fc       	sbrc	r4, 4
    7f8c:	03 c0       	rjmp	.+6      	; 0x7f94 <vfprintf+0x3f8>
    7f8e:	85 e6       	ldi	r24, 0x65	; 101
    7f90:	90 e0       	ldi	r25, 0x00	; 0
    7f92:	02 c0       	rjmp	.+4      	; 0x7f98 <vfprintf+0x3fc>
    7f94:	85 e4       	ldi	r24, 0x45	; 69
    7f96:	90 e0       	ldi	r25, 0x00	; 0
    7f98:	b3 01       	movw	r22, r6
    7f9a:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7f9e:	d7 fc       	sbrc	r13, 7
    7fa0:	05 c0       	rjmp	.+10     	; 0x7fac <vfprintf+0x410>
    7fa2:	c1 14       	cp	r12, r1
    7fa4:	d1 04       	cpc	r13, r1
    7fa6:	41 f4       	brne	.+16     	; 0x7fb8 <vfprintf+0x41c>
    7fa8:	04 ff       	sbrs	r16, 4
    7faa:	06 c0       	rjmp	.+12     	; 0x7fb8 <vfprintf+0x41c>
    7fac:	d0 94       	com	r13
    7fae:	c1 94       	neg	r12
    7fb0:	d1 08       	sbc	r13, r1
    7fb2:	d3 94       	inc	r13
    7fb4:	8d e2       	ldi	r24, 0x2D	; 45
    7fb6:	01 c0       	rjmp	.+2      	; 0x7fba <vfprintf+0x41e>
    7fb8:	8b e2       	ldi	r24, 0x2B	; 43
    7fba:	90 e0       	ldi	r25, 0x00	; 0
    7fbc:	b3 01       	movw	r22, r6
    7fbe:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7fc2:	80 e3       	ldi	r24, 0x30	; 48
    7fc4:	05 c0       	rjmp	.+10     	; 0x7fd0 <vfprintf+0x434>
    7fc6:	8f 5f       	subi	r24, 0xFF	; 255
    7fc8:	26 ef       	ldi	r18, 0xF6	; 246
    7fca:	3f ef       	ldi	r19, 0xFF	; 255
    7fcc:	c2 0e       	add	r12, r18
    7fce:	d3 1e       	adc	r13, r19
    7fd0:	3a e0       	ldi	r19, 0x0A	; 10
    7fd2:	c3 16       	cp	r12, r19
    7fd4:	d1 04       	cpc	r13, r1
    7fd6:	bc f7       	brge	.-18     	; 0x7fc6 <vfprintf+0x42a>
    7fd8:	90 e0       	ldi	r25, 0x00	; 0
    7fda:	b3 01       	movw	r22, r6
    7fdc:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7fe0:	c6 01       	movw	r24, r12
    7fe2:	c0 96       	adiw	r24, 0x30	; 48
    7fe4:	b3 01       	movw	r22, r6
    7fe6:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    7fea:	cc 84       	ldd	r12, Y+12	; 0x0c
    7fec:	dd 84       	ldd	r13, Y+13	; 0x0d
    7fee:	52 c1       	rjmp	.+676    	; 0x8294 <vfprintf+0x6f8>
    7ff0:	93 36       	cpi	r25, 0x63	; 99
    7ff2:	31 f0       	breq	.+12     	; 0x8000 <vfprintf+0x464>
    7ff4:	93 37       	cpi	r25, 0x73	; 115
    7ff6:	99 f0       	breq	.+38     	; 0x801e <vfprintf+0x482>
    7ff8:	93 35       	cpi	r25, 0x53	; 83
    7ffa:	09 f0       	breq	.+2      	; 0x7ffe <vfprintf+0x462>
    7ffc:	59 c0       	rjmp	.+178    	; 0x80b0 <vfprintf+0x514>
    7ffe:	23 c0       	rjmp	.+70     	; 0x8046 <vfprintf+0x4aa>
    8000:	f6 01       	movw	r30, r12
    8002:	80 81       	ld	r24, Z
    8004:	89 83       	std	Y+1, r24	; 0x01
    8006:	5e 01       	movw	r10, r28
    8008:	08 94       	sec
    800a:	a1 1c       	adc	r10, r1
    800c:	b1 1c       	adc	r11, r1
    800e:	22 e0       	ldi	r18, 0x02	; 2
    8010:	30 e0       	ldi	r19, 0x00	; 0
    8012:	c2 0e       	add	r12, r18
    8014:	d3 1e       	adc	r13, r19
    8016:	21 e0       	ldi	r18, 0x01	; 1
    8018:	e2 2e       	mov	r14, r18
    801a:	f1 2c       	mov	r15, r1
    801c:	12 c0       	rjmp	.+36     	; 0x8042 <vfprintf+0x4a6>
    801e:	f6 01       	movw	r30, r12
    8020:	a0 80       	ld	r10, Z
    8022:	b1 80       	ldd	r11, Z+1	; 0x01
    8024:	16 fd       	sbrc	r17, 6
    8026:	03 c0       	rjmp	.+6      	; 0x802e <vfprintf+0x492>
    8028:	6f ef       	ldi	r22, 0xFF	; 255
    802a:	7f ef       	ldi	r23, 0xFF	; 255
    802c:	02 c0       	rjmp	.+4      	; 0x8032 <vfprintf+0x496>
    802e:	69 2d       	mov	r22, r9
    8030:	70 e0       	ldi	r23, 0x00	; 0
    8032:	22 e0       	ldi	r18, 0x02	; 2
    8034:	30 e0       	ldi	r19, 0x00	; 0
    8036:	c2 0e       	add	r12, r18
    8038:	d3 1e       	adc	r13, r19
    803a:	c5 01       	movw	r24, r10
    803c:	0e 94 02 45 	call	0x8a04	; 0x8a04 <strnlen>
    8040:	7c 01       	movw	r14, r24
    8042:	1f 77       	andi	r17, 0x7F	; 127
    8044:	13 c0       	rjmp	.+38     	; 0x806c <vfprintf+0x4d0>
    8046:	f6 01       	movw	r30, r12
    8048:	a0 80       	ld	r10, Z
    804a:	b1 80       	ldd	r11, Z+1	; 0x01
    804c:	16 fd       	sbrc	r17, 6
    804e:	03 c0       	rjmp	.+6      	; 0x8056 <vfprintf+0x4ba>
    8050:	6f ef       	ldi	r22, 0xFF	; 255
    8052:	7f ef       	ldi	r23, 0xFF	; 255
    8054:	02 c0       	rjmp	.+4      	; 0x805a <vfprintf+0x4be>
    8056:	69 2d       	mov	r22, r9
    8058:	70 e0       	ldi	r23, 0x00	; 0
    805a:	22 e0       	ldi	r18, 0x02	; 2
    805c:	30 e0       	ldi	r19, 0x00	; 0
    805e:	c2 0e       	add	r12, r18
    8060:	d3 1e       	adc	r13, r19
    8062:	c5 01       	movw	r24, r10
    8064:	0e 94 c3 44 	call	0x8986	; 0x8986 <strnlen_P>
    8068:	7c 01       	movw	r14, r24
    806a:	10 68       	ori	r17, 0x80	; 128
    806c:	13 ff       	sbrs	r17, 3
    806e:	07 c0       	rjmp	.+14     	; 0x807e <vfprintf+0x4e2>
    8070:	1b c0       	rjmp	.+54     	; 0x80a8 <vfprintf+0x50c>
    8072:	80 e2       	ldi	r24, 0x20	; 32
    8074:	90 e0       	ldi	r25, 0x00	; 0
    8076:	b3 01       	movw	r22, r6
    8078:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    807c:	8a 94       	dec	r8
    807e:	88 2d       	mov	r24, r8
    8080:	90 e0       	ldi	r25, 0x00	; 0
    8082:	e8 16       	cp	r14, r24
    8084:	f9 06       	cpc	r15, r25
    8086:	a8 f3       	brcs	.-22     	; 0x8072 <vfprintf+0x4d6>
    8088:	0f c0       	rjmp	.+30     	; 0x80a8 <vfprintf+0x50c>
    808a:	f5 01       	movw	r30, r10
    808c:	17 fd       	sbrc	r17, 7
    808e:	85 91       	lpm	r24, Z+
    8090:	17 ff       	sbrs	r17, 7
    8092:	81 91       	ld	r24, Z+
    8094:	5f 01       	movw	r10, r30
    8096:	90 e0       	ldi	r25, 0x00	; 0
    8098:	b3 01       	movw	r22, r6
    809a:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    809e:	81 10       	cpse	r8, r1
    80a0:	8a 94       	dec	r8
    80a2:	08 94       	sec
    80a4:	e1 08       	sbc	r14, r1
    80a6:	f1 08       	sbc	r15, r1
    80a8:	e1 14       	cp	r14, r1
    80aa:	f1 04       	cpc	r15, r1
    80ac:	71 f7       	brne	.-36     	; 0x808a <vfprintf+0x4ee>
    80ae:	f2 c0       	rjmp	.+484    	; 0x8294 <vfprintf+0x6f8>
    80b0:	94 36       	cpi	r25, 0x64	; 100
    80b2:	11 f0       	breq	.+4      	; 0x80b8 <vfprintf+0x51c>
    80b4:	99 36       	cpi	r25, 0x69	; 105
    80b6:	89 f5       	brne	.+98     	; 0x811a <vfprintf+0x57e>
    80b8:	17 ff       	sbrs	r17, 7
    80ba:	08 c0       	rjmp	.+16     	; 0x80cc <vfprintf+0x530>
    80bc:	f6 01       	movw	r30, r12
    80be:	20 81       	ld	r18, Z
    80c0:	31 81       	ldd	r19, Z+1	; 0x01
    80c2:	42 81       	ldd	r20, Z+2	; 0x02
    80c4:	53 81       	ldd	r21, Z+3	; 0x03
    80c6:	84 e0       	ldi	r24, 0x04	; 4
    80c8:	90 e0       	ldi	r25, 0x00	; 0
    80ca:	0a c0       	rjmp	.+20     	; 0x80e0 <vfprintf+0x544>
    80cc:	f6 01       	movw	r30, r12
    80ce:	80 81       	ld	r24, Z
    80d0:	91 81       	ldd	r25, Z+1	; 0x01
    80d2:	9c 01       	movw	r18, r24
    80d4:	44 27       	eor	r20, r20
    80d6:	37 fd       	sbrc	r19, 7
    80d8:	40 95       	com	r20
    80da:	54 2f       	mov	r21, r20
    80dc:	82 e0       	ldi	r24, 0x02	; 2
    80de:	90 e0       	ldi	r25, 0x00	; 0
    80e0:	c8 0e       	add	r12, r24
    80e2:	d9 1e       	adc	r13, r25
    80e4:	9f e6       	ldi	r25, 0x6F	; 111
    80e6:	f9 2e       	mov	r15, r25
    80e8:	f1 22       	and	r15, r17
    80ea:	57 ff       	sbrs	r21, 7
    80ec:	09 c0       	rjmp	.+18     	; 0x8100 <vfprintf+0x564>
    80ee:	50 95       	com	r21
    80f0:	40 95       	com	r20
    80f2:	30 95       	com	r19
    80f4:	21 95       	neg	r18
    80f6:	3f 4f       	sbci	r19, 0xFF	; 255
    80f8:	4f 4f       	sbci	r20, 0xFF	; 255
    80fa:	5f 4f       	sbci	r21, 0xFF	; 255
    80fc:	90 e8       	ldi	r25, 0x80	; 128
    80fe:	f9 2a       	or	r15, r25
    8100:	ca 01       	movw	r24, r20
    8102:	b9 01       	movw	r22, r18
    8104:	ae 01       	movw	r20, r28
    8106:	4f 5f       	subi	r20, 0xFF	; 255
    8108:	5f 4f       	sbci	r21, 0xFF	; 255
    810a:	2a e0       	ldi	r18, 0x0A	; 10
    810c:	30 e0       	ldi	r19, 0x00	; 0
    810e:	0e 94 2d 46 	call	0x8c5a	; 0x8c5a <__ultoa_invert>
    8112:	e8 2e       	mov	r14, r24
    8114:	e8 89       	ldd	r30, Y+16	; 0x10
    8116:	ee 1a       	sub	r14, r30
    8118:	41 c0       	rjmp	.+130    	; 0x819c <vfprintf+0x600>
    811a:	95 37       	cpi	r25, 0x75	; 117
    811c:	21 f4       	brne	.+8      	; 0x8126 <vfprintf+0x58a>
    811e:	1f 7e       	andi	r17, 0xEF	; 239
    8120:	2a e0       	ldi	r18, 0x0A	; 10
    8122:	30 e0       	ldi	r19, 0x00	; 0
    8124:	1c c0       	rjmp	.+56     	; 0x815e <vfprintf+0x5c2>
    8126:	19 7f       	andi	r17, 0xF9	; 249
    8128:	9f 36       	cpi	r25, 0x6F	; 111
    812a:	61 f0       	breq	.+24     	; 0x8144 <vfprintf+0x5a8>
    812c:	90 37       	cpi	r25, 0x70	; 112
    812e:	20 f4       	brcc	.+8      	; 0x8138 <vfprintf+0x59c>
    8130:	98 35       	cpi	r25, 0x58	; 88
    8132:	09 f0       	breq	.+2      	; 0x8136 <vfprintf+0x59a>
    8134:	b2 c0       	rjmp	.+356    	; 0x829a <vfprintf+0x6fe>
    8136:	0f c0       	rjmp	.+30     	; 0x8156 <vfprintf+0x5ba>
    8138:	90 37       	cpi	r25, 0x70	; 112
    813a:	39 f0       	breq	.+14     	; 0x814a <vfprintf+0x5ae>
    813c:	98 37       	cpi	r25, 0x78	; 120
    813e:	09 f0       	breq	.+2      	; 0x8142 <vfprintf+0x5a6>
    8140:	ac c0       	rjmp	.+344    	; 0x829a <vfprintf+0x6fe>
    8142:	04 c0       	rjmp	.+8      	; 0x814c <vfprintf+0x5b0>
    8144:	28 e0       	ldi	r18, 0x08	; 8
    8146:	30 e0       	ldi	r19, 0x00	; 0
    8148:	0a c0       	rjmp	.+20     	; 0x815e <vfprintf+0x5c2>
    814a:	10 61       	ori	r17, 0x10	; 16
    814c:	14 fd       	sbrc	r17, 4
    814e:	14 60       	ori	r17, 0x04	; 4
    8150:	20 e1       	ldi	r18, 0x10	; 16
    8152:	30 e0       	ldi	r19, 0x00	; 0
    8154:	04 c0       	rjmp	.+8      	; 0x815e <vfprintf+0x5c2>
    8156:	14 fd       	sbrc	r17, 4
    8158:	16 60       	ori	r17, 0x06	; 6
    815a:	20 e1       	ldi	r18, 0x10	; 16
    815c:	32 e0       	ldi	r19, 0x02	; 2
    815e:	17 ff       	sbrs	r17, 7
    8160:	08 c0       	rjmp	.+16     	; 0x8172 <vfprintf+0x5d6>
    8162:	f6 01       	movw	r30, r12
    8164:	60 81       	ld	r22, Z
    8166:	71 81       	ldd	r23, Z+1	; 0x01
    8168:	82 81       	ldd	r24, Z+2	; 0x02
    816a:	93 81       	ldd	r25, Z+3	; 0x03
    816c:	44 e0       	ldi	r20, 0x04	; 4
    816e:	50 e0       	ldi	r21, 0x00	; 0
    8170:	08 c0       	rjmp	.+16     	; 0x8182 <vfprintf+0x5e6>
    8172:	f6 01       	movw	r30, r12
    8174:	80 81       	ld	r24, Z
    8176:	91 81       	ldd	r25, Z+1	; 0x01
    8178:	bc 01       	movw	r22, r24
    817a:	80 e0       	ldi	r24, 0x00	; 0
    817c:	90 e0       	ldi	r25, 0x00	; 0
    817e:	42 e0       	ldi	r20, 0x02	; 2
    8180:	50 e0       	ldi	r21, 0x00	; 0
    8182:	c4 0e       	add	r12, r20
    8184:	d5 1e       	adc	r13, r21
    8186:	ae 01       	movw	r20, r28
    8188:	4f 5f       	subi	r20, 0xFF	; 255
    818a:	5f 4f       	sbci	r21, 0xFF	; 255
    818c:	0e 94 2d 46 	call	0x8c5a	; 0x8c5a <__ultoa_invert>
    8190:	e8 2e       	mov	r14, r24
    8192:	58 89       	ldd	r21, Y+16	; 0x10
    8194:	e5 1a       	sub	r14, r21
    8196:	8f e7       	ldi	r24, 0x7F	; 127
    8198:	f8 2e       	mov	r15, r24
    819a:	f1 22       	and	r15, r17
    819c:	f6 fe       	sbrs	r15, 6
    819e:	0b c0       	rjmp	.+22     	; 0x81b6 <vfprintf+0x61a>
    81a0:	8e ef       	ldi	r24, 0xFE	; 254
    81a2:	f8 22       	and	r15, r24
    81a4:	e9 14       	cp	r14, r9
    81a6:	38 f4       	brcc	.+14     	; 0x81b6 <vfprintf+0x61a>
    81a8:	f4 fe       	sbrs	r15, 4
    81aa:	07 c0       	rjmp	.+14     	; 0x81ba <vfprintf+0x61e>
    81ac:	f2 fc       	sbrc	r15, 2
    81ae:	05 c0       	rjmp	.+10     	; 0x81ba <vfprintf+0x61e>
    81b0:	9f ee       	ldi	r25, 0xEF	; 239
    81b2:	f9 22       	and	r15, r25
    81b4:	02 c0       	rjmp	.+4      	; 0x81ba <vfprintf+0x61e>
    81b6:	1e 2d       	mov	r17, r14
    81b8:	01 c0       	rjmp	.+2      	; 0x81bc <vfprintf+0x620>
    81ba:	19 2d       	mov	r17, r9
    81bc:	f4 fe       	sbrs	r15, 4
    81be:	0d c0       	rjmp	.+26     	; 0x81da <vfprintf+0x63e>
    81c0:	fe 01       	movw	r30, r28
    81c2:	ee 0d       	add	r30, r14
    81c4:	f1 1d       	adc	r31, r1
    81c6:	80 81       	ld	r24, Z
    81c8:	80 33       	cpi	r24, 0x30	; 48
    81ca:	19 f4       	brne	.+6      	; 0x81d2 <vfprintf+0x636>
    81cc:	e9 ee       	ldi	r30, 0xE9	; 233
    81ce:	fe 22       	and	r15, r30
    81d0:	08 c0       	rjmp	.+16     	; 0x81e2 <vfprintf+0x646>
    81d2:	1f 5f       	subi	r17, 0xFF	; 255
    81d4:	f2 fe       	sbrs	r15, 2
    81d6:	05 c0       	rjmp	.+10     	; 0x81e2 <vfprintf+0x646>
    81d8:	03 c0       	rjmp	.+6      	; 0x81e0 <vfprintf+0x644>
    81da:	8f 2d       	mov	r24, r15
    81dc:	86 78       	andi	r24, 0x86	; 134
    81de:	09 f0       	breq	.+2      	; 0x81e2 <vfprintf+0x646>
    81e0:	1f 5f       	subi	r17, 0xFF	; 255
    81e2:	0f 2d       	mov	r16, r15
    81e4:	f3 fc       	sbrc	r15, 3
    81e6:	14 c0       	rjmp	.+40     	; 0x8210 <vfprintf+0x674>
    81e8:	f0 fe       	sbrs	r15, 0
    81ea:	0f c0       	rjmp	.+30     	; 0x820a <vfprintf+0x66e>
    81ec:	18 15       	cp	r17, r8
    81ee:	10 f0       	brcs	.+4      	; 0x81f4 <vfprintf+0x658>
    81f0:	9e 2c       	mov	r9, r14
    81f2:	0b c0       	rjmp	.+22     	; 0x820a <vfprintf+0x66e>
    81f4:	9e 2c       	mov	r9, r14
    81f6:	98 0c       	add	r9, r8
    81f8:	91 1a       	sub	r9, r17
    81fa:	18 2d       	mov	r17, r8
    81fc:	06 c0       	rjmp	.+12     	; 0x820a <vfprintf+0x66e>
    81fe:	80 e2       	ldi	r24, 0x20	; 32
    8200:	90 e0       	ldi	r25, 0x00	; 0
    8202:	b3 01       	movw	r22, r6
    8204:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8208:	1f 5f       	subi	r17, 0xFF	; 255
    820a:	18 15       	cp	r17, r8
    820c:	c0 f3       	brcs	.-16     	; 0x81fe <vfprintf+0x662>
    820e:	04 c0       	rjmp	.+8      	; 0x8218 <vfprintf+0x67c>
    8210:	18 15       	cp	r17, r8
    8212:	10 f4       	brcc	.+4      	; 0x8218 <vfprintf+0x67c>
    8214:	81 1a       	sub	r8, r17
    8216:	01 c0       	rjmp	.+2      	; 0x821a <vfprintf+0x67e>
    8218:	88 24       	eor	r8, r8
    821a:	04 ff       	sbrs	r16, 4
    821c:	0f c0       	rjmp	.+30     	; 0x823c <vfprintf+0x6a0>
    821e:	80 e3       	ldi	r24, 0x30	; 48
    8220:	90 e0       	ldi	r25, 0x00	; 0
    8222:	b3 01       	movw	r22, r6
    8224:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8228:	02 ff       	sbrs	r16, 2
    822a:	1d c0       	rjmp	.+58     	; 0x8266 <vfprintf+0x6ca>
    822c:	01 fd       	sbrc	r16, 1
    822e:	03 c0       	rjmp	.+6      	; 0x8236 <vfprintf+0x69a>
    8230:	88 e7       	ldi	r24, 0x78	; 120
    8232:	90 e0       	ldi	r25, 0x00	; 0
    8234:	0e c0       	rjmp	.+28     	; 0x8252 <vfprintf+0x6b6>
    8236:	88 e5       	ldi	r24, 0x58	; 88
    8238:	90 e0       	ldi	r25, 0x00	; 0
    823a:	0b c0       	rjmp	.+22     	; 0x8252 <vfprintf+0x6b6>
    823c:	80 2f       	mov	r24, r16
    823e:	86 78       	andi	r24, 0x86	; 134
    8240:	91 f0       	breq	.+36     	; 0x8266 <vfprintf+0x6ca>
    8242:	01 ff       	sbrs	r16, 1
    8244:	02 c0       	rjmp	.+4      	; 0x824a <vfprintf+0x6ae>
    8246:	8b e2       	ldi	r24, 0x2B	; 43
    8248:	01 c0       	rjmp	.+2      	; 0x824c <vfprintf+0x6b0>
    824a:	80 e2       	ldi	r24, 0x20	; 32
    824c:	f7 fc       	sbrc	r15, 7
    824e:	8d e2       	ldi	r24, 0x2D	; 45
    8250:	90 e0       	ldi	r25, 0x00	; 0
    8252:	b3 01       	movw	r22, r6
    8254:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8258:	06 c0       	rjmp	.+12     	; 0x8266 <vfprintf+0x6ca>
    825a:	80 e3       	ldi	r24, 0x30	; 48
    825c:	90 e0       	ldi	r25, 0x00	; 0
    825e:	b3 01       	movw	r22, r6
    8260:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8264:	9a 94       	dec	r9
    8266:	e9 14       	cp	r14, r9
    8268:	c0 f3       	brcs	.-16     	; 0x825a <vfprintf+0x6be>
    826a:	ea 94       	dec	r14
    826c:	e1 e0       	ldi	r30, 0x01	; 1
    826e:	f0 e0       	ldi	r31, 0x00	; 0
    8270:	ec 0f       	add	r30, r28
    8272:	fd 1f       	adc	r31, r29
    8274:	ee 0d       	add	r30, r14
    8276:	f1 1d       	adc	r31, r1
    8278:	80 81       	ld	r24, Z
    827a:	90 e0       	ldi	r25, 0x00	; 0
    827c:	b3 01       	movw	r22, r6
    827e:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8282:	ee 20       	and	r14, r14
    8284:	91 f7       	brne	.-28     	; 0x826a <vfprintf+0x6ce>
    8286:	06 c0       	rjmp	.+12     	; 0x8294 <vfprintf+0x6f8>
    8288:	80 e2       	ldi	r24, 0x20	; 32
    828a:	90 e0       	ldi	r25, 0x00	; 0
    828c:	b3 01       	movw	r22, r6
    828e:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8292:	8a 94       	dec	r8
    8294:	88 20       	and	r8, r8
    8296:	c1 f7       	brne	.-16     	; 0x8288 <vfprintf+0x6ec>
    8298:	99 cc       	rjmp	.-1742   	; 0x7bcc <vfprintf+0x30>
    829a:	f3 01       	movw	r30, r6
    829c:	66 81       	ldd	r22, Z+6	; 0x06
    829e:	77 81       	ldd	r23, Z+7	; 0x07
    82a0:	cb 01       	movw	r24, r22
    82a2:	61 96       	adiw	r28, 0x11	; 17
    82a4:	e2 e1       	ldi	r30, 0x12	; 18
    82a6:	0c 94 a9 43 	jmp	0x8752	; 0x8752 <__epilogue_restores__>

000082aa <__subsf3>:
    82aa:	50 58       	subi	r21, 0x80	; 128

000082ac <__addsf3>:
    82ac:	bb 27       	eor	r27, r27
    82ae:	aa 27       	eor	r26, r26
    82b0:	0e d0       	rcall	.+28     	; 0x82ce <__addsf3x>
    82b2:	70 c1       	rjmp	.+736    	; 0x8594 <__fp_round>
    82b4:	61 d1       	rcall	.+706    	; 0x8578 <__fp_pscA>
    82b6:	30 f0       	brcs	.+12     	; 0x82c4 <__addsf3+0x18>
    82b8:	66 d1       	rcall	.+716    	; 0x8586 <__fp_pscB>
    82ba:	20 f0       	brcs	.+8      	; 0x82c4 <__addsf3+0x18>
    82bc:	31 f4       	brne	.+12     	; 0x82ca <__addsf3+0x1e>
    82be:	9f 3f       	cpi	r25, 0xFF	; 255
    82c0:	11 f4       	brne	.+4      	; 0x82c6 <__addsf3+0x1a>
    82c2:	1e f4       	brtc	.+6      	; 0x82ca <__addsf3+0x1e>
    82c4:	56 c1       	rjmp	.+684    	; 0x8572 <__fp_nan>
    82c6:	0e f4       	brtc	.+2      	; 0x82ca <__addsf3+0x1e>
    82c8:	e0 95       	com	r30
    82ca:	e7 fb       	bst	r30, 7
    82cc:	4c c1       	rjmp	.+664    	; 0x8566 <__fp_inf>

000082ce <__addsf3x>:
    82ce:	e9 2f       	mov	r30, r25
    82d0:	72 d1       	rcall	.+740    	; 0x85b6 <__fp_split3>
    82d2:	80 f3       	brcs	.-32     	; 0x82b4 <__addsf3+0x8>
    82d4:	ba 17       	cp	r27, r26
    82d6:	62 07       	cpc	r22, r18
    82d8:	73 07       	cpc	r23, r19
    82da:	84 07       	cpc	r24, r20
    82dc:	95 07       	cpc	r25, r21
    82de:	18 f0       	brcs	.+6      	; 0x82e6 <__addsf3x+0x18>
    82e0:	71 f4       	brne	.+28     	; 0x82fe <__addsf3x+0x30>
    82e2:	9e f5       	brtc	.+102    	; 0x834a <__addsf3x+0x7c>
    82e4:	8a c1       	rjmp	.+788    	; 0x85fa <__fp_zero>
    82e6:	0e f4       	brtc	.+2      	; 0x82ea <__addsf3x+0x1c>
    82e8:	e0 95       	com	r30
    82ea:	0b 2e       	mov	r0, r27
    82ec:	ba 2f       	mov	r27, r26
    82ee:	a0 2d       	mov	r26, r0
    82f0:	0b 01       	movw	r0, r22
    82f2:	b9 01       	movw	r22, r18
    82f4:	90 01       	movw	r18, r0
    82f6:	0c 01       	movw	r0, r24
    82f8:	ca 01       	movw	r24, r20
    82fa:	a0 01       	movw	r20, r0
    82fc:	11 24       	eor	r1, r1
    82fe:	ff 27       	eor	r31, r31
    8300:	59 1b       	sub	r21, r25
    8302:	99 f0       	breq	.+38     	; 0x832a <__addsf3x+0x5c>
    8304:	59 3f       	cpi	r21, 0xF9	; 249
    8306:	50 f4       	brcc	.+20     	; 0x831c <__addsf3x+0x4e>
    8308:	50 3e       	cpi	r21, 0xE0	; 224
    830a:	68 f1       	brcs	.+90     	; 0x8366 <__addsf3x+0x98>
    830c:	1a 16       	cp	r1, r26
    830e:	f0 40       	sbci	r31, 0x00	; 0
    8310:	a2 2f       	mov	r26, r18
    8312:	23 2f       	mov	r18, r19
    8314:	34 2f       	mov	r19, r20
    8316:	44 27       	eor	r20, r20
    8318:	58 5f       	subi	r21, 0xF8	; 248
    831a:	f3 cf       	rjmp	.-26     	; 0x8302 <__addsf3x+0x34>
    831c:	46 95       	lsr	r20
    831e:	37 95       	ror	r19
    8320:	27 95       	ror	r18
    8322:	a7 95       	ror	r26
    8324:	f0 40       	sbci	r31, 0x00	; 0
    8326:	53 95       	inc	r21
    8328:	c9 f7       	brne	.-14     	; 0x831c <__addsf3x+0x4e>
    832a:	7e f4       	brtc	.+30     	; 0x834a <__addsf3x+0x7c>
    832c:	1f 16       	cp	r1, r31
    832e:	ba 0b       	sbc	r27, r26
    8330:	62 0b       	sbc	r22, r18
    8332:	73 0b       	sbc	r23, r19
    8334:	84 0b       	sbc	r24, r20
    8336:	ba f0       	brmi	.+46     	; 0x8366 <__addsf3x+0x98>
    8338:	91 50       	subi	r25, 0x01	; 1
    833a:	a1 f0       	breq	.+40     	; 0x8364 <__addsf3x+0x96>
    833c:	ff 0f       	add	r31, r31
    833e:	bb 1f       	adc	r27, r27
    8340:	66 1f       	adc	r22, r22
    8342:	77 1f       	adc	r23, r23
    8344:	88 1f       	adc	r24, r24
    8346:	c2 f7       	brpl	.-16     	; 0x8338 <__addsf3x+0x6a>
    8348:	0e c0       	rjmp	.+28     	; 0x8366 <__addsf3x+0x98>
    834a:	ba 0f       	add	r27, r26
    834c:	62 1f       	adc	r22, r18
    834e:	73 1f       	adc	r23, r19
    8350:	84 1f       	adc	r24, r20
    8352:	48 f4       	brcc	.+18     	; 0x8366 <__addsf3x+0x98>
    8354:	87 95       	ror	r24
    8356:	77 95       	ror	r23
    8358:	67 95       	ror	r22
    835a:	b7 95       	ror	r27
    835c:	f7 95       	ror	r31
    835e:	9e 3f       	cpi	r25, 0xFE	; 254
    8360:	08 f0       	brcs	.+2      	; 0x8364 <__addsf3x+0x96>
    8362:	b3 cf       	rjmp	.-154    	; 0x82ca <__addsf3+0x1e>
    8364:	93 95       	inc	r25
    8366:	88 0f       	add	r24, r24
    8368:	08 f0       	brcs	.+2      	; 0x836c <__addsf3x+0x9e>
    836a:	99 27       	eor	r25, r25
    836c:	ee 0f       	add	r30, r30
    836e:	97 95       	ror	r25
    8370:	87 95       	ror	r24
    8372:	08 95       	ret

00008374 <__cmpsf2>:
    8374:	d4 d0       	rcall	.+424    	; 0x851e <__fp_cmp>
    8376:	08 f4       	brcc	.+2      	; 0x837a <__cmpsf2+0x6>
    8378:	81 e0       	ldi	r24, 0x01	; 1
    837a:	08 95       	ret

0000837c <__divsf3>:
    837c:	0c d0       	rcall	.+24     	; 0x8396 <__divsf3x>
    837e:	0a c1       	rjmp	.+532    	; 0x8594 <__fp_round>
    8380:	02 d1       	rcall	.+516    	; 0x8586 <__fp_pscB>
    8382:	40 f0       	brcs	.+16     	; 0x8394 <__divsf3+0x18>
    8384:	f9 d0       	rcall	.+498    	; 0x8578 <__fp_pscA>
    8386:	30 f0       	brcs	.+12     	; 0x8394 <__divsf3+0x18>
    8388:	21 f4       	brne	.+8      	; 0x8392 <__divsf3+0x16>
    838a:	5f 3f       	cpi	r21, 0xFF	; 255
    838c:	19 f0       	breq	.+6      	; 0x8394 <__divsf3+0x18>
    838e:	eb c0       	rjmp	.+470    	; 0x8566 <__fp_inf>
    8390:	51 11       	cpse	r21, r1
    8392:	34 c1       	rjmp	.+616    	; 0x85fc <__fp_szero>
    8394:	ee c0       	rjmp	.+476    	; 0x8572 <__fp_nan>

00008396 <__divsf3x>:
    8396:	0f d1       	rcall	.+542    	; 0x85b6 <__fp_split3>
    8398:	98 f3       	brcs	.-26     	; 0x8380 <__divsf3+0x4>

0000839a <__divsf3_pse>:
    839a:	99 23       	and	r25, r25
    839c:	c9 f3       	breq	.-14     	; 0x8390 <__divsf3+0x14>
    839e:	55 23       	and	r21, r21
    83a0:	b1 f3       	breq	.-20     	; 0x838e <__divsf3+0x12>
    83a2:	95 1b       	sub	r25, r21
    83a4:	55 0b       	sbc	r21, r21
    83a6:	bb 27       	eor	r27, r27
    83a8:	aa 27       	eor	r26, r26
    83aa:	62 17       	cp	r22, r18
    83ac:	73 07       	cpc	r23, r19
    83ae:	84 07       	cpc	r24, r20
    83b0:	38 f0       	brcs	.+14     	; 0x83c0 <__divsf3_pse+0x26>
    83b2:	9f 5f       	subi	r25, 0xFF	; 255
    83b4:	5f 4f       	sbci	r21, 0xFF	; 255
    83b6:	22 0f       	add	r18, r18
    83b8:	33 1f       	adc	r19, r19
    83ba:	44 1f       	adc	r20, r20
    83bc:	aa 1f       	adc	r26, r26
    83be:	a9 f3       	breq	.-22     	; 0x83aa <__divsf3_pse+0x10>
    83c0:	33 d0       	rcall	.+102    	; 0x8428 <__divsf3_pse+0x8e>
    83c2:	0e 2e       	mov	r0, r30
    83c4:	3a f0       	brmi	.+14     	; 0x83d4 <__divsf3_pse+0x3a>
    83c6:	e0 e8       	ldi	r30, 0x80	; 128
    83c8:	30 d0       	rcall	.+96     	; 0x842a <__divsf3_pse+0x90>
    83ca:	91 50       	subi	r25, 0x01	; 1
    83cc:	50 40       	sbci	r21, 0x00	; 0
    83ce:	e6 95       	lsr	r30
    83d0:	00 1c       	adc	r0, r0
    83d2:	ca f7       	brpl	.-14     	; 0x83c6 <__divsf3_pse+0x2c>
    83d4:	29 d0       	rcall	.+82     	; 0x8428 <__divsf3_pse+0x8e>
    83d6:	fe 2f       	mov	r31, r30
    83d8:	27 d0       	rcall	.+78     	; 0x8428 <__divsf3_pse+0x8e>
    83da:	66 0f       	add	r22, r22
    83dc:	77 1f       	adc	r23, r23
    83de:	88 1f       	adc	r24, r24
    83e0:	bb 1f       	adc	r27, r27
    83e2:	26 17       	cp	r18, r22
    83e4:	37 07       	cpc	r19, r23
    83e6:	48 07       	cpc	r20, r24
    83e8:	ab 07       	cpc	r26, r27
    83ea:	b0 e8       	ldi	r27, 0x80	; 128
    83ec:	09 f0       	breq	.+2      	; 0x83f0 <__divsf3_pse+0x56>
    83ee:	bb 0b       	sbc	r27, r27
    83f0:	80 2d       	mov	r24, r0
    83f2:	bf 01       	movw	r22, r30
    83f4:	ff 27       	eor	r31, r31
    83f6:	93 58       	subi	r25, 0x83	; 131
    83f8:	5f 4f       	sbci	r21, 0xFF	; 255
    83fa:	2a f0       	brmi	.+10     	; 0x8406 <__divsf3_pse+0x6c>
    83fc:	9e 3f       	cpi	r25, 0xFE	; 254
    83fe:	51 05       	cpc	r21, r1
    8400:	68 f0       	brcs	.+26     	; 0x841c <__divsf3_pse+0x82>
    8402:	b1 c0       	rjmp	.+354    	; 0x8566 <__fp_inf>
    8404:	fb c0       	rjmp	.+502    	; 0x85fc <__fp_szero>
    8406:	5f 3f       	cpi	r21, 0xFF	; 255
    8408:	ec f3       	brlt	.-6      	; 0x8404 <__divsf3_pse+0x6a>
    840a:	98 3e       	cpi	r25, 0xE8	; 232
    840c:	dc f3       	brlt	.-10     	; 0x8404 <__divsf3_pse+0x6a>
    840e:	86 95       	lsr	r24
    8410:	77 95       	ror	r23
    8412:	67 95       	ror	r22
    8414:	b7 95       	ror	r27
    8416:	f7 95       	ror	r31
    8418:	9f 5f       	subi	r25, 0xFF	; 255
    841a:	c9 f7       	brne	.-14     	; 0x840e <__divsf3_pse+0x74>
    841c:	88 0f       	add	r24, r24
    841e:	91 1d       	adc	r25, r1
    8420:	96 95       	lsr	r25
    8422:	87 95       	ror	r24
    8424:	97 f9       	bld	r25, 7
    8426:	08 95       	ret
    8428:	e1 e0       	ldi	r30, 0x01	; 1
    842a:	66 0f       	add	r22, r22
    842c:	77 1f       	adc	r23, r23
    842e:	88 1f       	adc	r24, r24
    8430:	bb 1f       	adc	r27, r27
    8432:	62 17       	cp	r22, r18
    8434:	73 07       	cpc	r23, r19
    8436:	84 07       	cpc	r24, r20
    8438:	ba 07       	cpc	r27, r26
    843a:	20 f0       	brcs	.+8      	; 0x8444 <__divsf3_pse+0xaa>
    843c:	62 1b       	sub	r22, r18
    843e:	73 0b       	sbc	r23, r19
    8440:	84 0b       	sbc	r24, r20
    8442:	ba 0b       	sbc	r27, r26
    8444:	ee 1f       	adc	r30, r30
    8446:	88 f7       	brcc	.-30     	; 0x842a <__divsf3_pse+0x90>
    8448:	e0 95       	com	r30
    844a:	08 95       	ret

0000844c <__fixunssfsi>:
    844c:	bc d0       	rcall	.+376    	; 0x85c6 <__fp_splitA>
    844e:	88 f0       	brcs	.+34     	; 0x8472 <__fixunssfsi+0x26>
    8450:	9f 57       	subi	r25, 0x7F	; 127
    8452:	90 f0       	brcs	.+36     	; 0x8478 <__fixunssfsi+0x2c>
    8454:	b9 2f       	mov	r27, r25
    8456:	99 27       	eor	r25, r25
    8458:	b7 51       	subi	r27, 0x17	; 23
    845a:	a0 f0       	brcs	.+40     	; 0x8484 <__fixunssfsi+0x38>
    845c:	d1 f0       	breq	.+52     	; 0x8492 <__fixunssfsi+0x46>
    845e:	66 0f       	add	r22, r22
    8460:	77 1f       	adc	r23, r23
    8462:	88 1f       	adc	r24, r24
    8464:	99 1f       	adc	r25, r25
    8466:	1a f0       	brmi	.+6      	; 0x846e <__fixunssfsi+0x22>
    8468:	ba 95       	dec	r27
    846a:	c9 f7       	brne	.-14     	; 0x845e <__fixunssfsi+0x12>
    846c:	12 c0       	rjmp	.+36     	; 0x8492 <__fixunssfsi+0x46>
    846e:	b1 30       	cpi	r27, 0x01	; 1
    8470:	81 f0       	breq	.+32     	; 0x8492 <__fixunssfsi+0x46>
    8472:	c3 d0       	rcall	.+390    	; 0x85fa <__fp_zero>
    8474:	b1 e0       	ldi	r27, 0x01	; 1
    8476:	08 95       	ret
    8478:	c0 c0       	rjmp	.+384    	; 0x85fa <__fp_zero>
    847a:	67 2f       	mov	r22, r23
    847c:	78 2f       	mov	r23, r24
    847e:	88 27       	eor	r24, r24
    8480:	b8 5f       	subi	r27, 0xF8	; 248
    8482:	39 f0       	breq	.+14     	; 0x8492 <__fixunssfsi+0x46>
    8484:	b9 3f       	cpi	r27, 0xF9	; 249
    8486:	cc f3       	brlt	.-14     	; 0x847a <__fixunssfsi+0x2e>
    8488:	86 95       	lsr	r24
    848a:	77 95       	ror	r23
    848c:	67 95       	ror	r22
    848e:	b3 95       	inc	r27
    8490:	d9 f7       	brne	.-10     	; 0x8488 <__fixunssfsi+0x3c>
    8492:	3e f4       	brtc	.+14     	; 0x84a2 <__fixunssfsi+0x56>
    8494:	90 95       	com	r25
    8496:	80 95       	com	r24
    8498:	70 95       	com	r23
    849a:	61 95       	neg	r22
    849c:	7f 4f       	sbci	r23, 0xFF	; 255
    849e:	8f 4f       	sbci	r24, 0xFF	; 255
    84a0:	9f 4f       	sbci	r25, 0xFF	; 255
    84a2:	08 95       	ret

000084a4 <__floatunsisf>:
    84a4:	e8 94       	clt
    84a6:	09 c0       	rjmp	.+18     	; 0x84ba <__floatsisf+0x12>

000084a8 <__floatsisf>:
    84a8:	97 fb       	bst	r25, 7
    84aa:	3e f4       	brtc	.+14     	; 0x84ba <__floatsisf+0x12>
    84ac:	90 95       	com	r25
    84ae:	80 95       	com	r24
    84b0:	70 95       	com	r23
    84b2:	61 95       	neg	r22
    84b4:	7f 4f       	sbci	r23, 0xFF	; 255
    84b6:	8f 4f       	sbci	r24, 0xFF	; 255
    84b8:	9f 4f       	sbci	r25, 0xFF	; 255
    84ba:	99 23       	and	r25, r25
    84bc:	a9 f0       	breq	.+42     	; 0x84e8 <__floatsisf+0x40>
    84be:	f9 2f       	mov	r31, r25
    84c0:	96 e9       	ldi	r25, 0x96	; 150
    84c2:	bb 27       	eor	r27, r27
    84c4:	93 95       	inc	r25
    84c6:	f6 95       	lsr	r31
    84c8:	87 95       	ror	r24
    84ca:	77 95       	ror	r23
    84cc:	67 95       	ror	r22
    84ce:	b7 95       	ror	r27
    84d0:	f1 11       	cpse	r31, r1
    84d2:	f8 cf       	rjmp	.-16     	; 0x84c4 <__floatsisf+0x1c>
    84d4:	fa f4       	brpl	.+62     	; 0x8514 <__floatsisf+0x6c>
    84d6:	bb 0f       	add	r27, r27
    84d8:	11 f4       	brne	.+4      	; 0x84de <__floatsisf+0x36>
    84da:	60 ff       	sbrs	r22, 0
    84dc:	1b c0       	rjmp	.+54     	; 0x8514 <__floatsisf+0x6c>
    84de:	6f 5f       	subi	r22, 0xFF	; 255
    84e0:	7f 4f       	sbci	r23, 0xFF	; 255
    84e2:	8f 4f       	sbci	r24, 0xFF	; 255
    84e4:	9f 4f       	sbci	r25, 0xFF	; 255
    84e6:	16 c0       	rjmp	.+44     	; 0x8514 <__floatsisf+0x6c>
    84e8:	88 23       	and	r24, r24
    84ea:	11 f0       	breq	.+4      	; 0x84f0 <__floatsisf+0x48>
    84ec:	96 e9       	ldi	r25, 0x96	; 150
    84ee:	11 c0       	rjmp	.+34     	; 0x8512 <__floatsisf+0x6a>
    84f0:	77 23       	and	r23, r23
    84f2:	21 f0       	breq	.+8      	; 0x84fc <__floatsisf+0x54>
    84f4:	9e e8       	ldi	r25, 0x8E	; 142
    84f6:	87 2f       	mov	r24, r23
    84f8:	76 2f       	mov	r23, r22
    84fa:	05 c0       	rjmp	.+10     	; 0x8506 <__floatsisf+0x5e>
    84fc:	66 23       	and	r22, r22
    84fe:	71 f0       	breq	.+28     	; 0x851c <__floatsisf+0x74>
    8500:	96 e8       	ldi	r25, 0x86	; 134
    8502:	86 2f       	mov	r24, r22
    8504:	70 e0       	ldi	r23, 0x00	; 0
    8506:	60 e0       	ldi	r22, 0x00	; 0
    8508:	2a f0       	brmi	.+10     	; 0x8514 <__floatsisf+0x6c>
    850a:	9a 95       	dec	r25
    850c:	66 0f       	add	r22, r22
    850e:	77 1f       	adc	r23, r23
    8510:	88 1f       	adc	r24, r24
    8512:	da f7       	brpl	.-10     	; 0x850a <__floatsisf+0x62>
    8514:	88 0f       	add	r24, r24
    8516:	96 95       	lsr	r25
    8518:	87 95       	ror	r24
    851a:	97 f9       	bld	r25, 7
    851c:	08 95       	ret

0000851e <__fp_cmp>:
    851e:	99 0f       	add	r25, r25
    8520:	00 08       	sbc	r0, r0
    8522:	55 0f       	add	r21, r21
    8524:	aa 0b       	sbc	r26, r26
    8526:	e0 e8       	ldi	r30, 0x80	; 128
    8528:	fe ef       	ldi	r31, 0xFE	; 254
    852a:	16 16       	cp	r1, r22
    852c:	17 06       	cpc	r1, r23
    852e:	e8 07       	cpc	r30, r24
    8530:	f9 07       	cpc	r31, r25
    8532:	c0 f0       	brcs	.+48     	; 0x8564 <__fp_cmp+0x46>
    8534:	12 16       	cp	r1, r18
    8536:	13 06       	cpc	r1, r19
    8538:	e4 07       	cpc	r30, r20
    853a:	f5 07       	cpc	r31, r21
    853c:	98 f0       	brcs	.+38     	; 0x8564 <__fp_cmp+0x46>
    853e:	62 1b       	sub	r22, r18
    8540:	73 0b       	sbc	r23, r19
    8542:	84 0b       	sbc	r24, r20
    8544:	95 0b       	sbc	r25, r21
    8546:	39 f4       	brne	.+14     	; 0x8556 <__fp_cmp+0x38>
    8548:	0a 26       	eor	r0, r26
    854a:	61 f0       	breq	.+24     	; 0x8564 <__fp_cmp+0x46>
    854c:	23 2b       	or	r18, r19
    854e:	24 2b       	or	r18, r20
    8550:	25 2b       	or	r18, r21
    8552:	21 f4       	brne	.+8      	; 0x855c <__fp_cmp+0x3e>
    8554:	08 95       	ret
    8556:	0a 26       	eor	r0, r26
    8558:	09 f4       	brne	.+2      	; 0x855c <__fp_cmp+0x3e>
    855a:	a1 40       	sbci	r26, 0x01	; 1
    855c:	a6 95       	lsr	r26
    855e:	8f ef       	ldi	r24, 0xFF	; 255
    8560:	81 1d       	adc	r24, r1
    8562:	81 1d       	adc	r24, r1
    8564:	08 95       	ret

00008566 <__fp_inf>:
    8566:	97 f9       	bld	r25, 7
    8568:	9f 67       	ori	r25, 0x7F	; 127
    856a:	80 e8       	ldi	r24, 0x80	; 128
    856c:	70 e0       	ldi	r23, 0x00	; 0
    856e:	60 e0       	ldi	r22, 0x00	; 0
    8570:	08 95       	ret

00008572 <__fp_nan>:
    8572:	9f ef       	ldi	r25, 0xFF	; 255
    8574:	80 ec       	ldi	r24, 0xC0	; 192
    8576:	08 95       	ret

00008578 <__fp_pscA>:
    8578:	00 24       	eor	r0, r0
    857a:	0a 94       	dec	r0
    857c:	16 16       	cp	r1, r22
    857e:	17 06       	cpc	r1, r23
    8580:	18 06       	cpc	r1, r24
    8582:	09 06       	cpc	r0, r25
    8584:	08 95       	ret

00008586 <__fp_pscB>:
    8586:	00 24       	eor	r0, r0
    8588:	0a 94       	dec	r0
    858a:	12 16       	cp	r1, r18
    858c:	13 06       	cpc	r1, r19
    858e:	14 06       	cpc	r1, r20
    8590:	05 06       	cpc	r0, r21
    8592:	08 95       	ret

00008594 <__fp_round>:
    8594:	09 2e       	mov	r0, r25
    8596:	03 94       	inc	r0
    8598:	00 0c       	add	r0, r0
    859a:	11 f4       	brne	.+4      	; 0x85a0 <__fp_round+0xc>
    859c:	88 23       	and	r24, r24
    859e:	52 f0       	brmi	.+20     	; 0x85b4 <__fp_round+0x20>
    85a0:	bb 0f       	add	r27, r27
    85a2:	40 f4       	brcc	.+16     	; 0x85b4 <__fp_round+0x20>
    85a4:	bf 2b       	or	r27, r31
    85a6:	11 f4       	brne	.+4      	; 0x85ac <__fp_round+0x18>
    85a8:	60 ff       	sbrs	r22, 0
    85aa:	04 c0       	rjmp	.+8      	; 0x85b4 <__fp_round+0x20>
    85ac:	6f 5f       	subi	r22, 0xFF	; 255
    85ae:	7f 4f       	sbci	r23, 0xFF	; 255
    85b0:	8f 4f       	sbci	r24, 0xFF	; 255
    85b2:	9f 4f       	sbci	r25, 0xFF	; 255
    85b4:	08 95       	ret

000085b6 <__fp_split3>:
    85b6:	57 fd       	sbrc	r21, 7
    85b8:	90 58       	subi	r25, 0x80	; 128
    85ba:	44 0f       	add	r20, r20
    85bc:	55 1f       	adc	r21, r21
    85be:	59 f0       	breq	.+22     	; 0x85d6 <__fp_splitA+0x10>
    85c0:	5f 3f       	cpi	r21, 0xFF	; 255
    85c2:	71 f0       	breq	.+28     	; 0x85e0 <__fp_splitA+0x1a>
    85c4:	47 95       	ror	r20

000085c6 <__fp_splitA>:
    85c6:	88 0f       	add	r24, r24
    85c8:	97 fb       	bst	r25, 7
    85ca:	99 1f       	adc	r25, r25
    85cc:	61 f0       	breq	.+24     	; 0x85e6 <__fp_splitA+0x20>
    85ce:	9f 3f       	cpi	r25, 0xFF	; 255
    85d0:	79 f0       	breq	.+30     	; 0x85f0 <__fp_splitA+0x2a>
    85d2:	87 95       	ror	r24
    85d4:	08 95       	ret
    85d6:	12 16       	cp	r1, r18
    85d8:	13 06       	cpc	r1, r19
    85da:	14 06       	cpc	r1, r20
    85dc:	55 1f       	adc	r21, r21
    85de:	f2 cf       	rjmp	.-28     	; 0x85c4 <__fp_split3+0xe>
    85e0:	46 95       	lsr	r20
    85e2:	f1 df       	rcall	.-30     	; 0x85c6 <__fp_splitA>
    85e4:	08 c0       	rjmp	.+16     	; 0x85f6 <__fp_splitA+0x30>
    85e6:	16 16       	cp	r1, r22
    85e8:	17 06       	cpc	r1, r23
    85ea:	18 06       	cpc	r1, r24
    85ec:	99 1f       	adc	r25, r25
    85ee:	f1 cf       	rjmp	.-30     	; 0x85d2 <__fp_splitA+0xc>
    85f0:	86 95       	lsr	r24
    85f2:	71 05       	cpc	r23, r1
    85f4:	61 05       	cpc	r22, r1
    85f6:	08 94       	sec
    85f8:	08 95       	ret

000085fa <__fp_zero>:
    85fa:	e8 94       	clt

000085fc <__fp_szero>:
    85fc:	bb 27       	eor	r27, r27
    85fe:	66 27       	eor	r22, r22
    8600:	77 27       	eor	r23, r23
    8602:	cb 01       	movw	r24, r22
    8604:	97 f9       	bld	r25, 7
    8606:	08 95       	ret

00008608 <__gesf2>:
    8608:	8a df       	rcall	.-236    	; 0x851e <__fp_cmp>
    860a:	08 f4       	brcc	.+2      	; 0x860e <__gesf2+0x6>
    860c:	8f ef       	ldi	r24, 0xFF	; 255
    860e:	08 95       	ret

00008610 <__mulsf3>:
    8610:	0b d0       	rcall	.+22     	; 0x8628 <__mulsf3x>
    8612:	c0 cf       	rjmp	.-128    	; 0x8594 <__fp_round>
    8614:	b1 df       	rcall	.-158    	; 0x8578 <__fp_pscA>
    8616:	28 f0       	brcs	.+10     	; 0x8622 <__mulsf3+0x12>
    8618:	b6 df       	rcall	.-148    	; 0x8586 <__fp_pscB>
    861a:	18 f0       	brcs	.+6      	; 0x8622 <__mulsf3+0x12>
    861c:	95 23       	and	r25, r21
    861e:	09 f0       	breq	.+2      	; 0x8622 <__mulsf3+0x12>
    8620:	a2 cf       	rjmp	.-188    	; 0x8566 <__fp_inf>
    8622:	a7 cf       	rjmp	.-178    	; 0x8572 <__fp_nan>
    8624:	11 24       	eor	r1, r1
    8626:	ea cf       	rjmp	.-44     	; 0x85fc <__fp_szero>

00008628 <__mulsf3x>:
    8628:	c6 df       	rcall	.-116    	; 0x85b6 <__fp_split3>
    862a:	a0 f3       	brcs	.-24     	; 0x8614 <__mulsf3+0x4>

0000862c <__mulsf3_pse>:
    862c:	95 9f       	mul	r25, r21
    862e:	d1 f3       	breq	.-12     	; 0x8624 <__mulsf3+0x14>
    8630:	95 0f       	add	r25, r21
    8632:	50 e0       	ldi	r21, 0x00	; 0
    8634:	55 1f       	adc	r21, r21
    8636:	62 9f       	mul	r22, r18
    8638:	f0 01       	movw	r30, r0
    863a:	72 9f       	mul	r23, r18
    863c:	bb 27       	eor	r27, r27
    863e:	f0 0d       	add	r31, r0
    8640:	b1 1d       	adc	r27, r1
    8642:	63 9f       	mul	r22, r19
    8644:	aa 27       	eor	r26, r26
    8646:	f0 0d       	add	r31, r0
    8648:	b1 1d       	adc	r27, r1
    864a:	aa 1f       	adc	r26, r26
    864c:	64 9f       	mul	r22, r20
    864e:	66 27       	eor	r22, r22
    8650:	b0 0d       	add	r27, r0
    8652:	a1 1d       	adc	r26, r1
    8654:	66 1f       	adc	r22, r22
    8656:	82 9f       	mul	r24, r18
    8658:	22 27       	eor	r18, r18
    865a:	b0 0d       	add	r27, r0
    865c:	a1 1d       	adc	r26, r1
    865e:	62 1f       	adc	r22, r18
    8660:	73 9f       	mul	r23, r19
    8662:	b0 0d       	add	r27, r0
    8664:	a1 1d       	adc	r26, r1
    8666:	62 1f       	adc	r22, r18
    8668:	83 9f       	mul	r24, r19
    866a:	a0 0d       	add	r26, r0
    866c:	61 1d       	adc	r22, r1
    866e:	22 1f       	adc	r18, r18
    8670:	74 9f       	mul	r23, r20
    8672:	33 27       	eor	r19, r19
    8674:	a0 0d       	add	r26, r0
    8676:	61 1d       	adc	r22, r1
    8678:	23 1f       	adc	r18, r19
    867a:	84 9f       	mul	r24, r20
    867c:	60 0d       	add	r22, r0
    867e:	21 1d       	adc	r18, r1
    8680:	82 2f       	mov	r24, r18
    8682:	76 2f       	mov	r23, r22
    8684:	6a 2f       	mov	r22, r26
    8686:	11 24       	eor	r1, r1
    8688:	9f 57       	subi	r25, 0x7F	; 127
    868a:	50 40       	sbci	r21, 0x00	; 0
    868c:	8a f0       	brmi	.+34     	; 0x86b0 <__mulsf3_pse+0x84>
    868e:	e1 f0       	breq	.+56     	; 0x86c8 <__mulsf3_pse+0x9c>
    8690:	88 23       	and	r24, r24
    8692:	4a f0       	brmi	.+18     	; 0x86a6 <__mulsf3_pse+0x7a>
    8694:	ee 0f       	add	r30, r30
    8696:	ff 1f       	adc	r31, r31
    8698:	bb 1f       	adc	r27, r27
    869a:	66 1f       	adc	r22, r22
    869c:	77 1f       	adc	r23, r23
    869e:	88 1f       	adc	r24, r24
    86a0:	91 50       	subi	r25, 0x01	; 1
    86a2:	50 40       	sbci	r21, 0x00	; 0
    86a4:	a9 f7       	brne	.-22     	; 0x8690 <__mulsf3_pse+0x64>
    86a6:	9e 3f       	cpi	r25, 0xFE	; 254
    86a8:	51 05       	cpc	r21, r1
    86aa:	70 f0       	brcs	.+28     	; 0x86c8 <__mulsf3_pse+0x9c>
    86ac:	5c cf       	rjmp	.-328    	; 0x8566 <__fp_inf>
    86ae:	a6 cf       	rjmp	.-180    	; 0x85fc <__fp_szero>
    86b0:	5f 3f       	cpi	r21, 0xFF	; 255
    86b2:	ec f3       	brlt	.-6      	; 0x86ae <__mulsf3_pse+0x82>
    86b4:	98 3e       	cpi	r25, 0xE8	; 232
    86b6:	dc f3       	brlt	.-10     	; 0x86ae <__mulsf3_pse+0x82>
    86b8:	86 95       	lsr	r24
    86ba:	77 95       	ror	r23
    86bc:	67 95       	ror	r22
    86be:	b7 95       	ror	r27
    86c0:	f7 95       	ror	r31
    86c2:	e7 95       	ror	r30
    86c4:	9f 5f       	subi	r25, 0xFF	; 255
    86c6:	c1 f7       	brne	.-16     	; 0x86b8 <__mulsf3_pse+0x8c>
    86c8:	fe 2b       	or	r31, r30
    86ca:	88 0f       	add	r24, r24
    86cc:	91 1d       	adc	r25, r1
    86ce:	96 95       	lsr	r25
    86d0:	87 95       	ror	r24
    86d2:	97 f9       	bld	r25, 7
    86d4:	08 95       	ret

000086d6 <__udivmodsi4>:
    86d6:	a1 e2       	ldi	r26, 0x21	; 33
    86d8:	1a 2e       	mov	r1, r26
    86da:	aa 1b       	sub	r26, r26
    86dc:	bb 1b       	sub	r27, r27
    86de:	fd 01       	movw	r30, r26
    86e0:	0d c0       	rjmp	.+26     	; 0x86fc <__udivmodsi4_ep>

000086e2 <__udivmodsi4_loop>:
    86e2:	aa 1f       	adc	r26, r26
    86e4:	bb 1f       	adc	r27, r27
    86e6:	ee 1f       	adc	r30, r30
    86e8:	ff 1f       	adc	r31, r31
    86ea:	a2 17       	cp	r26, r18
    86ec:	b3 07       	cpc	r27, r19
    86ee:	e4 07       	cpc	r30, r20
    86f0:	f5 07       	cpc	r31, r21
    86f2:	20 f0       	brcs	.+8      	; 0x86fc <__udivmodsi4_ep>
    86f4:	a2 1b       	sub	r26, r18
    86f6:	b3 0b       	sbc	r27, r19
    86f8:	e4 0b       	sbc	r30, r20
    86fa:	f5 0b       	sbc	r31, r21

000086fc <__udivmodsi4_ep>:
    86fc:	66 1f       	adc	r22, r22
    86fe:	77 1f       	adc	r23, r23
    8700:	88 1f       	adc	r24, r24
    8702:	99 1f       	adc	r25, r25
    8704:	1a 94       	dec	r1
    8706:	69 f7       	brne	.-38     	; 0x86e2 <__udivmodsi4_loop>
    8708:	60 95       	com	r22
    870a:	70 95       	com	r23
    870c:	80 95       	com	r24
    870e:	90 95       	com	r25
    8710:	9b 01       	movw	r18, r22
    8712:	ac 01       	movw	r20, r24
    8714:	bd 01       	movw	r22, r26
    8716:	cf 01       	movw	r24, r30
    8718:	08 95       	ret

0000871a <__prologue_saves__>:
    871a:	2f 92       	push	r2
    871c:	3f 92       	push	r3
    871e:	4f 92       	push	r4
    8720:	5f 92       	push	r5
    8722:	6f 92       	push	r6
    8724:	7f 92       	push	r7
    8726:	8f 92       	push	r8
    8728:	9f 92       	push	r9
    872a:	af 92       	push	r10
    872c:	bf 92       	push	r11
    872e:	cf 92       	push	r12
    8730:	df 92       	push	r13
    8732:	ef 92       	push	r14
    8734:	ff 92       	push	r15
    8736:	0f 93       	push	r16
    8738:	1f 93       	push	r17
    873a:	cf 93       	push	r28
    873c:	df 93       	push	r29
    873e:	cd b7       	in	r28, 0x3d	; 61
    8740:	de b7       	in	r29, 0x3e	; 62
    8742:	ca 1b       	sub	r28, r26
    8744:	db 0b       	sbc	r29, r27
    8746:	0f b6       	in	r0, 0x3f	; 63
    8748:	f8 94       	cli
    874a:	de bf       	out	0x3e, r29	; 62
    874c:	0f be       	out	0x3f, r0	; 63
    874e:	cd bf       	out	0x3d, r28	; 61
    8750:	09 94       	ijmp

00008752 <__epilogue_restores__>:
    8752:	2a 88       	ldd	r2, Y+18	; 0x12
    8754:	39 88       	ldd	r3, Y+17	; 0x11
    8756:	48 88       	ldd	r4, Y+16	; 0x10
    8758:	5f 84       	ldd	r5, Y+15	; 0x0f
    875a:	6e 84       	ldd	r6, Y+14	; 0x0e
    875c:	7d 84       	ldd	r7, Y+13	; 0x0d
    875e:	8c 84       	ldd	r8, Y+12	; 0x0c
    8760:	9b 84       	ldd	r9, Y+11	; 0x0b
    8762:	aa 84       	ldd	r10, Y+10	; 0x0a
    8764:	b9 84       	ldd	r11, Y+9	; 0x09
    8766:	c8 84       	ldd	r12, Y+8	; 0x08
    8768:	df 80       	ldd	r13, Y+7	; 0x07
    876a:	ee 80       	ldd	r14, Y+6	; 0x06
    876c:	fd 80       	ldd	r15, Y+5	; 0x05
    876e:	0c 81       	ldd	r16, Y+4	; 0x04
    8770:	1b 81       	ldd	r17, Y+3	; 0x03
    8772:	aa 81       	ldd	r26, Y+2	; 0x02
    8774:	b9 81       	ldd	r27, Y+1	; 0x01
    8776:	ce 0f       	add	r28, r30
    8778:	d1 1d       	adc	r29, r1
    877a:	0f b6       	in	r0, 0x3f	; 63
    877c:	f8 94       	cli
    877e:	de bf       	out	0x3e, r29	; 62
    8780:	0f be       	out	0x3f, r0	; 63
    8782:	cd bf       	out	0x3d, r28	; 61
    8784:	ed 01       	movw	r28, r26
    8786:	08 95       	ret

00008788 <atoi>:
    8788:	fc 01       	movw	r30, r24
    878a:	88 27       	eor	r24, r24
    878c:	99 27       	eor	r25, r25
    878e:	e8 94       	clt
    8790:	21 91       	ld	r18, Z+
    8792:	20 32       	cpi	r18, 0x20	; 32
    8794:	e9 f3       	breq	.-6      	; 0x8790 <atoi+0x8>
    8796:	29 30       	cpi	r18, 0x09	; 9
    8798:	10 f0       	brcs	.+4      	; 0x879e <atoi+0x16>
    879a:	2e 30       	cpi	r18, 0x0E	; 14
    879c:	c8 f3       	brcs	.-14     	; 0x8790 <atoi+0x8>
    879e:	2b 32       	cpi	r18, 0x2B	; 43
    87a0:	41 f0       	breq	.+16     	; 0x87b2 <atoi+0x2a>
    87a2:	2d 32       	cpi	r18, 0x2D	; 45
    87a4:	39 f4       	brne	.+14     	; 0x87b4 <atoi+0x2c>
    87a6:	68 94       	set
    87a8:	04 c0       	rjmp	.+8      	; 0x87b2 <atoi+0x2a>
    87aa:	0e 94 0d 45 	call	0x8a1a	; 0x8a1a <__mulhi_const_10>
    87ae:	82 0f       	add	r24, r18
    87b0:	91 1d       	adc	r25, r1
    87b2:	21 91       	ld	r18, Z+
    87b4:	20 53       	subi	r18, 0x30	; 48
    87b6:	2a 30       	cpi	r18, 0x0A	; 10
    87b8:	c0 f3       	brcs	.-16     	; 0x87aa <atoi+0x22>
    87ba:	1e f4       	brtc	.+6      	; 0x87c2 <atoi+0x3a>
    87bc:	90 95       	com	r25
    87be:	81 95       	neg	r24
    87c0:	9f 4f       	sbci	r25, 0xFF	; 255
    87c2:	08 95       	ret

000087c4 <__ftoa_engine>:
    87c4:	28 30       	cpi	r18, 0x08	; 8
    87c6:	08 f0       	brcs	.+2      	; 0x87ca <__ftoa_engine+0x6>
    87c8:	27 e0       	ldi	r18, 0x07	; 7
    87ca:	33 27       	eor	r19, r19
    87cc:	da 01       	movw	r26, r20
    87ce:	99 0f       	add	r25, r25
    87d0:	31 1d       	adc	r19, r1
    87d2:	87 fd       	sbrc	r24, 7
    87d4:	91 60       	ori	r25, 0x01	; 1
    87d6:	00 96       	adiw	r24, 0x00	; 0
    87d8:	61 05       	cpc	r22, r1
    87da:	71 05       	cpc	r23, r1
    87dc:	39 f4       	brne	.+14     	; 0x87ec <__ftoa_engine+0x28>
    87de:	32 60       	ori	r19, 0x02	; 2
    87e0:	2e 5f       	subi	r18, 0xFE	; 254
    87e2:	3d 93       	st	X+, r19
    87e4:	30 e3       	ldi	r19, 0x30	; 48
    87e6:	2a 95       	dec	r18
    87e8:	e1 f7       	brne	.-8      	; 0x87e2 <__ftoa_engine+0x1e>
    87ea:	08 95       	ret
    87ec:	9f 3f       	cpi	r25, 0xFF	; 255
    87ee:	30 f0       	brcs	.+12     	; 0x87fc <__ftoa_engine+0x38>
    87f0:	80 38       	cpi	r24, 0x80	; 128
    87f2:	71 05       	cpc	r23, r1
    87f4:	61 05       	cpc	r22, r1
    87f6:	09 f0       	breq	.+2      	; 0x87fa <__ftoa_engine+0x36>
    87f8:	3c 5f       	subi	r19, 0xFC	; 252
    87fa:	3c 5f       	subi	r19, 0xFC	; 252
    87fc:	3d 93       	st	X+, r19
    87fe:	91 30       	cpi	r25, 0x01	; 1
    8800:	08 f0       	brcs	.+2      	; 0x8804 <__ftoa_engine+0x40>
    8802:	80 68       	ori	r24, 0x80	; 128
    8804:	91 1d       	adc	r25, r1
    8806:	df 93       	push	r29
    8808:	cf 93       	push	r28
    880a:	1f 93       	push	r17
    880c:	0f 93       	push	r16
    880e:	ff 92       	push	r15
    8810:	ef 92       	push	r14
    8812:	19 2f       	mov	r17, r25
    8814:	98 7f       	andi	r25, 0xF8	; 248
    8816:	96 95       	lsr	r25
    8818:	e9 2f       	mov	r30, r25
    881a:	96 95       	lsr	r25
    881c:	96 95       	lsr	r25
    881e:	e9 0f       	add	r30, r25
    8820:	ff 27       	eor	r31, r31
    8822:	e7 53       	subi	r30, 0x37	; 55
    8824:	f7 4f       	sbci	r31, 0xF7	; 247
    8826:	99 27       	eor	r25, r25
    8828:	33 27       	eor	r19, r19
    882a:	ee 24       	eor	r14, r14
    882c:	ff 24       	eor	r15, r15
    882e:	a7 01       	movw	r20, r14
    8830:	e7 01       	movw	r28, r14
    8832:	05 90       	lpm	r0, Z+
    8834:	08 94       	sec
    8836:	07 94       	ror	r0
    8838:	28 f4       	brcc	.+10     	; 0x8844 <__ftoa_engine+0x80>
    883a:	36 0f       	add	r19, r22
    883c:	e7 1e       	adc	r14, r23
    883e:	f8 1e       	adc	r15, r24
    8840:	49 1f       	adc	r20, r25
    8842:	51 1d       	adc	r21, r1
    8844:	66 0f       	add	r22, r22
    8846:	77 1f       	adc	r23, r23
    8848:	88 1f       	adc	r24, r24
    884a:	99 1f       	adc	r25, r25
    884c:	06 94       	lsr	r0
    884e:	a1 f7       	brne	.-24     	; 0x8838 <__ftoa_engine+0x74>
    8850:	05 90       	lpm	r0, Z+
    8852:	07 94       	ror	r0
    8854:	28 f4       	brcc	.+10     	; 0x8860 <__ftoa_engine+0x9c>
    8856:	e7 0e       	add	r14, r23
    8858:	f8 1e       	adc	r15, r24
    885a:	49 1f       	adc	r20, r25
    885c:	56 1f       	adc	r21, r22
    885e:	c1 1d       	adc	r28, r1
    8860:	77 0f       	add	r23, r23
    8862:	88 1f       	adc	r24, r24
    8864:	99 1f       	adc	r25, r25
    8866:	66 1f       	adc	r22, r22
    8868:	06 94       	lsr	r0
    886a:	a1 f7       	brne	.-24     	; 0x8854 <__ftoa_engine+0x90>
    886c:	05 90       	lpm	r0, Z+
    886e:	07 94       	ror	r0
    8870:	28 f4       	brcc	.+10     	; 0x887c <__ftoa_engine+0xb8>
    8872:	f8 0e       	add	r15, r24
    8874:	49 1f       	adc	r20, r25
    8876:	56 1f       	adc	r21, r22
    8878:	c7 1f       	adc	r28, r23
    887a:	d1 1d       	adc	r29, r1
    887c:	88 0f       	add	r24, r24
    887e:	99 1f       	adc	r25, r25
    8880:	66 1f       	adc	r22, r22
    8882:	77 1f       	adc	r23, r23
    8884:	06 94       	lsr	r0
    8886:	a1 f7       	brne	.-24     	; 0x8870 <__ftoa_engine+0xac>
    8888:	05 90       	lpm	r0, Z+
    888a:	07 94       	ror	r0
    888c:	20 f4       	brcc	.+8      	; 0x8896 <__ftoa_engine+0xd2>
    888e:	49 0f       	add	r20, r25
    8890:	56 1f       	adc	r21, r22
    8892:	c7 1f       	adc	r28, r23
    8894:	d8 1f       	adc	r29, r24
    8896:	99 0f       	add	r25, r25
    8898:	66 1f       	adc	r22, r22
    889a:	77 1f       	adc	r23, r23
    889c:	88 1f       	adc	r24, r24
    889e:	06 94       	lsr	r0
    88a0:	a9 f7       	brne	.-22     	; 0x888c <__ftoa_engine+0xc8>
    88a2:	84 91       	lpm	r24, Z+
    88a4:	10 95       	com	r17
    88a6:	17 70       	andi	r17, 0x07	; 7
    88a8:	41 f0       	breq	.+16     	; 0x88ba <__ftoa_engine+0xf6>
    88aa:	d6 95       	lsr	r29
    88ac:	c7 95       	ror	r28
    88ae:	57 95       	ror	r21
    88b0:	47 95       	ror	r20
    88b2:	f7 94       	ror	r15
    88b4:	e7 94       	ror	r14
    88b6:	1a 95       	dec	r17
    88b8:	c1 f7       	brne	.-16     	; 0x88aa <__ftoa_engine+0xe6>
    88ba:	ef e6       	ldi	r30, 0x6F	; 111
    88bc:	f8 e0       	ldi	r31, 0x08	; 8
    88be:	68 94       	set
    88c0:	15 90       	lpm	r1, Z+
    88c2:	15 91       	lpm	r17, Z+
    88c4:	35 91       	lpm	r19, Z+
    88c6:	65 91       	lpm	r22, Z+
    88c8:	95 91       	lpm	r25, Z+
    88ca:	05 90       	lpm	r0, Z+
    88cc:	7f e2       	ldi	r23, 0x2F	; 47
    88ce:	73 95       	inc	r23
    88d0:	e1 18       	sub	r14, r1
    88d2:	f1 0a       	sbc	r15, r17
    88d4:	43 0b       	sbc	r20, r19
    88d6:	56 0b       	sbc	r21, r22
    88d8:	c9 0b       	sbc	r28, r25
    88da:	d0 09       	sbc	r29, r0
    88dc:	c0 f7       	brcc	.-16     	; 0x88ce <__ftoa_engine+0x10a>
    88de:	e1 0c       	add	r14, r1
    88e0:	f1 1e       	adc	r15, r17
    88e2:	43 1f       	adc	r20, r19
    88e4:	56 1f       	adc	r21, r22
    88e6:	c9 1f       	adc	r28, r25
    88e8:	d0 1d       	adc	r29, r0
    88ea:	7e f4       	brtc	.+30     	; 0x890a <__ftoa_engine+0x146>
    88ec:	70 33       	cpi	r23, 0x30	; 48
    88ee:	11 f4       	brne	.+4      	; 0x88f4 <__ftoa_engine+0x130>
    88f0:	8a 95       	dec	r24
    88f2:	e6 cf       	rjmp	.-52     	; 0x88c0 <__ftoa_engine+0xfc>
    88f4:	e8 94       	clt
    88f6:	01 50       	subi	r16, 0x01	; 1
    88f8:	30 f0       	brcs	.+12     	; 0x8906 <__ftoa_engine+0x142>
    88fa:	08 0f       	add	r16, r24
    88fc:	0a f4       	brpl	.+2      	; 0x8900 <__ftoa_engine+0x13c>
    88fe:	00 27       	eor	r16, r16
    8900:	02 17       	cp	r16, r18
    8902:	08 f4       	brcc	.+2      	; 0x8906 <__ftoa_engine+0x142>
    8904:	20 2f       	mov	r18, r16
    8906:	23 95       	inc	r18
    8908:	02 2f       	mov	r16, r18
    890a:	7a 33       	cpi	r23, 0x3A	; 58
    890c:	28 f0       	brcs	.+10     	; 0x8918 <__ftoa_engine+0x154>
    890e:	79 e3       	ldi	r23, 0x39	; 57
    8910:	7d 93       	st	X+, r23
    8912:	2a 95       	dec	r18
    8914:	e9 f7       	brne	.-6      	; 0x8910 <__ftoa_engine+0x14c>
    8916:	10 c0       	rjmp	.+32     	; 0x8938 <__ftoa_engine+0x174>
    8918:	7d 93       	st	X+, r23
    891a:	2a 95       	dec	r18
    891c:	89 f6       	brne	.-94     	; 0x88c0 <__ftoa_engine+0xfc>
    891e:	06 94       	lsr	r0
    8920:	97 95       	ror	r25
    8922:	67 95       	ror	r22
    8924:	37 95       	ror	r19
    8926:	17 95       	ror	r17
    8928:	17 94       	ror	r1
    892a:	e1 18       	sub	r14, r1
    892c:	f1 0a       	sbc	r15, r17
    892e:	43 0b       	sbc	r20, r19
    8930:	56 0b       	sbc	r21, r22
    8932:	c9 0b       	sbc	r28, r25
    8934:	d0 09       	sbc	r29, r0
    8936:	98 f0       	brcs	.+38     	; 0x895e <__ftoa_engine+0x19a>
    8938:	23 95       	inc	r18
    893a:	7e 91       	ld	r23, -X
    893c:	73 95       	inc	r23
    893e:	7a 33       	cpi	r23, 0x3A	; 58
    8940:	08 f0       	brcs	.+2      	; 0x8944 <__ftoa_engine+0x180>
    8942:	70 e3       	ldi	r23, 0x30	; 48
    8944:	7c 93       	st	X, r23
    8946:	20 13       	cpse	r18, r16
    8948:	b8 f7       	brcc	.-18     	; 0x8938 <__ftoa_engine+0x174>
    894a:	7e 91       	ld	r23, -X
    894c:	70 61       	ori	r23, 0x10	; 16
    894e:	7d 93       	st	X+, r23
    8950:	30 f0       	brcs	.+12     	; 0x895e <__ftoa_engine+0x19a>
    8952:	83 95       	inc	r24
    8954:	71 e3       	ldi	r23, 0x31	; 49
    8956:	7d 93       	st	X+, r23
    8958:	70 e3       	ldi	r23, 0x30	; 48
    895a:	2a 95       	dec	r18
    895c:	e1 f7       	brne	.-8      	; 0x8956 <__ftoa_engine+0x192>
    895e:	11 24       	eor	r1, r1
    8960:	ef 90       	pop	r14
    8962:	ff 90       	pop	r15
    8964:	0f 91       	pop	r16
    8966:	1f 91       	pop	r17
    8968:	cf 91       	pop	r28
    896a:	df 91       	pop	r29
    896c:	99 27       	eor	r25, r25
    896e:	87 fd       	sbrc	r24, 7
    8970:	90 95       	com	r25
    8972:	08 95       	ret

00008974 <memcpy_P>:
    8974:	fb 01       	movw	r30, r22
    8976:	dc 01       	movw	r26, r24
    8978:	02 c0       	rjmp	.+4      	; 0x897e <memcpy_P+0xa>
    897a:	05 90       	lpm	r0, Z+
    897c:	0d 92       	st	X+, r0
    897e:	41 50       	subi	r20, 0x01	; 1
    8980:	50 40       	sbci	r21, 0x00	; 0
    8982:	d8 f7       	brcc	.-10     	; 0x897a <memcpy_P+0x6>
    8984:	08 95       	ret

00008986 <strnlen_P>:
    8986:	fc 01       	movw	r30, r24
    8988:	05 90       	lpm	r0, Z+
    898a:	61 50       	subi	r22, 0x01	; 1
    898c:	70 40       	sbci	r23, 0x00	; 0
    898e:	01 10       	cpse	r0, r1
    8990:	d8 f7       	brcc	.-10     	; 0x8988 <strnlen_P+0x2>
    8992:	80 95       	com	r24
    8994:	90 95       	com	r25
    8996:	8e 0f       	add	r24, r30
    8998:	9f 1f       	adc	r25, r31
    899a:	08 95       	ret

0000899c <memcmp>:
    899c:	fb 01       	movw	r30, r22
    899e:	dc 01       	movw	r26, r24
    89a0:	04 c0       	rjmp	.+8      	; 0x89aa <memcmp+0xe>
    89a2:	8d 91       	ld	r24, X+
    89a4:	01 90       	ld	r0, Z+
    89a6:	80 19       	sub	r24, r0
    89a8:	21 f4       	brne	.+8      	; 0x89b2 <memcmp+0x16>
    89aa:	41 50       	subi	r20, 0x01	; 1
    89ac:	50 40       	sbci	r21, 0x00	; 0
    89ae:	c8 f7       	brcc	.-14     	; 0x89a2 <memcmp+0x6>
    89b0:	88 1b       	sub	r24, r24
    89b2:	99 0b       	sbc	r25, r25
    89b4:	08 95       	ret

000089b6 <memcpy>:
    89b6:	fb 01       	movw	r30, r22
    89b8:	dc 01       	movw	r26, r24
    89ba:	02 c0       	rjmp	.+4      	; 0x89c0 <memcpy+0xa>
    89bc:	01 90       	ld	r0, Z+
    89be:	0d 92       	st	X+, r0
    89c0:	41 50       	subi	r20, 0x01	; 1
    89c2:	50 40       	sbci	r21, 0x00	; 0
    89c4:	d8 f7       	brcc	.-10     	; 0x89bc <memcpy+0x6>
    89c6:	08 95       	ret

000089c8 <memset>:
    89c8:	dc 01       	movw	r26, r24
    89ca:	01 c0       	rjmp	.+2      	; 0x89ce <memset+0x6>
    89cc:	6d 93       	st	X+, r22
    89ce:	41 50       	subi	r20, 0x01	; 1
    89d0:	50 40       	sbci	r21, 0x00	; 0
    89d2:	e0 f7       	brcc	.-8      	; 0x89cc <memset+0x4>
    89d4:	08 95       	ret

000089d6 <strlen>:
    89d6:	fc 01       	movw	r30, r24
    89d8:	01 90       	ld	r0, Z+
    89da:	00 20       	and	r0, r0
    89dc:	e9 f7       	brne	.-6      	; 0x89d8 <strlen+0x2>
    89de:	80 95       	com	r24
    89e0:	90 95       	com	r25
    89e2:	8e 0f       	add	r24, r30
    89e4:	9f 1f       	adc	r25, r31
    89e6:	08 95       	ret

000089e8 <strncmp>:
    89e8:	fb 01       	movw	r30, r22
    89ea:	dc 01       	movw	r26, r24
    89ec:	41 50       	subi	r20, 0x01	; 1
    89ee:	50 40       	sbci	r21, 0x00	; 0
    89f0:	30 f0       	brcs	.+12     	; 0x89fe <strncmp+0x16>
    89f2:	8d 91       	ld	r24, X+
    89f4:	01 90       	ld	r0, Z+
    89f6:	80 19       	sub	r24, r0
    89f8:	19 f4       	brne	.+6      	; 0x8a00 <strncmp+0x18>
    89fa:	00 20       	and	r0, r0
    89fc:	b9 f7       	brne	.-18     	; 0x89ec <strncmp+0x4>
    89fe:	88 1b       	sub	r24, r24
    8a00:	99 0b       	sbc	r25, r25
    8a02:	08 95       	ret

00008a04 <strnlen>:
    8a04:	fc 01       	movw	r30, r24
    8a06:	61 50       	subi	r22, 0x01	; 1
    8a08:	70 40       	sbci	r23, 0x00	; 0
    8a0a:	01 90       	ld	r0, Z+
    8a0c:	01 10       	cpse	r0, r1
    8a0e:	d8 f7       	brcc	.-10     	; 0x8a06 <strnlen+0x2>
    8a10:	80 95       	com	r24
    8a12:	90 95       	com	r25
    8a14:	8e 0f       	add	r24, r30
    8a16:	9f 1f       	adc	r25, r31
    8a18:	08 95       	ret

00008a1a <__mulhi_const_10>:
    8a1a:	7a e0       	ldi	r23, 0x0A	; 10
    8a1c:	97 9f       	mul	r25, r23
    8a1e:	90 2d       	mov	r25, r0
    8a20:	87 9f       	mul	r24, r23
    8a22:	80 2d       	mov	r24, r0
    8a24:	91 0d       	add	r25, r1
    8a26:	11 24       	eor	r1, r1
    8a28:	08 95       	ret

00008a2a <fgetc>:
    8a2a:	cf 93       	push	r28
    8a2c:	df 93       	push	r29
    8a2e:	ec 01       	movw	r28, r24
    8a30:	4b 81       	ldd	r20, Y+3	; 0x03
    8a32:	40 ff       	sbrs	r20, 0
    8a34:	1a c0       	rjmp	.+52     	; 0x8a6a <fgetc+0x40>
    8a36:	46 ff       	sbrs	r20, 6
    8a38:	0a c0       	rjmp	.+20     	; 0x8a4e <fgetc+0x24>
    8a3a:	4f 7b       	andi	r20, 0xBF	; 191
    8a3c:	4b 83       	std	Y+3, r20	; 0x03
    8a3e:	8e 81       	ldd	r24, Y+6	; 0x06
    8a40:	9f 81       	ldd	r25, Y+7	; 0x07
    8a42:	01 96       	adiw	r24, 0x01	; 1
    8a44:	9f 83       	std	Y+7, r25	; 0x07
    8a46:	8e 83       	std	Y+6, r24	; 0x06
    8a48:	8a 81       	ldd	r24, Y+2	; 0x02
    8a4a:	28 2f       	mov	r18, r24
    8a4c:	2b c0       	rjmp	.+86     	; 0x8aa4 <fgetc+0x7a>
    8a4e:	42 ff       	sbrs	r20, 2
    8a50:	13 c0       	rjmp	.+38     	; 0x8a78 <fgetc+0x4e>
    8a52:	e8 81       	ld	r30, Y
    8a54:	f9 81       	ldd	r31, Y+1	; 0x01
    8a56:	80 81       	ld	r24, Z
    8a58:	28 2f       	mov	r18, r24
    8a5a:	33 27       	eor	r19, r19
    8a5c:	27 fd       	sbrc	r18, 7
    8a5e:	30 95       	com	r19
    8a60:	21 15       	cp	r18, r1
    8a62:	31 05       	cpc	r19, r1
    8a64:	29 f4       	brne	.+10     	; 0x8a70 <fgetc+0x46>
    8a66:	40 62       	ori	r20, 0x20	; 32
    8a68:	4b 83       	std	Y+3, r20	; 0x03
    8a6a:	2f ef       	ldi	r18, 0xFF	; 255
    8a6c:	3f ef       	ldi	r19, 0xFF	; 255
    8a6e:	1b c0       	rjmp	.+54     	; 0x8aa6 <fgetc+0x7c>
    8a70:	31 96       	adiw	r30, 0x01	; 1
    8a72:	f9 83       	std	Y+1, r31	; 0x01
    8a74:	e8 83       	st	Y, r30
    8a76:	11 c0       	rjmp	.+34     	; 0x8a9a <fgetc+0x70>
    8a78:	ea 85       	ldd	r30, Y+10	; 0x0a
    8a7a:	fb 85       	ldd	r31, Y+11	; 0x0b
    8a7c:	ce 01       	movw	r24, r28
    8a7e:	09 95       	icall
    8a80:	9c 01       	movw	r18, r24
    8a82:	97 ff       	sbrs	r25, 7
    8a84:	0a c0       	rjmp	.+20     	; 0x8a9a <fgetc+0x70>
    8a86:	9b 81       	ldd	r25, Y+3	; 0x03
    8a88:	2f 5f       	subi	r18, 0xFF	; 255
    8a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    8a8c:	11 f0       	breq	.+4      	; 0x8a92 <fgetc+0x68>
    8a8e:	80 e2       	ldi	r24, 0x20	; 32
    8a90:	01 c0       	rjmp	.+2      	; 0x8a94 <fgetc+0x6a>
    8a92:	80 e1       	ldi	r24, 0x10	; 16
    8a94:	89 2b       	or	r24, r25
    8a96:	8b 83       	std	Y+3, r24	; 0x03
    8a98:	e8 cf       	rjmp	.-48     	; 0x8a6a <fgetc+0x40>
    8a9a:	8e 81       	ldd	r24, Y+6	; 0x06
    8a9c:	9f 81       	ldd	r25, Y+7	; 0x07
    8a9e:	01 96       	adiw	r24, 0x01	; 1
    8aa0:	9f 83       	std	Y+7, r25	; 0x07
    8aa2:	8e 83       	std	Y+6, r24	; 0x06
    8aa4:	30 e0       	ldi	r19, 0x00	; 0
    8aa6:	c9 01       	movw	r24, r18
    8aa8:	df 91       	pop	r29
    8aaa:	cf 91       	pop	r28
    8aac:	08 95       	ret

00008aae <fputc>:
    8aae:	0f 93       	push	r16
    8ab0:	1f 93       	push	r17
    8ab2:	cf 93       	push	r28
    8ab4:	df 93       	push	r29
    8ab6:	8c 01       	movw	r16, r24
    8ab8:	eb 01       	movw	r28, r22
    8aba:	8b 81       	ldd	r24, Y+3	; 0x03
    8abc:	81 ff       	sbrs	r24, 1
    8abe:	1b c0       	rjmp	.+54     	; 0x8af6 <fputc+0x48>
    8ac0:	82 ff       	sbrs	r24, 2
    8ac2:	0d c0       	rjmp	.+26     	; 0x8ade <fputc+0x30>
    8ac4:	2e 81       	ldd	r18, Y+6	; 0x06
    8ac6:	3f 81       	ldd	r19, Y+7	; 0x07
    8ac8:	8c 81       	ldd	r24, Y+4	; 0x04
    8aca:	9d 81       	ldd	r25, Y+5	; 0x05
    8acc:	28 17       	cp	r18, r24
    8ace:	39 07       	cpc	r19, r25
    8ad0:	64 f4       	brge	.+24     	; 0x8aea <fputc+0x3c>
    8ad2:	e8 81       	ld	r30, Y
    8ad4:	f9 81       	ldd	r31, Y+1	; 0x01
    8ad6:	01 93       	st	Z+, r16
    8ad8:	f9 83       	std	Y+1, r31	; 0x01
    8ada:	e8 83       	st	Y, r30
    8adc:	06 c0       	rjmp	.+12     	; 0x8aea <fputc+0x3c>
    8ade:	e8 85       	ldd	r30, Y+8	; 0x08
    8ae0:	f9 85       	ldd	r31, Y+9	; 0x09
    8ae2:	80 2f       	mov	r24, r16
    8ae4:	09 95       	icall
    8ae6:	89 2b       	or	r24, r25
    8ae8:	31 f4       	brne	.+12     	; 0x8af6 <fputc+0x48>
    8aea:	8e 81       	ldd	r24, Y+6	; 0x06
    8aec:	9f 81       	ldd	r25, Y+7	; 0x07
    8aee:	01 96       	adiw	r24, 0x01	; 1
    8af0:	9f 83       	std	Y+7, r25	; 0x07
    8af2:	8e 83       	std	Y+6, r24	; 0x06
    8af4:	02 c0       	rjmp	.+4      	; 0x8afa <fputc+0x4c>
    8af6:	0f ef       	ldi	r16, 0xFF	; 255
    8af8:	1f ef       	ldi	r17, 0xFF	; 255
    8afa:	c8 01       	movw	r24, r16
    8afc:	df 91       	pop	r29
    8afe:	cf 91       	pop	r28
    8b00:	1f 91       	pop	r17
    8b02:	0f 91       	pop	r16
    8b04:	08 95       	ret

00008b06 <fwrite>:
    8b06:	a0 e0       	ldi	r26, 0x00	; 0
    8b08:	b0 e0       	ldi	r27, 0x00	; 0
    8b0a:	e9 e8       	ldi	r30, 0x89	; 137
    8b0c:	f5 e4       	ldi	r31, 0x45	; 69
    8b0e:	0c 94 93 43 	jmp	0x8726	; 0x8726 <__prologue_saves__+0xc>
    8b12:	fc 01       	movw	r30, r24
    8b14:	4b 01       	movw	r8, r22
    8b16:	5a 01       	movw	r10, r20
    8b18:	69 01       	movw	r12, r18
    8b1a:	d9 01       	movw	r26, r18
    8b1c:	13 96       	adiw	r26, 0x03	; 3
    8b1e:	8c 91       	ld	r24, X
    8b20:	81 ff       	sbrs	r24, 1
    8b22:	1e c0       	rjmp	.+60     	; 0x8b60 <fwrite+0x5a>
    8b24:	7f 01       	movw	r14, r30
    8b26:	c0 e0       	ldi	r28, 0x00	; 0
    8b28:	d0 e0       	ldi	r29, 0x00	; 0
    8b2a:	14 c0       	rjmp	.+40     	; 0x8b54 <fwrite+0x4e>
    8b2c:	d6 01       	movw	r26, r12
    8b2e:	18 96       	adiw	r26, 0x08	; 8
    8b30:	ed 91       	ld	r30, X+
    8b32:	fc 91       	ld	r31, X
    8b34:	19 97       	sbiw	r26, 0x09	; 9
    8b36:	d7 01       	movw	r26, r14
    8b38:	8c 91       	ld	r24, X
    8b3a:	b6 01       	movw	r22, r12
    8b3c:	09 95       	icall
    8b3e:	89 2b       	or	r24, r25
    8b40:	89 f4       	brne	.+34     	; 0x8b64 <fwrite+0x5e>
    8b42:	08 94       	sec
    8b44:	e1 1c       	adc	r14, r1
    8b46:	f1 1c       	adc	r15, r1
    8b48:	0f 5f       	subi	r16, 0xFF	; 255
    8b4a:	1f 4f       	sbci	r17, 0xFF	; 255
    8b4c:	08 15       	cp	r16, r8
    8b4e:	19 05       	cpc	r17, r9
    8b50:	68 f3       	brcs	.-38     	; 0x8b2c <fwrite+0x26>
    8b52:	21 96       	adiw	r28, 0x01	; 1
    8b54:	ca 15       	cp	r28, r10
    8b56:	db 05       	cpc	r29, r11
    8b58:	28 f4       	brcc	.+10     	; 0x8b64 <fwrite+0x5e>
    8b5a:	00 e0       	ldi	r16, 0x00	; 0
    8b5c:	10 e0       	ldi	r17, 0x00	; 0
    8b5e:	f6 cf       	rjmp	.-20     	; 0x8b4c <fwrite+0x46>
    8b60:	c0 e0       	ldi	r28, 0x00	; 0
    8b62:	d0 e0       	ldi	r29, 0x00	; 0
    8b64:	ce 01       	movw	r24, r28
    8b66:	cd b7       	in	r28, 0x3d	; 61
    8b68:	de b7       	in	r29, 0x3e	; 62
    8b6a:	ec e0       	ldi	r30, 0x0C	; 12
    8b6c:	0c 94 af 43 	jmp	0x875e	; 0x875e <__epilogue_restores__+0xc>

00008b70 <printf>:
    8b70:	a0 e0       	ldi	r26, 0x00	; 0
    8b72:	b0 e0       	ldi	r27, 0x00	; 0
    8b74:	ee eb       	ldi	r30, 0xBE	; 190
    8b76:	f5 e4       	ldi	r31, 0x45	; 69
    8b78:	0c 94 9d 43 	jmp	0x873a	; 0x873a <__prologue_saves__+0x20>
    8b7c:	fe 01       	movw	r30, r28
    8b7e:	35 96       	adiw	r30, 0x05	; 5
    8b80:	61 91       	ld	r22, Z+
    8b82:	71 91       	ld	r23, Z+
    8b84:	80 91 5c 10 	lds	r24, 0x105C
    8b88:	90 91 5d 10 	lds	r25, 0x105D
    8b8c:	af 01       	movw	r20, r30
    8b8e:	0e 94 ce 3d 	call	0x7b9c	; 0x7b9c <vfprintf>
    8b92:	20 96       	adiw	r28, 0x00	; 0
    8b94:	e2 e0       	ldi	r30, 0x02	; 2
    8b96:	0c 94 b9 43 	jmp	0x8772	; 0x8772 <__epilogue_restores__+0x20>

00008b9a <putchar>:
    8b9a:	60 91 5c 10 	lds	r22, 0x105C
    8b9e:	70 91 5d 10 	lds	r23, 0x105D
    8ba2:	0e 94 57 45 	call	0x8aae	; 0x8aae <fputc>
    8ba6:	08 95       	ret

00008ba8 <puts>:
    8ba8:	0f 93       	push	r16
    8baa:	1f 93       	push	r17
    8bac:	cf 93       	push	r28
    8bae:	df 93       	push	r29
    8bb0:	8c 01       	movw	r16, r24
    8bb2:	e0 91 5c 10 	lds	r30, 0x105C
    8bb6:	f0 91 5d 10 	lds	r31, 0x105D
    8bba:	83 81       	ldd	r24, Z+3	; 0x03
    8bbc:	81 ff       	sbrs	r24, 1
    8bbe:	21 c0       	rjmp	.+66     	; 0x8c02 <puts+0x5a>
    8bc0:	c0 e0       	ldi	r28, 0x00	; 0
    8bc2:	d0 e0       	ldi	r29, 0x00	; 0
    8bc4:	0d c0       	rjmp	.+26     	; 0x8be0 <puts+0x38>
    8bc6:	e0 91 5c 10 	lds	r30, 0x105C
    8bca:	f0 91 5d 10 	lds	r31, 0x105D
    8bce:	20 85       	ldd	r18, Z+8	; 0x08
    8bd0:	31 85       	ldd	r19, Z+9	; 0x09
    8bd2:	bf 01       	movw	r22, r30
    8bd4:	f9 01       	movw	r30, r18
    8bd6:	09 95       	icall
    8bd8:	89 2b       	or	r24, r25
    8bda:	11 f0       	breq	.+4      	; 0x8be0 <puts+0x38>
    8bdc:	cf ef       	ldi	r28, 0xFF	; 255
    8bde:	df ef       	ldi	r29, 0xFF	; 255
    8be0:	f8 01       	movw	r30, r16
    8be2:	81 91       	ld	r24, Z+
    8be4:	8f 01       	movw	r16, r30
    8be6:	88 23       	and	r24, r24
    8be8:	71 f7       	brne	.-36     	; 0x8bc6 <puts+0x1e>
    8bea:	e0 91 5c 10 	lds	r30, 0x105C
    8bee:	f0 91 5d 10 	lds	r31, 0x105D
    8bf2:	20 85       	ldd	r18, Z+8	; 0x08
    8bf4:	31 85       	ldd	r19, Z+9	; 0x09
    8bf6:	8a e0       	ldi	r24, 0x0A	; 10
    8bf8:	bf 01       	movw	r22, r30
    8bfa:	f9 01       	movw	r30, r18
    8bfc:	09 95       	icall
    8bfe:	89 2b       	or	r24, r25
    8c00:	11 f0       	breq	.+4      	; 0x8c06 <puts+0x5e>
    8c02:	cf ef       	ldi	r28, 0xFF	; 255
    8c04:	df ef       	ldi	r29, 0xFF	; 255
    8c06:	ce 01       	movw	r24, r28
    8c08:	df 91       	pop	r29
    8c0a:	cf 91       	pop	r28
    8c0c:	1f 91       	pop	r17
    8c0e:	0f 91       	pop	r16
    8c10:	08 95       	ret

00008c12 <sprintf>:
    8c12:	ae e0       	ldi	r26, 0x0E	; 14
    8c14:	b0 e0       	ldi	r27, 0x00	; 0
    8c16:	ef e0       	ldi	r30, 0x0F	; 15
    8c18:	f6 e4       	ldi	r31, 0x46	; 70
    8c1a:	0c 94 9b 43 	jmp	0x8736	; 0x8736 <__prologue_saves__+0x1c>
    8c1e:	0d 89       	ldd	r16, Y+21	; 0x15
    8c20:	1e 89       	ldd	r17, Y+22	; 0x16
    8c22:	86 e0       	ldi	r24, 0x06	; 6
    8c24:	8c 83       	std	Y+4, r24	; 0x04
    8c26:	1a 83       	std	Y+2, r17	; 0x02
    8c28:	09 83       	std	Y+1, r16	; 0x01
    8c2a:	8f ef       	ldi	r24, 0xFF	; 255
    8c2c:	9f e7       	ldi	r25, 0x7F	; 127
    8c2e:	9e 83       	std	Y+6, r25	; 0x06
    8c30:	8d 83       	std	Y+5, r24	; 0x05
    8c32:	9e 01       	movw	r18, r28
    8c34:	27 5e       	subi	r18, 0xE7	; 231
    8c36:	3f 4f       	sbci	r19, 0xFF	; 255
    8c38:	ce 01       	movw	r24, r28
    8c3a:	01 96       	adiw	r24, 0x01	; 1
    8c3c:	6f 89       	ldd	r22, Y+23	; 0x17
    8c3e:	78 8d       	ldd	r23, Y+24	; 0x18
    8c40:	a9 01       	movw	r20, r18
    8c42:	0e 94 ce 3d 	call	0x7b9c	; 0x7b9c <vfprintf>
    8c46:	2f 81       	ldd	r18, Y+7	; 0x07
    8c48:	38 85       	ldd	r19, Y+8	; 0x08
    8c4a:	02 0f       	add	r16, r18
    8c4c:	13 1f       	adc	r17, r19
    8c4e:	f8 01       	movw	r30, r16
    8c50:	10 82       	st	Z, r1
    8c52:	2e 96       	adiw	r28, 0x0e	; 14
    8c54:	e4 e0       	ldi	r30, 0x04	; 4
    8c56:	0c 94 b7 43 	jmp	0x876e	; 0x876e <__epilogue_restores__+0x1c>

00008c5a <__ultoa_invert>:
    8c5a:	fa 01       	movw	r30, r20
    8c5c:	aa 27       	eor	r26, r26
    8c5e:	28 30       	cpi	r18, 0x08	; 8
    8c60:	51 f1       	breq	.+84     	; 0x8cb6 <__ultoa_invert+0x5c>
    8c62:	20 31       	cpi	r18, 0x10	; 16
    8c64:	81 f1       	breq	.+96     	; 0x8cc6 <__ultoa_invert+0x6c>
    8c66:	e8 94       	clt
    8c68:	6f 93       	push	r22
    8c6a:	6e 7f       	andi	r22, 0xFE	; 254
    8c6c:	6e 5f       	subi	r22, 0xFE	; 254
    8c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    8c70:	8f 4f       	sbci	r24, 0xFF	; 255
    8c72:	9f 4f       	sbci	r25, 0xFF	; 255
    8c74:	af 4f       	sbci	r26, 0xFF	; 255
    8c76:	b1 e0       	ldi	r27, 0x01	; 1
    8c78:	3e d0       	rcall	.+124    	; 0x8cf6 <__ultoa_invert+0x9c>
    8c7a:	b4 e0       	ldi	r27, 0x04	; 4
    8c7c:	3c d0       	rcall	.+120    	; 0x8cf6 <__ultoa_invert+0x9c>
    8c7e:	67 0f       	add	r22, r23
    8c80:	78 1f       	adc	r23, r24
    8c82:	89 1f       	adc	r24, r25
    8c84:	9a 1f       	adc	r25, r26
    8c86:	a1 1d       	adc	r26, r1
    8c88:	68 0f       	add	r22, r24
    8c8a:	79 1f       	adc	r23, r25
    8c8c:	8a 1f       	adc	r24, r26
    8c8e:	91 1d       	adc	r25, r1
    8c90:	a1 1d       	adc	r26, r1
    8c92:	6a 0f       	add	r22, r26
    8c94:	71 1d       	adc	r23, r1
    8c96:	81 1d       	adc	r24, r1
    8c98:	91 1d       	adc	r25, r1
    8c9a:	a1 1d       	adc	r26, r1
    8c9c:	20 d0       	rcall	.+64     	; 0x8cde <__ultoa_invert+0x84>
    8c9e:	09 f4       	brne	.+2      	; 0x8ca2 <__ultoa_invert+0x48>
    8ca0:	68 94       	set
    8ca2:	3f 91       	pop	r19
    8ca4:	2a e0       	ldi	r18, 0x0A	; 10
    8ca6:	26 9f       	mul	r18, r22
    8ca8:	11 24       	eor	r1, r1
    8caa:	30 19       	sub	r19, r0
    8cac:	30 5d       	subi	r19, 0xD0	; 208
    8cae:	31 93       	st	Z+, r19
    8cb0:	de f6       	brtc	.-74     	; 0x8c68 <__ultoa_invert+0xe>
    8cb2:	cf 01       	movw	r24, r30
    8cb4:	08 95       	ret
    8cb6:	46 2f       	mov	r20, r22
    8cb8:	47 70       	andi	r20, 0x07	; 7
    8cba:	40 5d       	subi	r20, 0xD0	; 208
    8cbc:	41 93       	st	Z+, r20
    8cbe:	b3 e0       	ldi	r27, 0x03	; 3
    8cc0:	0f d0       	rcall	.+30     	; 0x8ce0 <__ultoa_invert+0x86>
    8cc2:	c9 f7       	brne	.-14     	; 0x8cb6 <__ultoa_invert+0x5c>
    8cc4:	f6 cf       	rjmp	.-20     	; 0x8cb2 <__ultoa_invert+0x58>
    8cc6:	46 2f       	mov	r20, r22
    8cc8:	4f 70       	andi	r20, 0x0F	; 15
    8cca:	40 5d       	subi	r20, 0xD0	; 208
    8ccc:	4a 33       	cpi	r20, 0x3A	; 58
    8cce:	18 f0       	brcs	.+6      	; 0x8cd6 <__ultoa_invert+0x7c>
    8cd0:	49 5d       	subi	r20, 0xD9	; 217
    8cd2:	31 fd       	sbrc	r19, 1
    8cd4:	40 52       	subi	r20, 0x20	; 32
    8cd6:	41 93       	st	Z+, r20
    8cd8:	02 d0       	rcall	.+4      	; 0x8cde <__ultoa_invert+0x84>
    8cda:	a9 f7       	brne	.-22     	; 0x8cc6 <__ultoa_invert+0x6c>
    8cdc:	ea cf       	rjmp	.-44     	; 0x8cb2 <__ultoa_invert+0x58>
    8cde:	b4 e0       	ldi	r27, 0x04	; 4
    8ce0:	a6 95       	lsr	r26
    8ce2:	97 95       	ror	r25
    8ce4:	87 95       	ror	r24
    8ce6:	77 95       	ror	r23
    8ce8:	67 95       	ror	r22
    8cea:	ba 95       	dec	r27
    8cec:	c9 f7       	brne	.-14     	; 0x8ce0 <__ultoa_invert+0x86>
    8cee:	00 97       	sbiw	r24, 0x00	; 0
    8cf0:	61 05       	cpc	r22, r1
    8cf2:	71 05       	cpc	r23, r1
    8cf4:	08 95       	ret
    8cf6:	9b 01       	movw	r18, r22
    8cf8:	ac 01       	movw	r20, r24
    8cfa:	0a 2e       	mov	r0, r26
    8cfc:	06 94       	lsr	r0
    8cfe:	57 95       	ror	r21
    8d00:	47 95       	ror	r20
    8d02:	37 95       	ror	r19
    8d04:	27 95       	ror	r18
    8d06:	ba 95       	dec	r27
    8d08:	c9 f7       	brne	.-14     	; 0x8cfc <__ultoa_invert+0xa2>
    8d0a:	62 0f       	add	r22, r18
    8d0c:	73 1f       	adc	r23, r19
    8d0e:	84 1f       	adc	r24, r20
    8d10:	95 1f       	adc	r25, r21
    8d12:	a0 1d       	adc	r26, r0
    8d14:	08 95       	ret

00008d16 <_exit>:
    8d16:	f8 94       	cli

00008d18 <__stop_program>:
    8d18:	ff cf       	rjmp	.-2      	; 0x8d18 <__stop_program>
